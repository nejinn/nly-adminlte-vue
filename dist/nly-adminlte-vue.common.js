module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "fb15");
/******/ })
/************************************************************************/
/******/ ({

/***/ "00ee":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ "0366":
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__("1c0b");

// optional / simple context binding
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "0481":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var flattenIntoArray = __webpack_require__("a2bf");
var toObject = __webpack_require__("7b0b");
var toLength = __webpack_require__("50c4");
var toInteger = __webpack_require__("a691");
var arraySpeciesCreate = __webpack_require__("65f0");

// `Array.prototype.flat` method
// https://github.com/tc39/proposal-flatMap
$({ target: 'Array', proto: true }, {
  flat: function flat(/* depthArg = 1 */) {
    var depthArg = arguments.length ? arguments[0] : undefined;
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});


/***/ }),

/***/ "0538":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__("1c0b");
var isObject = __webpack_require__("861d");

var slice = [].slice;
var factories = {};

var construct = function (C, argsLength, args) {
  if (!(argsLength in factories)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
  } return factories[argsLength](C, args);
};

// `Function.prototype.bind` method implementation
// https://tc39.github.io/ecma262/#sec-function.prototype.bind
module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = slice.call(arguments, 1);
  var boundFunction = function bound(/* args... */) {
    var args = partArgs.concat(slice.call(arguments));
    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
  };
  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
  return boundFunction;
};


/***/ }),

/***/ "057f":
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__("fc6a");
var nativeGetOwnPropertyNames = __webpack_require__("241c").f;

var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return nativeGetOwnPropertyNames(it);
  } catch (error) {
    return windowNames.slice();
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]'
    ? getWindowNames(it)
    : nativeGetOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ "06cf":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var propertyIsEnumerableModule = __webpack_require__("d1e7");
var createPropertyDescriptor = __webpack_require__("5c6c");
var toIndexedObject = __webpack_require__("fc6a");
var toPrimitive = __webpack_require__("c04e");
var has = __webpack_require__("5135");
var IE8_DOM_DEFINE = __webpack_require__("0cfb");

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};


/***/ }),

/***/ "0cfb":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var fails = __webpack_require__("d039");
var createElement = __webpack_require__("cc12");

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ "1148":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__("a691");
var requireObjectCoercible = __webpack_require__("1d80");

// `String.prototype.repeat` method implementation
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
module.exports = ''.repeat || function repeat(count) {
  var str = String(requireObjectCoercible(this));
  var result = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};


/***/ }),

/***/ "1276":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
var isRegExp = __webpack_require__("44e7");
var anObject = __webpack_require__("825a");
var requireObjectCoercible = __webpack_require__("1d80");
var speciesConstructor = __webpack_require__("4840");
var advanceStringIndex = __webpack_require__("8aa5");
var toLength = __webpack_require__("50c4");
var callRegExpExec = __webpack_require__("14c3");
var regexpExec = __webpack_require__("9263");
var fails = __webpack_require__("d039");

var arrayPush = [].push;
var min = Math.min;
var MAX_UINT32 = 0xFFFFFFFF;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { return !RegExp(MAX_UINT32, 'y'); });

// @@split logic
fixRegExpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'.split(/(b)*/)[1] == 'c' ||
    'test'.split(/(?:)/, -1).length != 4 ||
    'ab'.split(/(?:ab)*/).length != 2 ||
    '.'.split(/(.?)(.?)/).length != 4 ||
    '.'.split(/()()/).length > 1 ||
    ''.split(/.?/).length
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(requireObjectCoercible(this));
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (separator === undefined) return [string];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) {
        return nativeSplit.call(string, separator, lim);
      }
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
          lastLength = match[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim) break;
        }
        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
      }
      if (lastLastIndex === string.length) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output.length > lim ? output.slice(0, lim) : output;
    };
  // Chakra, V8
  } else if ('0'.split(undefined, 0).length) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
    };
  } else internalSplit = nativeSplit;

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = requireObjectCoercible(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
}, !SUPPORTS_Y);


/***/ }),

/***/ "129f":
/***/ (function(module, exports) {

// `SameValue` abstract operation
// https://tc39.github.io/ecma262/#sec-samevalue
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),

/***/ "131a":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var setPrototypeOf = __webpack_require__("d2bb");

// `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
$({ target: 'Object', stat: true }, {
  setPrototypeOf: setPrototypeOf
});


/***/ }),

/***/ "13d5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $reduce = __webpack_require__("d58f").left;
var arrayMethodIsStrict = __webpack_require__("a640");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var STRICT_METHOD = arrayMethodIsStrict('reduce');
var USES_TO_LENGTH = arrayMethodUsesToLength('reduce', { 1: 0 });

// `Array.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
$({ target: 'Array', proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "14c3":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("c6b6");
var regexpExec = __webpack_require__("9263");

// `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }

  return regexpExec.call(R, S);
};



/***/ }),

/***/ "159b":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var DOMIterables = __webpack_require__("fdbc");
var forEach = __webpack_require__("17c2");
var createNonEnumerableProperty = __webpack_require__("9112");

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  // some Chrome versions have non-configurable methods on DOMTokenList
  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
  } catch (error) {
    CollectionPrototype.forEach = forEach;
  }
}


/***/ }),

/***/ "17c2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $forEach = __webpack_require__("b727").forEach;
var arrayMethodIsStrict = __webpack_require__("a640");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var STRICT_METHOD = arrayMethodIsStrict('forEach');
var USES_TO_LENGTH = arrayMethodUsesToLength('forEach');

// `Array.prototype.forEach` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
module.exports = (!STRICT_METHOD || !USES_TO_LENGTH) ? function forEach(callbackfn /* , thisArg */) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
} : [].forEach;


/***/ }),

/***/ "19aa":
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  } return it;
};


/***/ }),

/***/ "1be4":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("d066");

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ "1c0b":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  } return it;
};


/***/ }),

/***/ "1c7e":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line no-throw-literal
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ "1cdc":
/***/ (function(module, exports, __webpack_require__) {

var userAgent = __webpack_require__("342f");

module.exports = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);


/***/ }),

/***/ "1d80":
/***/ (function(module, exports) {

// `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "1dde":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var wellKnownSymbol = __webpack_require__("b622");
var V8_VERSION = __webpack_require__("2d00");

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),

/***/ "2266":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var isArrayIteratorMethod = __webpack_require__("e95a");
var toLength = __webpack_require__("50c4");
var bind = __webpack_require__("0366");
var getIteratorMethod = __webpack_require__("35a1");
var callWithSafeIterationClosing = __webpack_require__("9bdd");

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
  var boundFunction = bind(fn, that, AS_ENTRIES ? 2 : 1);
  var iterator, iterFn, index, length, result, next, step;

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = AS_ENTRIES
          ? boundFunction(anObject(step = iterable[index])[0], step[1])
          : boundFunction(iterable[index]);
        if (result && result instanceof Result) return result;
      } return new Result(false);
    }
    iterator = iterFn.call(iterable);
  }

  next = iterator.next;
  while (!(step = next.call(iterator)).done) {
    result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
    if (typeof result == 'object' && result && result instanceof Result) return result;
  } return new Result(false);
};

iterate.stop = function (result) {
  return new Result(true, result);
};


/***/ }),

/***/ "23cb":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("a691");

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "23e7":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
var createNonEnumerableProperty = __webpack_require__("9112");
var redefine = __webpack_require__("6eeb");
var setGlobal = __webpack_require__("ce4e");
var copyConstructorProperties = __webpack_require__("e893");
var isForced = __webpack_require__("94ca");

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ "241c":
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__("ca84");
var enumBugKeys = __webpack_require__("7839");

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "2532":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var notARegExp = __webpack_require__("5a34");
var requireObjectCoercible = __webpack_require__("1d80");
var correctIsRegExpLogic = __webpack_require__("ab13");

// `String.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-string.prototype.includes
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~String(requireObjectCoercible(this))
      .indexOf(notARegExp(searchString), arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "25f0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefine = __webpack_require__("6eeb");
var anObject = __webpack_require__("825a");
var fails = __webpack_require__("d039");
var flags = __webpack_require__("ad6d");

var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING];

var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = nativeToString.name != TO_STRING;

// `RegExp.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
  redefine(RegExp.prototype, TO_STRING, function toString() {
    var R = anObject(this);
    var p = String(R.source);
    var rf = R.flags;
    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? flags.call(R) : rf);
    return '/' + p + '/' + f;
  }, { unsafe: true });
}


/***/ }),

/***/ "2626":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getBuiltIn = __webpack_require__("d066");
var definePropertyModule = __webpack_require__("9bf2");
var wellKnownSymbol = __webpack_require__("b622");
var DESCRIPTORS = __webpack_require__("83ab");

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};


/***/ }),

/***/ "27b0":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDateUtil", function() { return getDateUtil; });
var getDateUtil = function getDateUtil() {
  var dateUtil = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "native";
  if (dateUtil instanceof Object) return dateUtil;else if (typeof dateUtil === "string" || dateUtil instanceof String) {
    return __webpack_require__("624e")("./" + dateUtil).default;
  }
};



/***/ }),

/***/ "2b19":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var is = __webpack_require__("129f");

// `Object.is` method
// https://tc39.github.io/ecma262/#sec-object.is
$({ target: 'Object', stat: true }, {
  is: is
});


/***/ }),

/***/ "2b88":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

 /*! 
  * portal-vue © Thorsten Lünborg, 2019 
  * 
  * Version: 2.1.7
  * 
  * LICENCE: MIT 
  * 
  * https://github.com/linusborg/portal-vue
  * 
 */



Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Vue = _interopDefault(__webpack_require__("8bbf"));

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var inBrowser = typeof window !== 'undefined';
function freeze(item) {
  if (Array.isArray(item) || _typeof(item) === 'object') {
    return Object.freeze(item);
  }

  return item;
}
function combinePassengers(transports) {
  var slotProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return transports.reduce(function (passengers, transport) {
    var temp = transport.passengers[0];
    var newPassengers = typeof temp === 'function' ? temp(slotProps) : transport.passengers;
    return passengers.concat(newPassengers);
  }, []);
}
function stableSort(array, compareFn) {
  return array.map(function (v, idx) {
    return [idx, v];
  }).sort(function (a, b) {
    return compareFn(a[1], b[1]) || a[0] - b[0];
  }).map(function (c) {
    return c[1];
  });
}
function pick(obj, keys) {
  return keys.reduce(function (acc, key) {
    if (obj.hasOwnProperty(key)) {
      acc[key] = obj[key];
    }

    return acc;
  }, {});
}

var transports = {};
var targets = {};
var sources = {};
var Wormhole = Vue.extend({
  data: function data() {
    return {
      transports: transports,
      targets: targets,
      sources: sources,
      trackInstances: inBrowser
    };
  },
  methods: {
    open: function open(transport) {
      if (!inBrowser) return;
      var to = transport.to,
          from = transport.from,
          passengers = transport.passengers,
          _transport$order = transport.order,
          order = _transport$order === void 0 ? Infinity : _transport$order;
      if (!to || !from || !passengers) return;
      var newTransport = {
        to: to,
        from: from,
        passengers: freeze(passengers),
        order: order
      };
      var keys = Object.keys(this.transports);

      if (keys.indexOf(to) === -1) {
        Vue.set(this.transports, to, []);
      }

      var currentIndex = this.$_getTransportIndex(newTransport); // Copying the array here so that the PortalTarget change event will actually contain two distinct arrays

      var newTransports = this.transports[to].slice(0);

      if (currentIndex === -1) {
        newTransports.push(newTransport);
      } else {
        newTransports[currentIndex] = newTransport;
      }

      this.transports[to] = stableSort(newTransports, function (a, b) {
        return a.order - b.order;
      });
    },
    close: function close(transport) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var to = transport.to,
          from = transport.from;
      if (!to || !from && force === false) return;

      if (!this.transports[to]) {
        return;
      }

      if (force) {
        this.transports[to] = [];
      } else {
        var index = this.$_getTransportIndex(transport);

        if (index >= 0) {
          // Copying the array here so that the PortalTarget change event will actually contain two distinct arrays
          var newTransports = this.transports[to].slice(0);
          newTransports.splice(index, 1);
          this.transports[to] = newTransports;
        }
      }
    },
    registerTarget: function registerTarget(target, vm, force) {
      if (!inBrowser) return;

      if (this.trackInstances && !force && this.targets[target]) {
        console.warn("[portal-vue]: Target ".concat(target, " already exists"));
      }

      this.$set(this.targets, target, Object.freeze([vm]));
    },
    unregisterTarget: function unregisterTarget(target) {
      this.$delete(this.targets, target);
    },
    registerSource: function registerSource(source, vm, force) {
      if (!inBrowser) return;

      if (this.trackInstances && !force && this.sources[source]) {
        console.warn("[portal-vue]: source ".concat(source, " already exists"));
      }

      this.$set(this.sources, source, Object.freeze([vm]));
    },
    unregisterSource: function unregisterSource(source) {
      this.$delete(this.sources, source);
    },
    hasTarget: function hasTarget(to) {
      return !!(this.targets[to] && this.targets[to][0]);
    },
    hasSource: function hasSource(to) {
      return !!(this.sources[to] && this.sources[to][0]);
    },
    hasContentFor: function hasContentFor(to) {
      return !!this.transports[to] && !!this.transports[to].length;
    },
    // Internal
    $_getTransportIndex: function $_getTransportIndex(_ref) {
      var to = _ref.to,
          from = _ref.from;

      for (var i in this.transports[to]) {
        if (this.transports[to][i].from === from) {
          return +i;
        }
      }

      return -1;
    }
  }
});
var wormhole = new Wormhole(transports);

var _id = 1;
var Portal = Vue.extend({
  name: 'portal',
  props: {
    disabled: {
      type: Boolean
    },
    name: {
      type: String,
      default: function _default() {
        return String(_id++);
      }
    },
    order: {
      type: Number,
      default: 0
    },
    slim: {
      type: Boolean
    },
    slotProps: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    tag: {
      type: String,
      default: 'DIV'
    },
    to: {
      type: String,
      default: function _default() {
        return String(Math.round(Math.random() * 10000000));
      }
    }
  },
  created: function created() {
    var _this = this;

    this.$nextTick(function () {
      wormhole.registerSource(_this.name, _this);
    });
  },
  mounted: function mounted() {
    if (!this.disabled) {
      this.sendUpdate();
    }
  },
  updated: function updated() {
    if (this.disabled) {
      this.clear();
    } else {
      this.sendUpdate();
    }
  },
  beforeDestroy: function beforeDestroy() {
    wormhole.unregisterSource(this.name);
    this.clear();
  },
  watch: {
    to: function to(newValue, oldValue) {
      oldValue && oldValue !== newValue && this.clear(oldValue);
      this.sendUpdate();
    }
  },
  methods: {
    clear: function clear(target) {
      var closer = {
        from: this.name,
        to: target || this.to
      };
      wormhole.close(closer);
    },
    normalizeSlots: function normalizeSlots() {
      return this.$scopedSlots.default ? [this.$scopedSlots.default] : this.$slots.default;
    },
    normalizeOwnChildren: function normalizeOwnChildren(children) {
      return typeof children === 'function' ? children(this.slotProps) : children;
    },
    sendUpdate: function sendUpdate() {
      var slotContent = this.normalizeSlots();

      if (slotContent) {
        var transport = {
          from: this.name,
          to: this.to,
          passengers: _toConsumableArray(slotContent),
          order: this.order
        };
        wormhole.open(transport);
      } else {
        this.clear();
      }
    }
  },
  render: function render(h) {
    var children = this.$slots.default || this.$scopedSlots.default || [];
    var Tag = this.tag;

    if (children && this.disabled) {
      return children.length <= 1 && this.slim ? this.normalizeOwnChildren(children)[0] : h(Tag, [this.normalizeOwnChildren(children)]);
    } else {
      return this.slim ? h() : h(Tag, {
        class: {
          'v-portal': true
        },
        style: {
          display: 'none'
        },
        key: 'v-portal-placeholder'
      });
    }
  }
});

var PortalTarget = Vue.extend({
  name: 'portalTarget',
  props: {
    multiple: {
      type: Boolean,
      default: false
    },
    name: {
      type: String,
      required: true
    },
    slim: {
      type: Boolean,
      default: false
    },
    slotProps: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    tag: {
      type: String,
      default: 'div'
    },
    transition: {
      type: [String, Object, Function]
    }
  },
  data: function data() {
    return {
      transports: wormhole.transports,
      firstRender: true
    };
  },
  created: function created() {
    var _this = this;

    this.$nextTick(function () {
      wormhole.registerTarget(_this.name, _this);
    });
  },
  watch: {
    ownTransports: function ownTransports() {
      this.$emit('change', this.children().length > 0);
    },
    name: function name(newVal, oldVal) {
      /**
       * TODO
       * This should warn as well ...
       */
      wormhole.unregisterTarget(oldVal);
      wormhole.registerTarget(newVal, this);
    }
  },
  mounted: function mounted() {
    var _this2 = this;

    if (this.transition) {
      this.$nextTick(function () {
        // only when we have a transition, because it causes a re-render
        _this2.firstRender = false;
      });
    }
  },
  beforeDestroy: function beforeDestroy() {
    wormhole.unregisterTarget(this.name);
  },
  computed: {
    ownTransports: function ownTransports() {
      var transports = this.transports[this.name] || [];

      if (this.multiple) {
        return transports;
      }

      return transports.length === 0 ? [] : [transports[transports.length - 1]];
    },
    passengers: function passengers() {
      return combinePassengers(this.ownTransports, this.slotProps);
    }
  },
  methods: {
    // can't be a computed prop because it has to "react" to $slot changes.
    children: function children() {
      return this.passengers.length !== 0 ? this.passengers : this.$scopedSlots.default ? this.$scopedSlots.default(this.slotProps) : this.$slots.default || [];
    },
    // can't be a computed prop because it has to "react" to this.children().
    noWrapper: function noWrapper() {
      var noWrapper = this.slim && !this.transition;

      if (noWrapper && this.children().length > 1) {
        console.warn('[portal-vue]: PortalTarget with `slim` option received more than one child element.');
      }

      return noWrapper;
    }
  },
  render: function render(h) {
    var noWrapper = this.noWrapper();
    var children = this.children();
    var Tag = this.transition || this.tag;
    return noWrapper ? children[0] : this.slim && !Tag ? h() : h(Tag, {
      props: {
        // if we have a transition component, pass the tag if it exists
        tag: this.transition && this.tag ? this.tag : undefined
      },
      class: {
        'vue-portal-target': true
      }
    }, children);
  }
});

var _id$1 = 0;
var portalProps = ['disabled', 'name', 'order', 'slim', 'slotProps', 'tag', 'to'];
var targetProps = ['multiple', 'transition'];
var MountingPortal = Vue.extend({
  name: 'MountingPortal',
  inheritAttrs: false,
  props: {
    append: {
      type: [Boolean, String]
    },
    bail: {
      type: Boolean
    },
    mountTo: {
      type: String,
      required: true
    },
    // Portal
    disabled: {
      type: Boolean
    },
    // name for the portal
    name: {
      type: String,
      default: function _default() {
        return 'mounted_' + String(_id$1++);
      }
    },
    order: {
      type: Number,
      default: 0
    },
    slim: {
      type: Boolean
    },
    slotProps: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    tag: {
      type: String,
      default: 'DIV'
    },
    // name for the target
    to: {
      type: String,
      default: function _default() {
        return String(Math.round(Math.random() * 10000000));
      }
    },
    // Target
    multiple: {
      type: Boolean,
      default: false
    },
    targetSlim: {
      type: Boolean
    },
    targetSlotProps: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    targetTag: {
      type: String,
      default: 'div'
    },
    transition: {
      type: [String, Object, Function]
    }
  },
  created: function created() {
    if (typeof document === 'undefined') return;
    var el = document.querySelector(this.mountTo);

    if (!el) {
      console.error("[portal-vue]: Mount Point '".concat(this.mountTo, "' not found in document"));
      return;
    }

    var props = this.$props; // Target already exists

    if (wormhole.targets[props.name]) {
      if (props.bail) {
        console.warn("[portal-vue]: Target ".concat(props.name, " is already mounted.\n        Aborting because 'bail: true' is set"));
      } else {
        this.portalTarget = wormhole.targets[props.name];
      }

      return;
    }

    var append = props.append;

    if (append) {
      var type = typeof append === 'string' ? append : 'DIV';
      var mountEl = document.createElement(type);
      el.appendChild(mountEl);
      el = mountEl;
    } // get props for target from $props
    // we have to rename a few of them


    var _props = pick(this.$props, targetProps);

    _props.slim = this.targetSlim;
    _props.tag = this.targetTag;
    _props.slotProps = this.targetSlotProps;
    _props.name = this.to;
    this.portalTarget = new PortalTarget({
      el: el,
      parent: this.$parent || this,
      propsData: _props
    });
  },
  beforeDestroy: function beforeDestroy() {
    var target = this.portalTarget;

    if (this.append) {
      var el = target.$el;
      el.parentNode.removeChild(el);
    }

    target.$destroy();
  },
  render: function render(h) {
    if (!this.portalTarget) {
      console.warn("[portal-vue] Target wasn't mounted");
      return h();
    } // if there's no "manual" scoped slot, so we create a <Portal> ourselves


    if (!this.$scopedSlots.manual) {
      var props = pick(this.$props, portalProps);
      return h(Portal, {
        props: props,
        attrs: this.$attrs,
        on: this.$listeners,
        scopedSlots: this.$scopedSlots
      }, this.$slots.default);
    } // else, we render the scoped slot


    var content = this.$scopedSlots.manual({
      to: this.to
    }); // if user used <template> for the scoped slot
    // content will be an array

    if (Array.isArray(content)) {
      content = content[0];
    }

    if (!content) return h();
    return content;
  }
});

function install(Vue$$1) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  Vue$$1.component(options.portalName || 'Portal', Portal);
  Vue$$1.component(options.portalTargetName || 'PortalTarget', PortalTarget);
  Vue$$1.component(options.MountingPortalName || 'MountingPortal', MountingPortal);
}

var index = {
  install: install
};

exports.default = index;
exports.Portal = Portal;
exports.PortalTarget = PortalTarget;
exports.MountingPortal = MountingPortal;
exports.Wormhole = wormhole;
//# sourceMappingURL=portal-vue.common.js.map


/***/ }),

/***/ "2cf4":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var fails = __webpack_require__("d039");
var classof = __webpack_require__("c6b6");
var bind = __webpack_require__("0366");
var html = __webpack_require__("1be4");
var createElement = __webpack_require__("cc12");
var IS_IOS = __webpack_require__("1cdc");

var location = global.location;
var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function (id) {
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var listener = function (event) {
  run(event.data);
};

var post = function (id) {
  // old engines have not location.origin
  global.postMessage(id + '', location.protocol + '//' + location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (classof(process) == 'process') {
    defer = function (id) {
      process.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (
    global.addEventListener &&
    typeof postMessage == 'function' &&
    !global.importScripts &&
    !fails(post) &&
    location.protocol !== 'file:'
  ) {
    defer = post;
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};


/***/ }),

/***/ "2d00":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var userAgent = __webpack_require__("342f");

var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

module.exports = version && +version;


/***/ }),

/***/ "3410":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var fails = __webpack_require__("d039");
var toObject = __webpack_require__("7b0b");
var nativeGetPrototypeOf = __webpack_require__("e163");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__("e177");

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetPrototypeOf(1); });

// `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject(it));
  }
});



/***/ }),

/***/ "342f":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("d066");

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ "35a1":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("f5df");
var Iterators = __webpack_require__("3f8c");
var wellKnownSymbol = __webpack_require__("b622");

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "37e8":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var definePropertyModule = __webpack_require__("9bf2");
var anObject = __webpack_require__("825a");
var objectKeys = __webpack_require__("df75");

// `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties
module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
  return O;
};


/***/ }),

/***/ "3bbe":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");

module.exports = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  } return it;
};


/***/ }),

/***/ "3ca3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var charAt = __webpack_require__("6547").charAt;
var InternalStateModule = __webpack_require__("69f3");
var defineIterator = __webpack_require__("7dd0");

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = charAt(string, index);
  state.index += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "3f8c":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "4069":
/***/ (function(module, exports, __webpack_require__) {

// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = __webpack_require__("44d2");

addToUnscopables('flat');


/***/ }),

/***/ "408a":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("c6b6");

// `thisNumberValue` abstract operation
// https://tc39.github.io/ecma262/#sec-thisnumbervalue
module.exports = function (value) {
  if (typeof value != 'number' && classof(value) != 'Number') {
    throw TypeError('Incorrect invocation');
  }
  return +value;
};


/***/ }),

/***/ "4160":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var forEach = __webpack_require__("17c2");

// `Array.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
$({ target: 'Array', proto: true, forced: [].forEach != forEach }, {
  forEach: forEach
});


/***/ }),

/***/ "428f":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

module.exports = global;


/***/ }),

/***/ "4362":
/***/ (function(module, exports, __webpack_require__) {

exports.nextTick = function nextTick(fn) {
    var args = Array.prototype.slice.call(arguments);
    args.shift();
    setTimeout(function () {
        fn.apply(null, args);
    }, 0);
};

exports.platform = exports.arch = 
exports.execPath = exports.title = 'browser';
exports.pid = 1;
exports.browser = true;
exports.env = {};
exports.argv = [];

exports.binding = function (name) {
	throw new Error('No such module. (Possibly not yet loaded)')
};

(function () {
    var cwd = '/';
    var path;
    exports.cwd = function () { return cwd };
    exports.chdir = function (dir) {
        if (!path) path = __webpack_require__("df7c");
        cwd = path.resolve(dir, cwd);
    };
})();

exports.exit = exports.kill = 
exports.umask = exports.dlopen = 
exports.uptime = exports.memoryUsage = 
exports.uvCounters = function() {};
exports.features = {};


/***/ }),

/***/ "44ad":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var classof = __webpack_require__("c6b6");

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;


/***/ }),

/***/ "44d2":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");
var create = __webpack_require__("7c73");
var definePropertyModule = __webpack_require__("9bf2");

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "44de":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

module.exports = function (a, b) {
  var console = global.console;
  if (console && console.error) {
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  }
};


/***/ }),

/***/ "44e7":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");
var classof = __webpack_require__("c6b6");
var wellKnownSymbol = __webpack_require__("b622");

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.github.io/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};


/***/ }),

/***/ "45fc":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $some = __webpack_require__("b727").some;
var arrayMethodIsStrict = __webpack_require__("a640");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var STRICT_METHOD = arrayMethodIsStrict('some');
var USES_TO_LENGTH = arrayMethodUsesToLength('some');

// `Array.prototype.some` method
// https://tc39.github.io/ecma262/#sec-array.prototype.some
$({ target: 'Array', proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "466d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
var anObject = __webpack_require__("825a");
var toLength = __webpack_require__("50c4");
var requireObjectCoercible = __webpack_require__("1d80");
var advanceStringIndex = __webpack_require__("8aa5");
var regExpExec = __webpack_require__("14c3");

// @@match logic
fixRegExpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = requireObjectCoercible(this);
      var matcher = regexp == undefined ? undefined : regexp[MATCH];
      return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative(nativeMatch, regexp, this);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);

      if (!rx.global) return regExpExec(rx, S);

      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});


/***/ }),

/***/ "4840":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var aFunction = __webpack_require__("1c0b");
var wellKnownSymbol = __webpack_require__("b622");

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.github.io/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
};


/***/ }),

/***/ "4930":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  // Chrome 38 Symbol has incorrect toString conversion
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});


/***/ }),

/***/ "498a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $trim = __webpack_require__("58a8").trim;
var forcedStringTrimMethod = __webpack_require__("c8d2");

// `String.prototype.trim` method
// https://tc39.github.io/ecma262/#sec-string.prototype.trim
$({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {
  trim: function trim() {
    return $trim(this);
  }
});


/***/ }),

/***/ "4ae1":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var getBuiltIn = __webpack_require__("d066");
var aFunction = __webpack_require__("1c0b");
var anObject = __webpack_require__("825a");
var isObject = __webpack_require__("861d");
var create = __webpack_require__("7c73");
var bind = __webpack_require__("0538");
var fails = __webpack_require__("d039");

var nativeConstruct = getBuiltIn('Reflect', 'construct');

// `Reflect.construct` method
// https://tc39.github.io/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  nativeConstruct(function () { /* empty */ });
});
var FORCED = NEW_TARGET_BUG || ARGS_BUG;

$({ target: 'Reflect', stat: true, forced: FORCED, sham: FORCED }, {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),

/***/ "4d63":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var global = __webpack_require__("da84");
var isForced = __webpack_require__("94ca");
var inheritIfRequired = __webpack_require__("7156");
var defineProperty = __webpack_require__("9bf2").f;
var getOwnPropertyNames = __webpack_require__("241c").f;
var isRegExp = __webpack_require__("44e7");
var getFlags = __webpack_require__("ad6d");
var stickyHelpers = __webpack_require__("9f7f");
var redefine = __webpack_require__("6eeb");
var fails = __webpack_require__("d039");
var setInternalState = __webpack_require__("69f3").set;
var setSpecies = __webpack_require__("2626");
var wellKnownSymbol = __webpack_require__("b622");

var MATCH = wellKnownSymbol('match');
var NativeRegExp = global.RegExp;
var RegExpPrototype = NativeRegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;

// "new" should create a new object, old webkit bug
var CORRECT_NEW = new NativeRegExp(re1) !== re1;

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;

var FORCED = DESCRIPTORS && isForced('RegExp', (!CORRECT_NEW || UNSUPPORTED_Y || fails(function () {
  re2[MATCH] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
})));

// `RegExp` constructor
// https://tc39.github.io/ecma262/#sec-regexp-constructor
if (FORCED) {
  var RegExpWrapper = function RegExp(pattern, flags) {
    var thisIsRegExp = this instanceof RegExpWrapper;
    var patternIsRegExp = isRegExp(pattern);
    var flagsAreUndefined = flags === undefined;
    var sticky;

    if (!thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined) {
      return pattern;
    }

    if (CORRECT_NEW) {
      if (patternIsRegExp && !flagsAreUndefined) pattern = pattern.source;
    } else if (pattern instanceof RegExpWrapper) {
      if (flagsAreUndefined) flags = getFlags.call(pattern);
      pattern = pattern.source;
    }

    if (UNSUPPORTED_Y) {
      sticky = !!flags && flags.indexOf('y') > -1;
      if (sticky) flags = flags.replace(/y/g, '');
    }

    var result = inheritIfRequired(
      CORRECT_NEW ? new NativeRegExp(pattern, flags) : NativeRegExp(pattern, flags),
      thisIsRegExp ? this : RegExpPrototype,
      RegExpWrapper
    );

    if (UNSUPPORTED_Y && sticky) setInternalState(result, { sticky: sticky });

    return result;
  };
  var proxy = function (key) {
    key in RegExpWrapper || defineProperty(RegExpWrapper, key, {
      configurable: true,
      get: function () { return NativeRegExp[key]; },
      set: function (it) { NativeRegExp[key] = it; }
    });
  };
  var keys = getOwnPropertyNames(NativeRegExp);
  var index = 0;
  while (keys.length > index) proxy(keys[index++]);
  RegExpPrototype.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype;
  redefine(global, 'RegExp', RegExpWrapper);
}

// https://tc39.github.io/ecma262/#sec-get-regexp-@@species
setSpecies('RegExp');


/***/ }),

/***/ "4d64":
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__("fc6a");
var toLength = __webpack_require__("50c4");
var toAbsoluteIndex = __webpack_require__("23cb");

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ "4de4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $filter = __webpack_require__("b727").filter;
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');
// Edge 14- issue
var USES_TO_LENGTH = arrayMethodUsesToLength('filter');

// `Array.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-array.prototype.filter
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "4df4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var bind = __webpack_require__("0366");
var toObject = __webpack_require__("7b0b");
var callWithSafeIterationClosing = __webpack_require__("9bdd");
var isArrayIteratorMethod = __webpack_require__("e95a");
var toLength = __webpack_require__("50c4");
var createProperty = __webpack_require__("8418");
var getIteratorMethod = __webpack_require__("35a1");

// `Array.from` method implementation
// https://tc39.github.io/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var C = typeof this == 'function' ? this : Array;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    result = new C();
    for (;!(step = next.call(iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = toLength(O.length);
    result = new C(length);
    for (;length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }
  result.length = index;
  return result;
};


/***/ }),

/***/ "4ec9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var collection = __webpack_require__("6d61");
var collectionStrong = __webpack_require__("6566");

// `Map` constructor
// https://tc39.github.io/ecma262/#sec-map-objects
module.exports = collection('Map', function (init) {
  return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);


/***/ }),

/***/ "50c4":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("a691");

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "5135":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "52b6":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "5319":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
var anObject = __webpack_require__("825a");
var toObject = __webpack_require__("7b0b");
var toLength = __webpack_require__("50c4");
var toInteger = __webpack_require__("a691");
var requireObjectCoercible = __webpack_require__("1d80");
var advanceStringIndex = __webpack_require__("8aa5");
var regExpExec = __webpack_require__("14c3");

var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
fixRegExpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = requireObjectCoercible(this);
      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
      return replacer !== undefined
        ? replacer.call(searchValue, O, replaceValue)
        : nativeReplace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      if (
        (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0) ||
        (typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)
      ) {
        var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
        if (res.done) return res.value;
      }

      var rx = anObject(regexp);
      var S = String(this);

      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);

      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;

        results.push(result);
        if (!global) break;

        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }

      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];

        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

  // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return nativeReplace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});


/***/ }),

/***/ "53ca":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _typeof; });
/* harmony import */ var core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("a4d3");
/* harmony import */ var core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("e01a");
/* harmony import */ var core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_symbol_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("d28b");
/* harmony import */ var core_js_modules_es_symbol_iterator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_iterator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("e260");
/* harmony import */ var core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("d3b7");
/* harmony import */ var core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("3ca3");
/* harmony import */ var core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_web_dom_collections_iterator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("ddb0");
/* harmony import */ var core_js_modules_web_dom_collections_iterator__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_iterator__WEBPACK_IMPORTED_MODULE_6__);







function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

/***/ }),

/***/ "5530":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _objectSpread2; });
/* harmony import */ var core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("a4d3");
/* harmony import */ var core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("4de4");
/* harmony import */ var core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_array_for_each__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("4160");
/* harmony import */ var core_js_modules_es_array_for_each__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_for_each__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("e439");
/* harmony import */ var core_js_modules_es_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("dbb4");
/* harmony import */ var core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_object_keys__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("b64b");
/* harmony import */ var core_js_modules_es_object_keys__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_keys__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("159b");
/* harmony import */ var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("ade3");









function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

/***/ }),

/***/ "5692":
/***/ (function(module, exports, __webpack_require__) {

var IS_PURE = __webpack_require__("c430");
var store = __webpack_require__("c6cd");

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.6.5',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "56ef":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("d066");
var getOwnPropertyNamesModule = __webpack_require__("241c");
var getOwnPropertySymbolsModule = __webpack_require__("7418");
var anObject = __webpack_require__("825a");

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ "5899":
/***/ (function(module, exports) {

// a string of all valid unicode whitespaces
// eslint-disable-next-line max-len
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ "58a8":
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__("1d80");
var whitespaces = __webpack_require__("5899");

var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = String(requireObjectCoercible($this));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};


/***/ }),

/***/ "5a34":
/***/ (function(module, exports, __webpack_require__) {

var isRegExp = __webpack_require__("44e7");

module.exports = function (it) {
  if (isRegExp(it)) {
    throw TypeError("The method doesn't accept regular expressions");
  } return it;
};


/***/ }),

/***/ "5c6c":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "5d41":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var isObject = __webpack_require__("861d");
var anObject = __webpack_require__("825a");
var has = __webpack_require__("5135");
var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
var getPrototypeOf = __webpack_require__("e163");

// `Reflect.get` method
// https://tc39.github.io/ecma262/#sec-reflect.get
function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var descriptor, prototype;
  if (anObject(target) === receiver) return target[propertyKey];
  if (descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey)) return has(descriptor, 'value')
    ? descriptor.value
    : descriptor.get === undefined
      ? undefined
      : descriptor.get.call(receiver);
  if (isObject(prototype = getPrototypeOf(target))) return get(prototype, propertyKey, receiver);
}

$({ target: 'Reflect', stat: true }, {
  get: get
});


/***/ }),

/***/ "60da":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__("83ab");
var fails = __webpack_require__("d039");
var objectKeys = __webpack_require__("df75");
var getOwnPropertySymbolsModule = __webpack_require__("7418");
var propertyIsEnumerableModule = __webpack_require__("d1e7");
var toObject = __webpack_require__("7b0b");
var IndexedObject = __webpack_require__("44ad");

var nativeAssign = Object.assign;
var defineProperty = Object.defineProperty;

// `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
module.exports = !nativeAssign || fails(function () {
  // should have correct order of operations (Edge bug)
  if (DESCRIPTORS && nativeAssign({ b: 1 }, nativeAssign(defineProperty({}, 'a', {
    enumerable: true,
    get: function () {
      defineProperty(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1) return true;
  // should work with symbols and should have deterministic property order (V8 bug)
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];
    }
  } return T;
} : nativeAssign;


/***/ }),

/***/ "624e":
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./dateformat": "b77e",
	"./dateformat.js": "b77e",
	"./native": "b058",
	"./native.js": "b058",
	"./util": "27b0",
	"./util.js": "27b0"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "624e";

/***/ }),

/***/ "62e4":
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "6547":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("a691");
var requireObjectCoercible = __webpack_require__("1d80");

// `String.prototype.{ codePointAt, at }` methods implementation
var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING ? S.charAt(position) : first
        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ "6566":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var defineProperty = __webpack_require__("9bf2").f;
var create = __webpack_require__("7c73");
var redefineAll = __webpack_require__("e2cc");
var bind = __webpack_require__("0366");
var anInstance = __webpack_require__("19aa");
var iterate = __webpack_require__("2266");
var defineIterator = __webpack_require__("7dd0");
var setSpecies = __webpack_require__("2626");
var DESCRIPTORS = __webpack_require__("83ab");
var fastKey = __webpack_require__("f183").fastKey;
var InternalStateModule = __webpack_require__("69f3");

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, CONSTRUCTOR_NAME);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        index: create(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!DESCRIPTORS) that.size = 0;
      if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
    });

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index;
      // change existing entry
      if (entry) {
        entry.value = value;
      // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS) state.size++;
        else that.size++;
        // add to index
        if (index !== 'F') state.index[index] = entry;
      } return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that);
      // fast case
      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index];
      // frozen object case
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }
        state.first = state.last = undefined;
        if (DESCRIPTORS) state.size = 0;
        else that.size = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (DESCRIPTORS) state.size--;
          else that.size--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        var state = getInternalState(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          // revert to the last existing entry
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });

    redefineAll(C.prototype, IS_MAP ? {
      // 23.1.3.6 Map.prototype.get(key)
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // 23.1.3.9 Map.prototype.set(key, value)
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // 23.2.3.1 Set.prototype.add(value)
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS) defineProperty(C.prototype, 'size', {
      get: function () {
        return getInternalState(this).size;
      }
    });
    return C;
  },
  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      // revert to the last existing entry
      while (entry && entry.removed) entry = entry.previous;
      // get next entry
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return { value: undefined, done: true };
      }
      // return step by kind
      if (kind == 'keys') return { value: entry.key, done: false };
      if (kind == 'values') return { value: entry.value, done: false };
      return { value: [entry.key, entry.value], done: false };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(CONSTRUCTOR_NAME);
  }
};


/***/ }),

/***/ "65f0":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");
var isArray = __webpack_require__("e8b5");
var wellKnownSymbol = __webpack_require__("b622");

var SPECIES = wellKnownSymbol('species');

// `ArraySpeciesCreate` abstract operation
// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};


/***/ }),

/***/ "69f3":
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__("7f9a");
var global = __webpack_require__("da84");
var isObject = __webpack_require__("861d");
var createNonEnumerableProperty = __webpack_require__("9112");
var objectHas = __webpack_require__("5135");
var sharedKey = __webpack_require__("f772");
var hiddenKeys = __webpack_require__("d012");

var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = new WeakMap();
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "6d61":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var isForced = __webpack_require__("94ca");
var redefine = __webpack_require__("6eeb");
var InternalMetadataModule = __webpack_require__("f183");
var iterate = __webpack_require__("2266");
var anInstance = __webpack_require__("19aa");
var isObject = __webpack_require__("861d");
var fails = __webpack_require__("d039");
var checkCorrectnessOfIteration = __webpack_require__("1c7e");
var setToStringTag = __webpack_require__("d44e");
var inheritIfRequired = __webpack_require__("7156");

module.exports = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};

  var fixMethod = function (KEY) {
    var nativeMethod = NativePrototype[KEY];
    redefine(NativePrototype, KEY,
      KEY == 'add' ? function add(value) {
        nativeMethod.call(this, value === 0 ? 0 : value);
        return this;
      } : KEY == 'delete' ? function (key) {
        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
      } : KEY == 'get' ? function get(key) {
        return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
      } : KEY == 'has' ? function has(key) {
        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
      } : function set(key, value) {
        nativeMethod.call(this, key === 0 ? 0 : key, value);
        return this;
      }
    );
  };

  // eslint-disable-next-line max-len
  if (isForced(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
    new NativeConstructor().entries().next();
  })))) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.REQUIRED = true;
  } else if (isForced(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

    // weak collections should not contains .clear method
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;
  $({ global: true, forced: Constructor != NativeConstructor }, exported);

  setToStringTag(Constructor, CONSTRUCTOR_NAME);

  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

  return Constructor;
};


/***/ }),

/***/ "6eeb":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var createNonEnumerableProperty = __webpack_require__("9112");
var has = __webpack_require__("5135");
var setGlobal = __webpack_require__("ce4e");
var inspectSource = __webpack_require__("8925");
var InternalStateModule = __webpack_require__("69f3");

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});


/***/ }),

/***/ "7039":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var fails = __webpack_require__("d039");
var nativeGetOwnPropertyNames = __webpack_require__("057f").f;

var FAILS_ON_PRIMITIVES = fails(function () { return !Object.getOwnPropertyNames(1); });

// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  getOwnPropertyNames: nativeGetOwnPropertyNames
});


/***/ }),

/***/ "7156":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");
var setPrototypeOf = __webpack_require__("d2bb");

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    typeof (NewTarget = dummy.constructor) == 'function' &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),

/***/ "7418":
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "746f":
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__("428f");
var has = __webpack_require__("5135");
var wrappedWellKnownSymbolModule = __webpack_require__("e538");
var defineProperty = __webpack_require__("9bf2").f;

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),

/***/ "7839":
/***/ (function(module, exports) {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "7b0b":
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__("1d80");

// `ToObject` abstract operation
// https://tc39.github.io/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "7c73":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var defineProperties = __webpack_require__("37e8");
var enumBugKeys = __webpack_require__("7839");
var hiddenKeys = __webpack_require__("d012");
var html = __webpack_require__("1be4");
var documentCreateElement = __webpack_require__("cc12");
var sharedKey = __webpack_require__("f772");

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    /* global ActiveXObject */
    activeXDocument = document.domain && new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.github.io/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : defineProperties(result, Properties);
};


/***/ }),

/***/ "7db0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $find = __webpack_require__("b727").find;
var addToUnscopables = __webpack_require__("44d2");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var FIND = 'find';
var SKIPS_HOLES = true;

var USES_TO_LENGTH = arrayMethodUsesToLength(FIND);

// Shouldn't skip holes
if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

// `Array.prototype.find` method
// https://tc39.github.io/ecma262/#sec-array.prototype.find
$({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH }, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);


/***/ }),

/***/ "7dd0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var createIteratorConstructor = __webpack_require__("9ed3");
var getPrototypeOf = __webpack_require__("e163");
var setPrototypeOf = __webpack_require__("d2bb");
var setToStringTag = __webpack_require__("d44e");
var createNonEnumerableProperty = __webpack_require__("9112");
var redefine = __webpack_require__("6eeb");
var wellKnownSymbol = __webpack_require__("b622");
var IS_PURE = __webpack_require__("c430");
var Iterators = __webpack_require__("3f8c");
var IteratorsCore = __webpack_require__("ae93");

var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;
    defaultIterator = function values() { return nativeIterator.call(this); };
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
  }
  Iterators[NAME] = defaultIterator;

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  return methods;
};


/***/ }),

/***/ "7f9a":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var inspectSource = __webpack_require__("8925");

var WeakMap = global.WeakMap;

module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ "81d5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__("7b0b");
var toAbsoluteIndex = __webpack_require__("23cb");
var toLength = __webpack_require__("50c4");

// `Array.prototype.fill` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ "825a":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};


/***/ }),

/***/ "83ab":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

// Thank's IE8 for his funny defineProperty
module.exports = !fails(function () {
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ "8418":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toPrimitive = __webpack_require__("c04e");
var definePropertyModule = __webpack_require__("9bf2");
var createPropertyDescriptor = __webpack_require__("5c6c");

module.exports = function (object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ "857a":
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__("1d80");

var quot = /"/g;

// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
// https://tc39.github.io/ecma262/#sec-createhtml
module.exports = function (string, tag, attribute, value) {
  var S = String(requireObjectCoercible(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};


/***/ }),

/***/ "861d":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "8875":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// addapted from the document.currentScript polyfill by Adam Miller
// MIT license
// source: https://github.com/amiller-gh/currentScript-polyfill

// added support for Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1620505

(function (root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(typeof self !== 'undefined' ? self : this, function () {
  function getCurrentScript () {
    var descriptor = Object.getOwnPropertyDescriptor(document, 'currentScript')
    // for chrome
    if (!descriptor && 'currentScript' in document && document.currentScript) {
      return document.currentScript
    }

    // for other browsers with native support for currentScript
    if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {
      return document.currentScript
    }
  
    // IE 8-10 support script readyState
    // IE 11+ & Firefox support stack trace
    try {
      throw new Error();
    }
    catch (err) {
      // Find the second match for the "at" string to get file src url from stack.
      var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig,
        ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig,
        stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack),
        scriptLocation = (stackDetails && stackDetails[1]) || false,
        line = (stackDetails && stackDetails[2]) || false,
        currentLocation = document.location.href.replace(document.location.hash, ''),
        pageSource,
        inlineScriptSourceRegExp,
        inlineScriptSource,
        scripts = document.getElementsByTagName('script'); // Live NodeList collection
  
      if (scriptLocation === currentLocation) {
        pageSource = document.documentElement.outerHTML;
        inlineScriptSourceRegExp = new RegExp('(?:[^\\n]+?\\n){0,' + (line - 2) + '}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*', 'i');
        inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, '$1').trim();
      }
  
      for (var i = 0; i < scripts.length; i++) {
        // If ready state is interactive, return the script tag
        if (scripts[i].readyState === 'interactive') {
          return scripts[i];
        }
  
        // If src matches, return the script tag
        if (scripts[i].src === scriptLocation) {
          return scripts[i];
        }
  
        // If inline source matches, return the script tag
        if (
          scriptLocation === currentLocation &&
          scripts[i].innerHTML &&
          scripts[i].innerHTML.trim() === inlineScriptSource
        ) {
          return scripts[i];
        }
      }
  
      // If no match, return null
      return null;
    }
  };

  return getCurrentScript
}));


/***/ }),

/***/ "8925":
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__("c6cd");

var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof store.inspectSource != 'function') {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ "8aa5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var charAt = __webpack_require__("6547").charAt;

// `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};


/***/ }),

/***/ "8bbf":
/***/ (function(module, exports) {

module.exports = require("vue");

/***/ }),

/***/ "90e3":
/***/ (function(module, exports) {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};


/***/ }),

/***/ "9112":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var definePropertyModule = __webpack_require__("9bf2");
var createPropertyDescriptor = __webpack_require__("5c6c");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "9263":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var regexpFlags = __webpack_require__("ad6d");
var stickyHelpers = __webpack_require__("9f7f");

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = regexpFlags.call(re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = flags.replace('y', '');
      if (flags.indexOf('g') === -1) {
        flags += 'g';
      }

      strCopy = String(str).slice(re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = nativeExec.call(sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = match.input.slice(charsAdded);
        match[0] = match[0].slice(charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ "94ca":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "96cf":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "9911":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var createHTML = __webpack_require__("857a");
var forcedStringHTMLMethod = __webpack_require__("af03");

// `String.prototype.link` method
// https://tc39.github.io/ecma262/#sec-string.prototype.link
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('link') }, {
  link: function link(url) {
    return createHTML(this, 'a', 'href', url);
  }
});


/***/ }),

/***/ "99af":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var fails = __webpack_require__("d039");
var isArray = __webpack_require__("e8b5");
var isObject = __webpack_require__("861d");
var toObject = __webpack_require__("7b0b");
var toLength = __webpack_require__("50c4");
var createProperty = __webpack_require__("8418");
var arraySpeciesCreate = __webpack_require__("65f0");
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
var wellKnownSymbol = __webpack_require__("b622");
var V8_VERSION = __webpack_require__("2d00");

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

// `Array.prototype.concat` method
// https://tc39.github.io/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, forced: FORCED }, {
  concat: function concat(arg) { // eslint-disable-line no-unused-vars
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = toLength(E.length);
        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ "9bdd":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    var returnMethod = iterator['return'];
    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
    throw error;
  }
};


/***/ }),

/***/ "9bf2":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var IE8_DOM_DEFINE = __webpack_require__("0cfb");
var anObject = __webpack_require__("825a");
var toPrimitive = __webpack_require__("c04e");

var nativeDefineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "9ed3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IteratorPrototype = __webpack_require__("ae93").IteratorPrototype;
var create = __webpack_require__("7c73");
var createPropertyDescriptor = __webpack_require__("5c6c");
var setToStringTag = __webpack_require__("d44e");
var Iterators = __webpack_require__("3f8c");

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ "9f7f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fails = __webpack_require__("d039");

// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
// so we use an intermediate function.
function RE(s, f) {
  return RegExp(s, f);
}

exports.UNSUPPORTED_Y = fails(function () {
  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
  var re = RE('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') != null;
});

exports.BROKEN_CARET = fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = RE('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') != null;
});


/***/ }),

/***/ "a15b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var IndexedObject = __webpack_require__("44ad");
var toIndexedObject = __webpack_require__("fc6a");
var arrayMethodIsStrict = __webpack_require__("a640");

var nativeJoin = [].join;

var ES3_STRINGS = IndexedObject != Object;
var STRICT_METHOD = arrayMethodIsStrict('join', ',');

// `Array.prototype.join` method
// https://tc39.github.io/ecma262/#sec-array.prototype.join
$({ target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD }, {
  join: function join(separator) {
    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ }),

/***/ "a2bf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isArray = __webpack_require__("e8b5");
var toLength = __webpack_require__("50c4");
var bind = __webpack_require__("0366");

// `FlattenIntoArray` abstract operation
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var flattenIntoArray = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? bind(mapper, thisArg, 3) : false;
  var element;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      if (depth > 0 && isArray(element)) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError('Exceed the acceptable array length');
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
};

module.exports = flattenIntoArray;


/***/ }),

/***/ "a434":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var toAbsoluteIndex = __webpack_require__("23cb");
var toInteger = __webpack_require__("a691");
var toLength = __webpack_require__("50c4");
var toObject = __webpack_require__("7b0b");
var arraySpeciesCreate = __webpack_require__("65f0");
var createProperty = __webpack_require__("8418");
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');
var USES_TO_LENGTH = arrayMethodUsesToLength('splice', { ACCESSORS: true, 0: 0, 1: 2 });

var max = Math.max;
var min = Math.min;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

// `Array.prototype.splice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.splice
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  splice: function splice(start, deleteCount /* , ...items */) {
    var O = toObject(this);
    var len = toLength(O.length);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
    }
    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }
    A = arraySpeciesCreate(O, actualDeleteCount);
    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }
    A.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
    }
    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }
    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});


/***/ }),

/***/ "a4d3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var getBuiltIn = __webpack_require__("d066");
var IS_PURE = __webpack_require__("c430");
var DESCRIPTORS = __webpack_require__("83ab");
var NATIVE_SYMBOL = __webpack_require__("4930");
var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
var fails = __webpack_require__("d039");
var has = __webpack_require__("5135");
var isArray = __webpack_require__("e8b5");
var isObject = __webpack_require__("861d");
var anObject = __webpack_require__("825a");
var toObject = __webpack_require__("7b0b");
var toIndexedObject = __webpack_require__("fc6a");
var toPrimitive = __webpack_require__("c04e");
var createPropertyDescriptor = __webpack_require__("5c6c");
var nativeObjectCreate = __webpack_require__("7c73");
var objectKeys = __webpack_require__("df75");
var getOwnPropertyNamesModule = __webpack_require__("241c");
var getOwnPropertyNamesExternal = __webpack_require__("057f");
var getOwnPropertySymbolsModule = __webpack_require__("7418");
var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
var definePropertyModule = __webpack_require__("9bf2");
var propertyIsEnumerableModule = __webpack_require__("d1e7");
var createNonEnumerableProperty = __webpack_require__("9112");
var redefine = __webpack_require__("6eeb");
var shared = __webpack_require__("5692");
var sharedKey = __webpack_require__("f772");
var hiddenKeys = __webpack_require__("d012");
var uid = __webpack_require__("90e3");
var wellKnownSymbol = __webpack_require__("b622");
var wrappedWellKnownSymbolModule = __webpack_require__("e538");
var defineWellKnownSymbol = __webpack_require__("746f");
var setToStringTag = __webpack_require__("d44e");
var InternalStateModule = __webpack_require__("69f3");
var $forEach = __webpack_require__("b727").forEach;

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);
var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = global.Symbol;
var $stringify = getBuiltIn('JSON', 'stringify');
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore = shared('wks');
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var isSymbol = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return Object(it) instanceof $Symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPrimitive(P, true);
  anObject(Attributes);
  if (has(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPrimitive(V, true);
  var enumerable = nativePropertyIsEnumerable.call(this, P);
  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPrimitive(P, true);
  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
  });
  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
      result.push(AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.github.io/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return getInternalState(this).tag;
  });

  redefine($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty($Symbol[PROTOTYPE], 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }
}

$({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  // `Symbol.for` method
  // https://tc39.github.io/ecma262/#sec-symbol.for
  'for': function (key) {
    var string = String(key);
    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = $Symbol(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  },
  // `Symbol.keyFor` method
  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  },
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.github.io/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
$({ target: 'Object', stat: true, forced: fails(function () { getOwnPropertySymbolsModule.f(1); }) }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return getOwnPropertySymbolsModule.f(toObject(it));
  }
});

// `JSON.stringify` method behavior with symbols
// https://tc39.github.io/ecma262/#sec-json.stringify
if ($stringify) {
  var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function () {
    var symbol = $Symbol();
    // MS Edge converts symbol values to JSON as {}
    return $stringify([symbol]) != '[null]'
      // WebKit converts symbol values to JSON as null
      || $stringify({ a: symbol }) != '{}'
      // V8 throws on boxed symbols
      || $stringify(Object(symbol)) != '{}';
  });

  $({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
    // eslint-disable-next-line no-unused-vars
    stringify: function stringify(it, replacer, space) {
      var args = [it];
      var index = 1;
      var $replacer;
      while (arguments.length > index) args.push(arguments[index++]);
      $replacer = replacer;
      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
      if (!isArray(replacer)) replacer = function (key, value) {
        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return $stringify.apply(null, args);
    }
  });
}

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
  createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
}
// `Symbol.prototype[@@toStringTag]` property
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;


/***/ }),

/***/ "a623":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $every = __webpack_require__("b727").every;
var arrayMethodIsStrict = __webpack_require__("a640");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var STRICT_METHOD = arrayMethodIsStrict('every');
var USES_TO_LENGTH = arrayMethodUsesToLength('every');

// `Array.prototype.every` method
// https://tc39.github.io/ecma262/#sec-array.prototype.every
$({ target: 'Array', proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "a630":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var from = __webpack_require__("4df4");
var checkCorrectnessOfIteration = __webpack_require__("1c7e");

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.github.io/ecma262/#sec-array.from
$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
  from: from
});


/***/ }),

/***/ "a640":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__("d039");

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal
    method.call(null, argument || function () { throw 1; }, 1);
  });
};


/***/ }),

/***/ "a691":
/***/ (function(module, exports) {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};


/***/ }),

/***/ "a9e3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__("83ab");
var global = __webpack_require__("da84");
var isForced = __webpack_require__("94ca");
var redefine = __webpack_require__("6eeb");
var has = __webpack_require__("5135");
var classof = __webpack_require__("c6b6");
var inheritIfRequired = __webpack_require__("7156");
var toPrimitive = __webpack_require__("c04e");
var fails = __webpack_require__("d039");
var create = __webpack_require__("7c73");
var getOwnPropertyNames = __webpack_require__("241c").f;
var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
var defineProperty = __webpack_require__("9bf2").f;
var trim = __webpack_require__("58a8").trim;

var NUMBER = 'Number';
var NativeNumber = global[NUMBER];
var NumberPrototype = NativeNumber.prototype;

// Opera ~12 has broken Object#toString
var BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;

// `ToNumber` abstract operation
// https://tc39.github.io/ecma262/#sec-tonumber
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  var first, third, radix, maxCode, digits, length, index, code;
  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = it.charCodeAt(0);
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
        default: return +it;
      }
      digits = it.slice(2);
      length = digits.length;
      for (index = 0; index < length; index++) {
        code = digits.charCodeAt(index);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

// `Number` constructor
// https://tc39.github.io/ecma262/#sec-number-constructor
if (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
  var NumberWrapper = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var dummy = this;
    return dummy instanceof NumberWrapper
      // check on 1..constructor(foo) case
      && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classof(dummy) != NUMBER)
        ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
  };
  for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES2015 (in case, if modules with ES2015 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {
      defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
    }
  }
  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  redefine(global, NUMBER, NumberWrapper);
}


/***/ }),

/***/ "ab13":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

var MATCH = wellKnownSymbol('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (e) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (f) { /* empty */ }
  } return false;
};


/***/ }),

/***/ "ac1f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var exec = __webpack_require__("9263");

$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
  exec: exec
});


/***/ }),

/***/ "ad6d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__("825a");

// `RegExp.prototype.flags` getter implementation
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "ade3":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _defineProperty; });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/***/ }),

/***/ "ae40":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var fails = __webpack_require__("d039");
var has = __webpack_require__("5135");

var defineProperty = Object.defineProperty;
var cache = {};

var thrower = function (it) { throw it; };

module.exports = function (METHOD_NAME, options) {
  if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
  if (!options) options = {};
  var method = [][METHOD_NAME];
  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
  var argument0 = has(options, 0) ? options[0] : thrower;
  var argument1 = has(options, 1) ? options[1] : undefined;

  return cache[METHOD_NAME] = !!method && !fails(function () {
    if (ACCESSORS && !DESCRIPTORS) return true;
    var O = { length: -1 };

    if (ACCESSORS) defineProperty(O, 1, { enumerable: true, get: thrower });
    else O[1] = 1;

    method.call(O, argument0, argument1);
  });
};


/***/ }),

/***/ "ae93":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getPrototypeOf = __webpack_require__("e163");
var createNonEnumerableProperty = __webpack_require__("9112");
var has = __webpack_require__("5135");
var wellKnownSymbol = __webpack_require__("b622");
var IS_PURE = __webpack_require__("c430");

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () { return this; };

// `%IteratorPrototype%` object
// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

if (IteratorPrototype == undefined) IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ "af03":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

// check the existence of a method, lowercase
// of a tag and escaping quotes in arguments
module.exports = function (METHOD_NAME) {
  return fails(function () {
    var test = ''[METHOD_NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  });
};


/***/ }),

/***/ "b041":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
var classof = __webpack_require__("f5df");

// `Object.prototype.toString` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ "b058":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_array_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("d81d");
/* harmony import */ var core_js_modules_es_array_map__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_map__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("fb6a");
/* harmony import */ var core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var E_nly_adminlte_vue_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("5530");
/* harmony import */ var _dateformat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("b77e");




var DateUtil = {
  isSame: function isSame(date1, date2, granularity) {
    var dt1 = new Date(date1);
    var dt2 = new Date(date2);

    if (granularity === "date") {
      dt1.setHours(0, 0, 0, 0);
      dt2.setHours(0, 0, 0, 0);
    }

    return dt1.getTime() === dt2.getTime();
  },
  daysInMonth: function daysInMonth(year, month) {
    return new Date(year, month, 0).getDate();
  },
  weekNumber: function weekNumber(date) {
    return Object(_dateformat__WEBPACK_IMPORTED_MODULE_3__["getWeek"])(date);
  },
  format: function format(date, mask) {
    return Object(_dateformat__WEBPACK_IMPORTED_MODULE_3__["dateFormat"])(date, mask);
  },
  nextMonth: function nextMonth(date) {
    var nextMonthDate = new Date(date.getTime());
    nextMonthDate.setDate(1);
    nextMonthDate.setMonth(nextMonthDate.getMonth() + 1);
    return nextMonthDate;
  },
  prevMonth: function prevMonth(date) {
    var prevMonthDate = new Date(date.getTime());
    prevMonthDate.setDate(1);
    prevMonthDate.setMonth(prevMonthDate.getMonth() - 1);
    return prevMonthDate;
  },
  validateDateRange: function validateDateRange(newDate, min, max) {
    var max_date = new Date(max);
    var min_date = new Date(min);

    if (max && newDate.getTime() > max_date.getTime()) {
      return max_date;
    }

    if (min && newDate.getTime() < min_date.getTime()) {
      return min_date;
    }

    return newDate;
  },
  localeData: function localeData(options) {
    var default_locale = {
      direction: "ltr",
      format: "mm/dd/yyyy",
      separator: " - ",
      applyLabel: "Apply",
      cancelLabel: "Cancel",
      weekLabel: "W",
      customRangeLabel: "Custom Range",
      daysOfWeek: _dateformat__WEBPACK_IMPORTED_MODULE_3__["dateFormat"].i18n.dayNames.slice(0, 7).map(function (d) {
        return d.substring(0, 2);
      }),
      monthNames: _dateformat__WEBPACK_IMPORTED_MODULE_3__["dateFormat"].i18n.monthNames.slice(0, 12),
      firstDay: 0
    };
    return Object(E_nly_adminlte_vue_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(Object(E_nly_adminlte_vue_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])({}, default_locale), options);
  },
  yearMonth: function yearMonth(date) {
    var month = date.getMonth() + 1;
    return date.getFullYear() + (month < 10 ? "0" : "") + month;
  },
  isValidDate: function isValidDate(d) {
    return d instanceof Date && !isNaN(d);
  }
};
/* harmony default export */ __webpack_exports__["default"] = (DateUtil);

/***/ }),

/***/ "b0c0":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var defineProperty = __webpack_require__("9bf2").f;

var FunctionPrototype = Function.prototype;
var FunctionPrototypeToString = FunctionPrototype.toString;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// Function instances `.name` property
// https://tc39.github.io/ecma262/#sec-function-instances-name
if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
  defineProperty(FunctionPrototype, NAME, {
    configurable: true,
    get: function () {
      try {
        return FunctionPrototypeToString.call(this).match(nameRE)[1];
      } catch (error) {
        return '';
      }
    }
  });
}


/***/ }),

/***/ "b575":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
var classof = __webpack_require__("c6b6");
var macrotask = __webpack_require__("2cf4").set;
var IS_IOS = __webpack_require__("1cdc");

var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var IS_NODE = classof(process) == 'process';
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

var flush, head, last, notify, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!queueMicrotask) {
  flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head) notify();
        else last = undefined;
        throw error;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (IS_NODE) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  } else if (MutationObserver && !IS_IOS) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, { characterData: true });
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise.resolve(undefined);
    then = promise.then;
    notify = function () {
      then.call(promise, flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }
}

module.exports = queueMicrotask || function (fn) {
  var task = { fn: fn, next: undefined };
  if (last) last.next = task;
  if (!head) {
    head = task;
    notify();
  } last = task;
};


/***/ }),

/***/ "b622":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var shared = __webpack_require__("5692");
var has = __webpack_require__("5135");
var uid = __webpack_require__("90e3");
var NATIVE_SYMBOL = __webpack_require__("4930");
var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name)) {
    if (NATIVE_SYMBOL && has(Symbol, name)) WellKnownSymbolsStore[name] = Symbol[name];
    else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ "b64b":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var toObject = __webpack_require__("7b0b");
var nativeKeys = __webpack_require__("df75");
var fails = __webpack_require__("d039");

var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});


/***/ }),

/***/ "b680":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var toInteger = __webpack_require__("a691");
var thisNumberValue = __webpack_require__("408a");
var repeat = __webpack_require__("1148");
var fails = __webpack_require__("d039");

var nativeToFixed = 1.0.toFixed;
var floor = Math.floor;

var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

var FORCED = nativeToFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !fails(function () {
  // V8 ~ Android 4.3-
  nativeToFixed.call({});
});

// `Number.prototype.toFixed` method
// https://tc39.github.io/ecma262/#sec-number.prototype.tofixed
$({ target: 'Number', proto: true, forced: FORCED }, {
  // eslint-disable-next-line max-statements
  toFixed: function toFixed(fractionDigits) {
    var number = thisNumberValue(this);
    var fractDigits = toInteger(fractionDigits);
    var data = [0, 0, 0, 0, 0, 0];
    var sign = '';
    var result = '0';
    var e, z, j, k;

    var multiply = function (n, c) {
      var index = -1;
      var c2 = c;
      while (++index < 6) {
        c2 += n * data[index];
        data[index] = c2 % 1e7;
        c2 = floor(c2 / 1e7);
      }
    };

    var divide = function (n) {
      var index = 6;
      var c = 0;
      while (--index >= 0) {
        c += data[index];
        data[index] = floor(c / n);
        c = (c % n) * 1e7;
      }
    };

    var dataToString = function () {
      var index = 6;
      var s = '';
      while (--index >= 0) {
        if (s !== '' || index === 0 || data[index] !== 0) {
          var t = String(data[index]);
          s = s === '' ? t : s + repeat.call('0', 7 - t.length) + t;
        }
      } return s;
    };

    if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits');
    // eslint-disable-next-line no-self-compare
    if (number != number) return 'NaN';
    if (number <= -1e21 || number >= 1e21) return String(number);
    if (number < 0) {
      sign = '-';
      number = -number;
    }
    if (number > 1e-21) {
      e = log(number * pow(2, 69, 1)) - 69;
      z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = fractDigits;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        result = dataToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        result = dataToString() + repeat.call('0', fractDigits);
      }
    }
    if (fractDigits > 0) {
      k = result.length;
      result = sign + (k <= fractDigits
        ? '0.' + repeat.call('0', fractDigits - k) + result
        : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
    } else {
      result = sign + result;
    } return result;
  }
});


/***/ }),

/***/ "b727":
/***/ (function(module, exports, __webpack_require__) {

var bind = __webpack_require__("0366");
var IndexedObject = __webpack_require__("44ad");
var toObject = __webpack_require__("7b0b");
var toLength = __webpack_require__("50c4");
var arraySpeciesCreate = __webpack_require__("65f0");

var push = [].push;

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push.call(target, value); // filter
        } else if (IS_EVERY) return false;  // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6)
};


/***/ }),

/***/ "b77e":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dateFormat", function() { return dateFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDayOfWeek", function() { return getDayOfWeek; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWeek", function() { return getWeek; });
/* harmony import */ var core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("fb6a");
/* harmony import */ var core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("d3b7");
/* harmony import */ var core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_regexp_exec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("ac1f");
/* harmony import */ var core_js_modules_es_regexp_exec__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_exec__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_string_match__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("466d");
/* harmony import */ var core_js_modules_es_string_match__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_match__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("5319");
/* harmony import */ var core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var E_nly_adminlte_vue_node_modules_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("53ca");
/*
 * Date Format 1.2.3
 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
 * MIT license
 *
 * Includes enhancements by Scott Trenda <scott.trenda.net>
 * and Kris Kowal <cixar.com/~kris.kowal/>
 *
 * Accepts a date, a mask, or a date and a mask.
 * Returns a formatted version of the given date.
 * The date defaults to the current date/time.
 * The mask defaults to dateFormat.masks.default.
 */









var dateFormat = function () {
  var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZWN]|"[^"]*"|'[^']*'/g;
  var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
  var timezoneClip = /[^-+\dA-Z]/g; // Regexes and supporting functions are cached through closure

  return function (date, mask, utc, gmt) {
    // You can't provide utc if you skip other args (use the 'UTC:' mask prefix)
    if (arguments.length === 1 && kindOf(date) === "string" && !/\d/.test(date)) {
      mask = date;
      date = undefined;
    }

    date = date || new Date();

    if (!(date instanceof Date)) {
      date = new Date(date);
    }

    if (isNaN(date)) {
      throw TypeError("Invalid date");
    }

    mask = String(dateFormat.masks[mask] || mask || dateFormat.masks["default"]); // Allow setting the utc/gmt argument via the mask

    var maskSlice = mask.slice(0, 4);

    if (maskSlice === "UTC:" || maskSlice === "GMT:") {
      mask = mask.slice(4);
      utc = true;

      if (maskSlice === "GMT:") {
        gmt = true;
      }
    }

    var _ = utc ? "getUTC" : "get";

    var d = date[_ + "Date"]();

    var D = date[_ + "Day"]();

    var m = date[_ + "Month"]();

    var y = date[_ + "FullYear"]();

    var H = date[_ + "Hours"]();

    var M = date[_ + "Minutes"]();

    var s = date[_ + "Seconds"]();

    var L = date[_ + "Milliseconds"]();

    var o = utc ? 0 : date.getTimezoneOffset();
    var W = getWeek(date);
    var N = getDayOfWeek(date);
    var flags = {
      d: d,
      dd: pad(d),
      ddd: dateFormat.i18n.dayNames[D],
      dddd: dateFormat.i18n.dayNames[D + 7],
      m: m + 1,
      mm: pad(m + 1),
      mmm: dateFormat.i18n.monthNames[m],
      mmmm: dateFormat.i18n.monthNames[m + 12],
      yy: String(y).slice(2),
      yyyy: y,
      h: H % 12 || 12,
      hh: pad(H % 12 || 12),
      H: H,
      HH: pad(H),
      M: M,
      MM: pad(M),
      s: s,
      ss: pad(s),
      l: pad(L, 3),
      L: pad(Math.round(L / 10)),
      t: H < 12 ? dateFormat.i18n.timeNames[0] : dateFormat.i18n.timeNames[1],
      tt: H < 12 ? dateFormat.i18n.timeNames[2] : dateFormat.i18n.timeNames[3],
      T: H < 12 ? dateFormat.i18n.timeNames[4] : dateFormat.i18n.timeNames[5],
      TT: H < 12 ? dateFormat.i18n.timeNames[6] : dateFormat.i18n.timeNames[7],
      Z: gmt ? "GMT" : utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
      o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
      S: ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10],
      W: W,
      N: N
    };
    return mask.replace(token, function (match) {
      if (match in flags) {
        return flags[match];
      }

      return match.slice(1, match.length - 1);
    });
  };
}();

dateFormat.masks = {
  default: "ddd mmm dd yyyy HH:MM:ss",
  shortDate: "m/d/yy",
  mediumDate: "mmm d, yyyy",
  longDate: "mmmm d, yyyy",
  fullDate: "dddd, mmmm d, yyyy",
  shortTime: "h:MM TT",
  mediumTime: "h:MM:ss TT",
  longTime: "h:MM:ss TT Z",
  isoDate: "yyyy-mm-dd",
  isoTime: "HH:MM:ss",
  isoDateTime: "yyyy-mm-dd'T'HH:MM:sso",
  isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'",
  expiresHeaderFormat: "ddd, dd mmm yyyy HH:MM:ss Z"
}; // Internationalization strings

dateFormat.i18n = {
  dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  timeNames: ["a", "p", "am", "pm", "A", "P", "AM", "PM"]
};

function pad(val, len) {
  val = String(val);
  len = len || 2;

  while (val.length < len) {
    val = "0" + val;
  }

  return val;
}
/**
 * Get the ISO 8601 week number
 * Based on comments from
 * http://techblog.procurios.nl/k/n618/news/view/33796/14863/Calculate-ISO-8601-week-and-year-in-javascript.html
 *
 * @param  {Object} `date`
 * @return {Number}
 */


function getWeek(date) {
  // Remove time components of date
  var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate()); // Change date to Thursday same week

  targetThursday.setDate(targetThursday.getDate() - (targetThursday.getDay() + 6) % 7 + 3); // Take January 4th as it is always in week 1 (see ISO 8601)

  var firstThursday = new Date(targetThursday.getFullYear(), 0, 4); // Change date to Thursday same week

  firstThursday.setDate(firstThursday.getDate() - (firstThursday.getDay() + 6) % 7 + 3); // Check if daylight-saving-time-switch occurred and correct for it

  var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
  targetThursday.setHours(targetThursday.getHours() - ds); // Number of weeks between target Thursday and first Thursday

  var weekDiff = (targetThursday - firstThursday) / (86400000 * 7);
  return 1 + Math.floor(weekDiff);
}
/**
 * Get ISO-8601 numeric representation of the day of the week
 * 1 (for Monday) through 7 (for Sunday)
 *
 * @param  {Object} `date`
 * @return {Number}
 */


function getDayOfWeek(date) {
  var dow = date.getDay();

  if (dow === 0) {
    dow = 7;
  }

  return dow;
}
/**
 * kind-of shortcut
 * @param  {*} val
 * @return {String}
 */


function kindOf(val) {
  if (val === null) {
    return "null";
  }

  if (val === undefined) {
    return "undefined";
  }

  if (Object(E_nly_adminlte_vue_node_modules_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(val) !== "object") {
    return Object(E_nly_adminlte_vue_node_modules_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(val);
  }

  if (Array.isArray(val)) {
    return "array";
  }

  return {}.toString.call(val).slice(8, -1).toLowerCase();
}



/***/ }),

/***/ "bb2f":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

module.exports = !fails(function () {
  return Object.isExtensible(Object.preventExtensions({}));
});


/***/ }),

/***/ "c04e":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");

// `ToPrimitive` abstract operation
// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "c430":
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "c6b6":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "c6cd":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var setGlobal = __webpack_require__("ce4e");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;


/***/ }),

/***/ "c7cd":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var createHTML = __webpack_require__("857a");
var forcedStringHTMLMethod = __webpack_require__("af03");

// `String.prototype.fixed` method
// https://tc39.github.io/ecma262/#sec-string.prototype.fixed
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('fixed') }, {
  fixed: function fixed() {
    return createHTML(this, 'tt', '', '');
  }
});


/***/ }),

/***/ "c8ba":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "c8d2":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var whitespaces = __webpack_require__("5899");

var non = '\u200B\u0085\u180E';

// check that a method works with the correct list
// of whitespaces and has a correct name
module.exports = function (METHOD_NAME) {
  return fails(function () {
    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
  });
};


/***/ }),

/***/ "c96a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var createHTML = __webpack_require__("857a");
var forcedStringHTMLMethod = __webpack_require__("af03");

// `String.prototype.small` method
// https://tc39.github.io/ecma262/#sec-string.prototype.small
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('small') }, {
  small: function small() {
    return createHTML(this, 'small', '', '');
  }
});


/***/ }),

/***/ "c975":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $indexOf = __webpack_require__("4d64").indexOf;
var arrayMethodIsStrict = __webpack_require__("a640");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var nativeIndexOf = [].indexOf;

var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('indexOf');
var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

// `Array.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
$({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH }, {
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? nativeIndexOf.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "ca84":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("5135");
var toIndexedObject = __webpack_require__("fc6a");
var indexOf = __webpack_require__("4d64").indexOf;
var hiddenKeys = __webpack_require__("d012");

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "caad":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $includes = __webpack_require__("4d64").includes;
var addToUnscopables = __webpack_require__("44d2");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

// `Array.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true, forced: !USES_TO_LENGTH }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');


/***/ }),

/***/ "cb29":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var fill = __webpack_require__("81d5");
var addToUnscopables = __webpack_require__("44d2");

// `Array.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
$({ target: 'Array', proto: true }, {
  fill: fill
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('fill');


/***/ }),

/***/ "cc12":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isObject = __webpack_require__("861d");

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ "cca6":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var assign = __webpack_require__("60da");

// `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
$({ target: 'Object', stat: true, forced: Object.assign !== assign }, {
  assign: assign
});


/***/ }),

/***/ "cd3f":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      if (isHostObject(value)) {
        return object ? value : {};
      }
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? getAllKeys(value) : keys(value);
  }
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    assignValue(object, key, newValue === undefined ? source[key] : newValue);
  }
  return object;
}

/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, true, true);
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = cloneDeep;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba"), __webpack_require__("62e4")(module)))

/***/ }),

/***/ "cdf9":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var isObject = __webpack_require__("861d");
var newPromiseCapability = __webpack_require__("f069");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ "ce4e":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var createNonEnumerableProperty = __webpack_require__("9112");

module.exports = function (key, value) {
  try {
    createNonEnumerableProperty(global, key, value);
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ "d012":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "d039":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "d066":
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__("428f");
var global = __webpack_require__("da84");

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};


/***/ }),

/***/ "d1e7":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;


/***/ }),

/***/ "d28b":
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__("746f");

// `Symbol.iterator` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');


/***/ }),

/***/ "d2bb":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var aPossiblePrototype = __webpack_require__("3bbe");

// `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ "d3b7":
/***/ (function(module, exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
var redefine = __webpack_require__("6eeb");
var toString = __webpack_require__("b041");

// `Object.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  redefine(Object.prototype, 'toString', toString, { unsafe: true });
}


/***/ }),

/***/ "d44e":
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__("9bf2").f;
var has = __webpack_require__("5135");
var wellKnownSymbol = __webpack_require__("b622");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ "d58f":
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__("1c0b");
var toObject = __webpack_require__("7b0b");
var IndexedObject = __webpack_require__("44ad");
var toLength = __webpack_require__("50c4");

// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aFunction(callbackfn);
    var O = toObject(that);
    var self = IndexedObject(O);
    var length = toLength(O.length);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }
    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
    return memo;
  };
};

module.exports = {
  // `Array.prototype.reduce` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};


/***/ }),

/***/ "d784":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// TODO: Remove from `core-js@4` since it's moved to entry points
__webpack_require__("ac1f");
var redefine = __webpack_require__("6eeb");
var fails = __webpack_require__("d039");
var wellKnownSymbol = __webpack_require__("b622");
var regexpExec = __webpack_require__("9263");
var createNonEnumerableProperty = __webpack_require__("9112");

var SPECIES = wellKnownSymbol('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = (function () {
  return 'a'.replace(/./, '$0') === '$0';
})();

var REPLACE = wellKnownSymbol('replace');
// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }
  return false;
})();

// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

module.exports = function (KEY, length, exec, sham) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () { execCalled = true; return null; };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !(
      REPLACE_SUPPORTS_NAMED_GROUPS &&
      REPLACE_KEEPS_$0 &&
      !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    )) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
        }
        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
      }
      return { done: false };
    }, {
      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    });
    var stringMethod = methods[0];
    var regexMethod = methods[1];

    redefine(String.prototype, KEY, stringMethod);
    redefine(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return regexMethod.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return regexMethod.call(string, this); }
    );
  }

  if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
};


/***/ }),

/***/ "d81d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $map = __webpack_require__("b727").map;
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');
// FF49- issue
var USES_TO_LENGTH = arrayMethodUsesToLength('map');

// `Array.prototype.map` method
// https://tc39.github.io/ecma262/#sec-array.prototype.map
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "da84":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line no-undef
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  check(typeof self == 'object' && self) ||
  check(typeof global == 'object' && global) ||
  // eslint-disable-next-line no-new-func
  Function('return this')();

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")))

/***/ }),

/***/ "dbb4":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var DESCRIPTORS = __webpack_require__("83ab");
var ownKeys = __webpack_require__("56ef");
var toIndexedObject = __webpack_require__("fc6a");
var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
var createProperty = __webpack_require__("8418");

// `Object.getOwnPropertyDescriptors` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var keys = ownKeys(O);
    var result = {};
    var index = 0;
    var key, descriptor;
    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }
    return result;
  }
});


/***/ }),

/***/ "dbe5":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * OverlayScrollbars
 * https://github.com/KingSora/OverlayScrollbars
 *
 * Version: 1.13.0
 *
 * Copyright KingSora | Rene Haas.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 * Date: 02.08.2020
 */

(function (global, factory) {
    if (true)
        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return factory(global, global.document, undefined); }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    else {}
}(typeof window !== 'undefined' ? window : this,
    function (window, document, undefined) {
        'use strict';
        var PLUGINNAME = 'OverlayScrollbars';
        var TYPES = {
            o: 'object',
            f: 'function',
            a: 'array',
            s: 'string',
            b: 'boolean',
            n: 'number',
            u: 'undefined',
            z: 'null'
            //d : 'date',
            //e : 'error',
            //r : 'regexp',
            //y : 'symbol'
        };
        var LEXICON = {
            c: 'class',
            s: 'style',
            i: 'id',
            l: 'length',
            p: 'prototype',
            ti: 'tabindex',
            oH: 'offsetHeight',
            cH: 'clientHeight',
            sH: 'scrollHeight',
            oW: 'offsetWidth',
            cW: 'clientWidth',
            sW: 'scrollWidth',
            hOP: 'hasOwnProperty',
            bCR: 'getBoundingClientRect'
        };
        var VENDORS = (function () {
            //https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix
            var jsCache = {};
            var cssCache = {};
            var cssPrefixes = ['-webkit-', '-moz-', '-o-', '-ms-'];
            var jsPrefixes = ['WebKit', 'Moz', 'O', 'MS'];
            function firstLetterToUpper(str) {
                return str.charAt(0).toUpperCase() + str.slice(1);
            }

            return {
                _cssPrefixes: cssPrefixes,
                _jsPrefixes: jsPrefixes,
                _cssProperty: function (name) {
                    var result = cssCache[name];

                    if (cssCache[LEXICON.hOP](name))
                        return result;

                    var uppercasedName = firstLetterToUpper(name);
                    var elmStyle = document.createElement('div')[LEXICON.s];
                    var resultPossibilities;
                    var i = 0;
                    var v;
                    var currVendorWithoutDashes;

                    for (; i < cssPrefixes.length; i++) {
                        currVendorWithoutDashes = cssPrefixes[i].replace(/-/g, '');
                        resultPossibilities = [
                            name, //transition
                            cssPrefixes[i] + name, //-webkit-transition
                            currVendorWithoutDashes + uppercasedName, //webkitTransition
                            firstLetterToUpper(currVendorWithoutDashes) + uppercasedName //WebkitTransition
                        ];
                        for (v = 0; v < resultPossibilities[LEXICON.l]; v++) {
                            if (elmStyle[resultPossibilities[v]] !== undefined) {
                                result = resultPossibilities[v];
                                break;
                            }
                        }
                    }

                    cssCache[name] = result;
                    return result;
                },
                _cssPropertyValue: function (property, values, suffix) {
                    var name = property + ' ' + values;
                    var result = cssCache[name];

                    if (cssCache[LEXICON.hOP](name))
                        return result;

                    var dummyStyle = document.createElement('div')[LEXICON.s];
                    var possbleValues = values.split(' ');
                    var preparedSuffix = suffix || '';
                    var i = 0;
                    var v = -1;
                    var prop;

                    for (; i < possbleValues[LEXICON.l]; i++) {
                        for (; v < VENDORS._cssPrefixes[LEXICON.l]; v++) {
                            prop = v < 0 ? possbleValues[i] : VENDORS._cssPrefixes[v] + possbleValues[i];
                            dummyStyle.cssText = property + ':' + prop + preparedSuffix;
                            if (dummyStyle[LEXICON.l]) {
                                result = prop;
                                break;
                            }
                        }
                    }

                    cssCache[name] = result;
                    return result;
                },
                _jsAPI: function (name, isInterface, fallback) {
                    var i = 0;
                    var result = jsCache[name];

                    if (!jsCache[LEXICON.hOP](name)) {
                        result = window[name];
                        for (; i < jsPrefixes[LEXICON.l]; i++)
                            result = result || window[(isInterface ? jsPrefixes[i] : jsPrefixes[i].toLowerCase()) + firstLetterToUpper(name)];
                        jsCache[name] = result;
                    }
                    return result || fallback;
                }
            }
        })();
        var COMPATIBILITY = (function () {
            function windowSize(x) {
                return x ? window.innerWidth || document.documentElement[LEXICON.cW] || document.body[LEXICON.cW] : window.innerHeight || document.documentElement[LEXICON.cH] || document.body[LEXICON.cH];
            }
            function bind(func, thisObj) {
                if (typeof func != TYPES.f) {
                    throw "Can't bind function!";
                    // closest thing possible to the ECMAScript 5
                    // internal IsCallable function
                    //throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
                }
                var proto = LEXICON.p;
                var aArgs = Array[proto].slice.call(arguments, 2);
                var fNOP = function () { };
                var fBound = function () { return func.apply(this instanceof fNOP ? this : thisObj, aArgs.concat(Array[proto].slice.call(arguments))); };

                if (func[proto])
                    fNOP[proto] = func[proto]; // Function.prototype doesn't have a prototype property
                fBound[proto] = new fNOP();

                return fBound;
            }

            return {
                /**
                 * Gets the current window width.
                 * @returns {Number|number} The current window width in pixel.
                 */
                wW: bind(windowSize, 0, true),

                /**
                 * Gets the current window height.
                 * @returns {Number|number} The current window height in pixel.
                 */
                wH: bind(windowSize, 0),

                /**
                 * Gets the MutationObserver Object or undefined if not supported.
                 * @returns {MutationObserver|*|undefined} The MutationsObserver Object or undefined.
                 */
                mO: bind(VENDORS._jsAPI, 0, 'MutationObserver', true),

                /**
                 * Gets the ResizeObserver Object or undefined if not supported.
                 * @returns {MutationObserver|*|undefined} The ResizeObserver Object or undefined.
                 */
                rO: bind(VENDORS._jsAPI, 0, 'ResizeObserver', true),

                /**
                 * Gets the RequestAnimationFrame method or it's corresponding polyfill.
                 * @returns {*|Function} The RequestAnimationFrame method or it's corresponding polyfill.
                 */
                rAF: bind(VENDORS._jsAPI, 0, 'requestAnimationFrame', false, function (func) { return window.setTimeout(func, 1000 / 60); }),

                /**
                 * Gets the CancelAnimationFrame method or it's corresponding polyfill.
                 * @returns {*|Function} The CancelAnimationFrame method or it's corresponding polyfill.
                 */
                cAF: bind(VENDORS._jsAPI, 0, 'cancelAnimationFrame', false, function (id) { return window.clearTimeout(id); }),

                /**
                 * Gets the current time.
                 * @returns {number} The current time.
                 */
                now: function () {
                    return Date.now && Date.now() || new Date().getTime();
                },

                /**
                 * Stops the propagation of the given event.
                 * @param event The event of which the propagation shall be stoped.
                 */
                stpP: function (event) {
                    if (event.stopPropagation)
                        event.stopPropagation();
                    else
                        event.cancelBubble = true;
                },

                /**
                 * Prevents the default action of the given event.
                 * @param event The event of which the default action shall be prevented.
                 */
                prvD: function (event) {
                    if (event.preventDefault && event.cancelable)
                        event.preventDefault();
                    else
                        event.returnValue = false;
                },

                /**
                 * Gets the pageX and pageY values of the given mouse event.
                 * @param event The mouse event of which the pageX and pageX shall be got.
                 * @returns {{x: number, y: number}} x = pageX value, y = pageY value.
                 */
                page: function (event) {
                    event = event.originalEvent || event;

                    var strPage = 'page';
                    var strClient = 'client';
                    var strX = 'X';
                    var strY = 'Y';
                    var target = event.target || event.srcElement || document;
                    var eventDoc = target.ownerDocument || document;
                    var doc = eventDoc.documentElement;
                    var body = eventDoc.body;

                    //if touch event return return pageX/Y of it
                    if (event.touches !== undefined) {
                        var touch = event.touches[0];
                        return {
                            x: touch[strPage + strX],
                            y: touch[strPage + strY]
                        }
                    }

                    // Calculate pageX/Y if not native supported
                    if (!event[strPage + strX] && event[strClient + strX] && event[strClient + strX] != null) {

                        return {
                            x: event[strClient + strX] +
                                (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
                                (doc && doc.clientLeft || body && body.clientLeft || 0),
                            y: event[strClient + strY] +
                                (doc && doc.scrollTop || body && body.scrollTop || 0) -
                                (doc && doc.clientTop || body && body.clientTop || 0)
                        }
                    }
                    return {
                        x: event[strPage + strX],
                        y: event[strPage + strY]
                    };
                },

                /**
                 * Gets the clicked mouse button of the given mouse event.
                 * @param event The mouse event of which the clicked button shal be got.
                 * @returns {number} The number of the clicked mouse button. (0 : none | 1 : leftButton | 2 : middleButton | 3 : rightButton)
                 */
                mBtn: function (event) {
                    var button = event.button;
                    if (!event.which && button !== undefined)
                        return (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
                    else
                        return event.which;
                },

                /**
                 * Checks whether a item is in the given array and returns its index.
                 * @param item The item of which the position in the array shall be determined.
                 * @param arr The array.
                 * @returns {number} The zero based index of the item or -1 if the item isn't in the array.
                 */
                inA: function (item, arr) {
                    for (var i = 0; i < arr[LEXICON.l]; i++)
                        //Sometiems in IE a "SCRIPT70" Permission denied error occurs if HTML elements in a iFrame are compared
                        try {
                            if (arr[i] === item)
                                return i;
                        }
                        catch (e) { }
                    return -1;
                },

                /**
                 * Returns true if the given value is a array.
                 * @param arr The potential array.
                 * @returns {boolean} True if the given value is a array, false otherwise.
                 */
                isA: function (arr) {
                    var def = Array.isArray;
                    return def ? def(arr) : this.type(arr) == TYPES.a;
                },

                /**
                 * Determine the internal JavaScript [[Class]] of the given object.
                 * @param obj The object of which the type shall be determined.
                 * @returns {string} The type of the given object.
                 */
                type: function (obj) {
                    if (obj === undefined)
                        return obj + '';
                    if (obj === null)
                        return obj + '';
                    return Object[LEXICON.p].toString.call(obj).replace(/^\[object (.+)\]$/, '$1').toLowerCase();
                },


                bind: bind

                /**
                 * Gets the vendor-prefixed CSS property by the given name.
                 * For example the given name is "transform" and you're using a old Firefox browser then the returned value would be "-moz-transform".
                 * If the browser doesn't need a vendor-prefix, then the returned string is the given name.
                 * If the browser doesn't support the given property name at all (not even with a vendor-prefix) the returned value is null.
                 * @param propName The unprefixed CSS property name.
                 * @returns {string|null} The vendor-prefixed CSS property or null if the browser doesn't support the given CSS property.

                cssProp: function(propName) {
                    return VENDORS._cssProperty(propName);
                }
                */
            }
        })();


        var MATH = Math;
        var JQUERY = window.jQuery;
        var EASING = (function () {
            var _easingsMath = {
                p: MATH.PI,
                c: MATH.cos,
                s: MATH.sin,
                w: MATH.pow,
                t: MATH.sqrt,
                n: MATH.asin,
                a: MATH.abs,
                o: 1.70158
            };

            /*
             x : current percent (0 - 1),
             t : current time (duration * percent),
             b : start value (from),
             c : end value (to),
             d : duration

             easingName : function(x, t, b, c, d) { return easedValue; }
             */

            return {
                swing: function (x, t, b, c, d) {
                    return 0.5 - _easingsMath.c(x * _easingsMath.p) / 2;
                },
                linear: function (x, t, b, c, d) {
                    return x;
                },
                easeInQuad: function (x, t, b, c, d) {
                    return c * (t /= d) * t + b;
                },
                easeOutQuad: function (x, t, b, c, d) {
                    return -c * (t /= d) * (t - 2) + b;
                },
                easeInOutQuad: function (x, t, b, c, d) {
                    return ((t /= d / 2) < 1) ? c / 2 * t * t + b : -c / 2 * ((--t) * (t - 2) - 1) + b;
                },
                easeInCubic: function (x, t, b, c, d) {
                    return c * (t /= d) * t * t + b;
                },
                easeOutCubic: function (x, t, b, c, d) {
                    return c * ((t = t / d - 1) * t * t + 1) + b;
                },
                easeInOutCubic: function (x, t, b, c, d) {
                    return ((t /= d / 2) < 1) ? c / 2 * t * t * t + b : c / 2 * ((t -= 2) * t * t + 2) + b;
                },
                easeInQuart: function (x, t, b, c, d) {
                    return c * (t /= d) * t * t * t + b;
                },
                easeOutQuart: function (x, t, b, c, d) {
                    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
                },
                easeInOutQuart: function (x, t, b, c, d) {
                    return ((t /= d / 2) < 1) ? c / 2 * t * t * t * t + b : -c / 2 * ((t -= 2) * t * t * t - 2) + b;
                },
                easeInQuint: function (x, t, b, c, d) {
                    return c * (t /= d) * t * t * t * t + b;
                },
                easeOutQuint: function (x, t, b, c, d) {
                    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
                },
                easeInOutQuint: function (x, t, b, c, d) {
                    return ((t /= d / 2) < 1) ? c / 2 * t * t * t * t * t + b : c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
                },
                easeInSine: function (x, t, b, c, d) {
                    return -c * _easingsMath.c(t / d * (_easingsMath.p / 2)) + c + b;
                },
                easeOutSine: function (x, t, b, c, d) {
                    return c * _easingsMath.s(t / d * (_easingsMath.p / 2)) + b;
                },
                easeInOutSine: function (x, t, b, c, d) {
                    return -c / 2 * (_easingsMath.c(_easingsMath.p * t / d) - 1) + b;
                },
                easeInExpo: function (x, t, b, c, d) {
                    return (t == 0) ? b : c * _easingsMath.w(2, 10 * (t / d - 1)) + b;
                },
                easeOutExpo: function (x, t, b, c, d) {
                    return (t == d) ? b + c : c * (-_easingsMath.w(2, -10 * t / d) + 1) + b;
                },
                easeInOutExpo: function (x, t, b, c, d) {
                    if (t == 0) return b;
                    if (t == d) return b + c;
                    if ((t /= d / 2) < 1) return c / 2 * _easingsMath.w(2, 10 * (t - 1)) + b;
                    return c / 2 * (-_easingsMath.w(2, -10 * --t) + 2) + b;
                },
                easeInCirc: function (x, t, b, c, d) {
                    return -c * (_easingsMath.t(1 - (t /= d) * t) - 1) + b;
                },
                easeOutCirc: function (x, t, b, c, d) {
                    return c * _easingsMath.t(1 - (t = t / d - 1) * t) + b;
                },
                easeInOutCirc: function (x, t, b, c, d) {
                    return ((t /= d / 2) < 1) ? -c / 2 * (_easingsMath.t(1 - t * t) - 1) + b : c / 2 * (_easingsMath.t(1 - (t -= 2) * t) + 1) + b;
                },
                easeInElastic: function (x, t, b, c, d) {
                    var s = _easingsMath.o; var p = 0; var a = c;
                    if (t == 0) return b; if ((t /= d) == 1) return b + c; if (!p) p = d * .3;
                    if (a < _easingsMath.a(c)) { a = c; s = p / 4; }
                    else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);
                    return -(a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b;
                },
                easeOutElastic: function (x, t, b, c, d) {
                    var s = _easingsMath.o; var p = 0; var a = c;
                    if (t == 0) return b;
                    if ((t /= d) == 1) return b + c;
                    if (!p) p = d * .3;
                    if (a < _easingsMath.a(c)) { a = c; s = p / 4; }
                    else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);
                    return a * _easingsMath.w(2, -10 * t) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) + c + b;
                },
                easeInOutElastic: function (x, t, b, c, d) {
                    var s = _easingsMath.o; var p = 0; var a = c;
                    if (t == 0) return b;
                    if ((t /= d / 2) == 2) return b + c;
                    if (!p) p = d * (.3 * 1.5);
                    if (a < _easingsMath.a(c)) { a = c; s = p / 4; }
                    else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);
                    if (t < 1) return -.5 * (a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b;
                    return a * _easingsMath.w(2, -10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) * .5 + c + b;
                },
                easeInBack: function (x, t, b, c, d, s) {
                    s = s || _easingsMath.o;
                    return c * (t /= d) * t * ((s + 1) * t - s) + b;
                },
                easeOutBack: function (x, t, b, c, d, s) {
                    s = s || _easingsMath.o;
                    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
                },
                easeInOutBack: function (x, t, b, c, d, s) {
                    s = s || _easingsMath.o;
                    return ((t /= d / 2) < 1) ? c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b : c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
                },
                easeInBounce: function (x, t, b, c, d) {
                    return c - this.easeOutBounce(x, d - t, 0, c, d) + b;
                },
                easeOutBounce: function (x, t, b, c, d) {
                    var o = 7.5625;
                    if ((t /= d) < (1 / 2.75)) {
                        return c * (o * t * t) + b;
                    } else if (t < (2 / 2.75)) {
                        return c * (o * (t -= (1.5 / 2.75)) * t + .75) + b;
                    } else if (t < (2.5 / 2.75)) {
                        return c * (o * (t -= (2.25 / 2.75)) * t + .9375) + b;
                    } else {
                        return c * (o * (t -= (2.625 / 2.75)) * t + .984375) + b;
                    }
                },
                easeInOutBounce: function (x, t, b, c, d) {
                    return (t < d / 2) ? this.easeInBounce(x, t * 2, 0, c, d) * .5 + b : this.easeOutBounce(x, t * 2 - d, 0, c, d) * .5 + c * .5 + b;
                }
            };
            /*
             *
             * TERMS OF USE - EASING EQUATIONS
             * 
             * Open source under the BSD License. 
             * 
             * Copyright Â© 2001 Robert Penner
             * All rights reserved.
             * 
             * Redistribution and use in source and binary forms, with or without modification, 
             * are permitted provided that the following conditions are met:
             * 
             * Redistributions of source code must retain the above copyright notice, this list of 
             * conditions and the following disclaimer.
             * Redistributions in binary form must reproduce the above copyright notice, this list 
             * of conditions and the following disclaimer in the documentation and/or other materials 
             * provided with the distribution.
             * 
             * Neither the name of the author nor the names of contributors may be used to endorse 
             * or promote products derived from this software without specific prior written permission.
             * 
             * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY 
             * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
             * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
             *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
             *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
             *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
             * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
             *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
             * OF THE POSSIBILITY OF SUCH DAMAGE. 
             *
             */
        })();
        var FRAMEWORK = (function () {
            var _rnothtmlwhite = (/[^\x20\t\r\n\f]+/g);
            var _strSpace = ' ';
            var _strEmpty = '';
            var _strScrollLeft = 'scrollLeft';
            var _strScrollTop = 'scrollTop';
            var _animations = [];
            var _type = COMPATIBILITY.type;
            var _cssNumber = {
                animationIterationCount: true,
                columnCount: true,
                fillOpacity: true,
                flexGrow: true,
                flexShrink: true,
                fontWeight: true,
                lineHeight: true,
                opacity: true,
                order: true,
                orphans: true,
                widows: true,
                zIndex: true,
                zoom: true
            };

            function extend() {
                var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {},
                    i = 1,
                    length = arguments[LEXICON.l],
                    deep = false;

                // Handle a deep copy situation
                if (_type(target) == TYPES.b) {
                    deep = target;
                    target = arguments[1] || {};
                    // skip the boolean and the target
                    i = 2;
                }

                // Handle case when target is a string or something (possible in deep copy)
                if (_type(target) != TYPES.o && !_type(target) == TYPES.f) {
                    target = {};
                }

                // extend jQuery itself if only one argument is passed
                if (length === i) {
                    target = FakejQuery;
                    --i;
                }

                for (; i < length; i++) {
                    // Only deal with non-null/undefined values
                    if ((options = arguments[i]) != null) {
                        // Extend the base object
                        for (name in options) {
                            src = target[name];
                            copy = options[name];

                            // Prevent never-ending loop
                            if (target === copy) {
                                continue;
                            }

                            // Recurse if we're merging plain objects or arrays
                            if (deep && copy && (isPlainObject(copy) || (copyIsArray = COMPATIBILITY.isA(copy)))) {
                                if (copyIsArray) {
                                    copyIsArray = false;
                                    clone = src && COMPATIBILITY.isA(src) ? src : [];

                                } else {
                                    clone = src && isPlainObject(src) ? src : {};
                                }

                                // Never move original objects, clone them
                                target[name] = extend(deep, clone, copy);

                                // Don't bring in undefined values
                            } else if (copy !== undefined) {
                                target[name] = copy;
                            }
                        }
                    }
                }

                // Return the modified object
                return target;
            };

            function inArray(item, arr, fromIndex) {
                for (var i = fromIndex || 0; i < arr[LEXICON.l]; i++)
                    if (arr[i] === item)
                        return i;
                return -1;
            }

            function isFunction(obj) {
                return _type(obj) == TYPES.f;
            };

            function isEmptyObject(obj) {
                for (var name in obj)
                    return false;
                return true;
            };

            function isPlainObject(obj) {
                if (!obj || _type(obj) != TYPES.o)
                    return false;

                var key;
                var proto = LEXICON.p;
                var hasOwnProperty = Object[proto].hasOwnProperty;
                var hasOwnConstructor = hasOwnProperty.call(obj, 'constructor');
                var hasIsPrototypeOf = obj.constructor && obj.constructor[proto] && hasOwnProperty.call(obj.constructor[proto], 'isPrototypeOf');

                if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
                    return false;
                }


                for (key in obj) { /**/ }

                return _type(key) == TYPES.u || hasOwnProperty.call(obj, key);
            };

            function each(obj, callback) {
                var i = 0;

                if (isArrayLike(obj)) {
                    for (; i < obj[LEXICON.l]; i++) {
                        if (callback.call(obj[i], i, obj[i]) === false)
                            break;
                    }
                }
                else {
                    for (i in obj) {
                        if (callback.call(obj[i], i, obj[i]) === false)
                            break;
                    }
                }

                return obj;
            };

            function isArrayLike(obj) {
                var length = !!obj && [LEXICON.l] in obj && obj[LEXICON.l];
                var t = _type(obj);
                return isFunction(t) ? false : (t == TYPES.a || length === 0 || _type(length) == TYPES.n && length > 0 && (length - 1) in obj);
            }

            function stripAndCollapse(value) {
                var tokens = value.match(_rnothtmlwhite) || [];
                return tokens.join(_strSpace);
            }

            function matches(elem, selector) {
                var nodeList = (elem.parentNode || document).querySelectorAll(selector) || [];
                var i = nodeList[LEXICON.l];

                while (i--)
                    if (nodeList[i] == elem)
                        return true;

                return false;
            }

            function insertAdjacentElement(el, strategy, child) {
                if (COMPATIBILITY.isA(child)) {
                    for (var i = 0; i < child[LEXICON.l]; i++)
                        insertAdjacentElement(el, strategy, child[i]);
                }
                else if (_type(child) == TYPES.s)
                    el.insertAdjacentHTML(strategy, child);
                else
                    el.insertAdjacentElement(strategy, child.nodeType ? child : child[0]);
            }

            function setCSSVal(el, prop, val) {
                try {
                    if (el[LEXICON.s][prop] !== undefined)
                        el[LEXICON.s][prop] = parseCSSVal(prop, val);
                } catch (e) { }
            }

            function parseCSSVal(prop, val) {
                if (!_cssNumber[prop.toLowerCase()] && _type(val) == TYPES.n)
                    val += 'px';
                return val;
            }

            function startNextAnimationInQ(animObj, removeFromQ) {
                var index;
                var nextAnim;
                if (removeFromQ !== false)
                    animObj.q.splice(0, 1);
                if (animObj.q[LEXICON.l] > 0) {
                    nextAnim = animObj.q[0];
                    animate(animObj.el, nextAnim.props, nextAnim.duration, nextAnim.easing, nextAnim.complete, true);
                }
                else {
                    index = inArray(animObj, _animations);
                    if (index > -1)
                        _animations.splice(index, 1);
                }
            }

            function setAnimationValue(el, prop, value) {
                if (prop === _strScrollLeft || prop === _strScrollTop)
                    el[prop] = value;
                else
                    setCSSVal(el, prop, value);
            }

            function animate(el, props, options, easing, complete, guaranteedNext) {
                var hasOptions = isPlainObject(options);
                var from = {};
                var to = {};
                var i = 0;
                var key;
                var animObj;
                var start;
                var progress;
                var step;
                var specialEasing;
                var duration;
                if (hasOptions) {
                    easing = options.easing;
                    start = options.start;
                    progress = options.progress;
                    step = options.step;
                    specialEasing = options.specialEasing;
                    complete = options.complete;
                    duration = options.duration;
                }
                else
                    duration = options;
                specialEasing = specialEasing || {};
                duration = duration || 400;
                easing = easing || 'swing';
                guaranteedNext = guaranteedNext || false;

                for (; i < _animations[LEXICON.l]; i++) {
                    if (_animations[i].el === el) {
                        animObj = _animations[i];
                        break;
                    }
                }

                if (!animObj) {
                    animObj = {
                        el: el,
                        q: []
                    };
                    _animations.push(animObj);
                }

                for (key in props) {
                    if (key === _strScrollLeft || key === _strScrollTop)
                        from[key] = el[key];
                    else
                        from[key] = FakejQuery(el).css(key);
                }

                for (key in from) {
                    if (from[key] !== props[key] && props[key] !== undefined)
                        to[key] = props[key];
                }

                if (!isEmptyObject(to)) {
                    var timeNow;
                    var end;
                    var percent;
                    var fromVal;
                    var toVal;
                    var easedVal;
                    var timeStart;
                    var frame;
                    var elapsed;
                    var qPos = guaranteedNext ? 0 : inArray(qObj, animObj.q);
                    var qObj = {
                        props: to,
                        duration: hasOptions ? options : duration,
                        easing: easing,
                        complete: complete
                    };
                    if (qPos === -1) {
                        qPos = animObj.q[LEXICON.l];
                        animObj.q.push(qObj);
                    }

                    if (qPos === 0) {
                        if (duration > 0) {
                            timeStart = COMPATIBILITY.now();
                            frame = function () {
                                timeNow = COMPATIBILITY.now();
                                elapsed = (timeNow - timeStart);
                                end = qObj.stop || elapsed >= duration;
                                percent = 1 - ((MATH.max(0, timeStart + duration - timeNow) / duration) || 0);

                                for (key in to) {
                                    fromVal = parseFloat(from[key]);
                                    toVal = parseFloat(to[key]);
                                    easedVal = (toVal - fromVal) * EASING[specialEasing[key] || easing](percent, percent * duration, 0, 1, duration) + fromVal;
                                    setAnimationValue(el, key, easedVal);
                                    if (isFunction(step)) {
                                        step(easedVal, {
                                            elem: el,
                                            prop: key,
                                            start: fromVal,
                                            now: easedVal,
                                            end: toVal,
                                            pos: percent,
                                            options: {
                                                easing: easing,
                                                speacialEasing: specialEasing,
                                                duration: duration,
                                                complete: complete,
                                                step: step
                                            },
                                            startTime: timeStart
                                        });
                                    }
                                }

                                if (isFunction(progress))
                                    progress({}, percent, MATH.max(0, duration - elapsed));

                                if (end) {
                                    startNextAnimationInQ(animObj);
                                    if (isFunction(complete))
                                        complete();
                                }
                                else
                                    qObj.frame = COMPATIBILITY.rAF()(frame);
                            };
                            qObj.frame = COMPATIBILITY.rAF()(frame);
                        }
                        else {
                            for (key in to)
                                setAnimationValue(el, key, to[key]);
                            startNextAnimationInQ(animObj);
                        }
                    }
                }
                else if (guaranteedNext)
                    startNextAnimationInQ(animObj);
            }

            function stop(el, clearQ, jumpToEnd) {
                var animObj;
                var qObj;
                var key;
                var i = 0;
                for (; i < _animations[LEXICON.l]; i++) {
                    animObj = _animations[i];
                    if (animObj.el === el) {
                        if (animObj.q[LEXICON.l] > 0) {
                            qObj = animObj.q[0];
                            qObj.stop = true;
                            COMPATIBILITY.cAF()(qObj.frame);
                            animObj.q.splice(0, 1);

                            if (jumpToEnd)
                                for (key in qObj.props)
                                    setAnimationValue(el, key, qObj.props[key]);

                            if (clearQ)
                                animObj.q = [];
                            else
                                startNextAnimationInQ(animObj, false);
                        }
                        break;
                    }
                }
            }

            function elementIsVisible(el) {
                return !!(el[LEXICON.oW] || el[LEXICON.oH] || el.getClientRects()[LEXICON.l]);
            }

            function FakejQuery(selector) {
                if (arguments[LEXICON.l] === 0)
                    return this;

                var base = new FakejQuery();
                var elements = selector;
                var i = 0;
                var elms;
                var el;

                if (_type(selector) == TYPES.s) {
                    elements = [];
                    if (selector.charAt(0) === '<') {
                        el = document.createElement('div');
                        el.innerHTML = selector;
                        elms = el.children;
                    }
                    else {
                        elms = document.querySelectorAll(selector);
                    }

                    for (; i < elms[LEXICON.l]; i++)
                        elements.push(elms[i]);
                }

                if (elements) {
                    if (_type(elements) != TYPES.s && (!isArrayLike(elements) || elements === window || elements === elements.self))
                        elements = [elements];

                    for (i = 0; i < elements[LEXICON.l]; i++)
                        base[i] = elements[i];

                    base[LEXICON.l] = elements[LEXICON.l];
                }

                return base;
            };

            FakejQuery[LEXICON.p] = {

                //EVENTS:

                on: function (eventName, handler) {
                    eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];

                    var eventNameLength = eventName[LEXICON.l];
                    var i = 0;
                    var el;
                    return this.each(function () {
                        el = this;
                        try {
                            if (el.addEventListener) {
                                for (; i < eventNameLength; i++)
                                    el.addEventListener(eventName[i], handler);
                            }
                            else if (el.detachEvent) {
                                for (; i < eventNameLength; i++)
                                    el.attachEvent('on' + eventName[i], handler);
                            }
                        } catch (e) { }
                    });
                },

                off: function (eventName, handler) {
                    eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];

                    var eventNameLength = eventName[LEXICON.l];
                    var i = 0;
                    var el;
                    return this.each(function () {
                        el = this;
                        try {
                            if (el.removeEventListener) {
                                for (; i < eventNameLength; i++)
                                    el.removeEventListener(eventName[i], handler);
                            }
                            else if (el.detachEvent) {
                                for (; i < eventNameLength; i++)
                                    el.detachEvent('on' + eventName[i], handler);
                            }
                        } catch (e) { }
                    });
                },

                one: function (eventName, handler) {
                    eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];
                    return this.each(function () {
                        var el = FakejQuery(this);
                        FakejQuery.each(eventName, function (i, oneEventName) {
                            var oneHandler = function (e) {
                                handler.call(this, e);
                                el.off(oneEventName, oneHandler);
                            };
                            el.on(oneEventName, oneHandler);
                        });
                    });
                },

                trigger: function (eventName) {
                    var el;
                    var event;
                    return this.each(function () {
                        el = this;
                        if (document.createEvent) {
                            event = document.createEvent('HTMLEvents');
                            event.initEvent(eventName, true, false);
                            el.dispatchEvent(event);
                        }
                        else {
                            el.fireEvent('on' + eventName);
                        }
                    });
                },

                //DOM NODE INSERTING / REMOVING:

                append: function (child) {
                    return this.each(function () { insertAdjacentElement(this, 'beforeend', child); });
                },

                prepend: function (child) {
                    return this.each(function () { insertAdjacentElement(this, 'afterbegin', child); });
                },

                before: function (child) {
                    return this.each(function () { insertAdjacentElement(this, 'beforebegin', child); });
                },

                after: function (child) {
                    return this.each(function () { insertAdjacentElement(this, 'afterend', child); });
                },

                remove: function () {
                    return this.each(function () {
                        var el = this;
                        var parentNode = el.parentNode;
                        if (parentNode != null)
                            parentNode.removeChild(el);
                    });
                },

                unwrap: function () {
                    var parents = [];
                    var i;
                    var el;
                    var parent;

                    this.each(function () {
                        parent = this.parentNode;
                        if (inArray(parent, parents) === - 1)
                            parents.push(parent);
                    });

                    for (i = 0; i < parents[LEXICON.l]; i++) {
                        el = parents[i];
                        parent = el.parentNode;
                        while (el.firstChild)
                            parent.insertBefore(el.firstChild, el);
                        parent.removeChild(el);
                    }

                    return this;
                },

                wrapAll: function (wrapperHTML) {
                    var i;
                    var nodes = this;
                    var wrapper = FakejQuery(wrapperHTML)[0];
                    var deepest = wrapper;
                    var parent = nodes[0].parentNode;
                    var previousSibling = nodes[0].previousSibling;
                    while (deepest.childNodes[LEXICON.l] > 0)
                        deepest = deepest.childNodes[0];

                    for (i = 0; nodes[LEXICON.l] - i; deepest.firstChild === nodes[0] && i++)
                        deepest.appendChild(nodes[i]);

                    var nextSibling = previousSibling ? previousSibling.nextSibling : parent.firstChild;
                    parent.insertBefore(wrapper, nextSibling);

                    return this;
                },

                wrapInner: function (wrapperHTML) {
                    return this.each(function () {
                        var el = FakejQuery(this);
                        var contents = el.contents();

                        if (contents[LEXICON.l])
                            contents.wrapAll(wrapperHTML);
                        else
                            el.append(wrapperHTML);
                    });
                },

                wrap: function (wrapperHTML) {
                    return this.each(function () { FakejQuery(this).wrapAll(wrapperHTML); });
                },


                //DOM NODE MANIPULATION / INFORMATION:

                css: function (styles, val) {
                    var el;
                    var key;
                    var cptStyle;
                    var getCptStyle = window.getComputedStyle;
                    if (_type(styles) == TYPES.s) {
                        if (val === undefined) {
                            el = this[0];
                            cptStyle = getCptStyle ? getCptStyle(el, null) : el.currentStyle[styles];

                            //https://bugzilla.mozilla.org/show_bug.cgi?id=548397 can be null sometimes if iframe with display: none (firefox only!)
                            return getCptStyle ? cptStyle != null ? cptStyle.getPropertyValue(styles) : el[LEXICON.s][styles] : cptStyle;
                        }
                        else {
                            return this.each(function () {
                                setCSSVal(this, styles, val);
                            });
                        }
                    }
                    else {
                        return this.each(function () {
                            for (key in styles)
                                setCSSVal(this, key, styles[key]);
                        });
                    }
                },

                hasClass: function (className) {
                    var elem, i = 0;
                    var classNamePrepared = _strSpace + className + _strSpace;
                    var classList;

                    while ((elem = this[i++])) {
                        classList = elem.classList;
                        if (classList && classList.contains(className))
                            return true;
                        else if (elem.nodeType === 1 && (_strSpace + stripAndCollapse(elem.className + _strEmpty) + _strSpace).indexOf(classNamePrepared) > -1)
                            return true;
                    }

                    return false;
                },

                addClass: function (className) {
                    var classes;
                    var elem;
                    var cur;
                    var curValue;
                    var clazz;
                    var finalValue;
                    var supportClassList;
                    var elmClassList;
                    var i = 0;
                    var v = 0;

                    if (className) {
                        classes = className.match(_rnothtmlwhite) || [];

                        while ((elem = this[i++])) {
                            elmClassList = elem.classList;
                            if (supportClassList === undefined)
                                supportClassList = elmClassList !== undefined;

                            if (supportClassList) {
                                while ((clazz = classes[v++]))
                                    elmClassList.add(clazz);
                            }
                            else {
                                curValue = elem.className + _strEmpty;
                                cur = elem.nodeType === 1 && (_strSpace + stripAndCollapse(curValue) + _strSpace);

                                if (cur) {
                                    while ((clazz = classes[v++]))
                                        if (cur.indexOf(_strSpace + clazz + _strSpace) < 0)
                                            cur += clazz + _strSpace;

                                    finalValue = stripAndCollapse(cur);
                                    if (curValue !== finalValue)
                                        elem.className = finalValue;
                                }
                            }
                        }
                    }

                    return this;
                },

                removeClass: function (className) {
                    var classes;
                    var elem;
                    var cur;
                    var curValue;
                    var clazz;
                    var finalValue;
                    var supportClassList;
                    var elmClassList;
                    var i = 0;
                    var v = 0;

                    if (className) {
                        classes = className.match(_rnothtmlwhite) || [];

                        while ((elem = this[i++])) {
                            elmClassList = elem.classList;
                            if (supportClassList === undefined)
                                supportClassList = elmClassList !== undefined;

                            if (supportClassList) {
                                while ((clazz = classes[v++]))
                                    elmClassList.remove(clazz);
                            }
                            else {
                                curValue = elem.className + _strEmpty;
                                cur = elem.nodeType === 1 && (_strSpace + stripAndCollapse(curValue) + _strSpace);

                                if (cur) {
                                    while ((clazz = classes[v++]))
                                        while (cur.indexOf(_strSpace + clazz + _strSpace) > -1)
                                            cur = cur.replace(_strSpace + clazz + _strSpace, _strSpace);

                                    finalValue = stripAndCollapse(cur);
                                    if (curValue !== finalValue)
                                        elem.className = finalValue;
                                }
                            }
                        }
                    }

                    return this;
                },

                hide: function () {
                    return this.each(function () { this[LEXICON.s].display = 'none'; });
                },

                show: function () {
                    return this.each(function () { this[LEXICON.s].display = 'block'; });
                },

                attr: function (attrName, value) {
                    var i = 0;
                    var el;
                    while (el = this[i++]) {
                        if (value === undefined)
                            return el.getAttribute(attrName);
                        el.setAttribute(attrName, value);
                    }
                    return this;
                },

                removeAttr: function (attrName) {
                    return this.each(function () { this.removeAttribute(attrName); });
                },

                offset: function () {
                    var el = this[0];
                    var rect = el[LEXICON.bCR]();
                    var scrollLeft = window.pageXOffset || document.documentElement[_strScrollLeft];
                    var scrollTop = window.pageYOffset || document.documentElement[_strScrollTop];
                    return {
                        top: rect.top + scrollTop,
                        left: rect.left + scrollLeft
                    };
                },

                position: function () {
                    var el = this[0];
                    return {
                        top: el.offsetTop,
                        left: el.offsetLeft
                    };
                },

                scrollLeft: function (value) {
                    var i = 0;
                    var el;
                    while (el = this[i++]) {
                        if (value === undefined)
                            return el[_strScrollLeft];
                        el[_strScrollLeft] = value;
                    }
                    return this;
                },

                scrollTop: function (value) {
                    var i = 0;
                    var el;
                    while (el = this[i++]) {
                        if (value === undefined)
                            return el[_strScrollTop];
                        el[_strScrollTop] = value;
                    }
                    return this;
                },

                val: function (value) {
                    var el = this[0];
                    if (!value)
                        return el.value;
                    el.value = value;
                    return this;
                },


                //DOM TRAVERSAL / FILTERING:

                first: function () {
                    return this.eq(0);
                },

                last: function () {
                    return this.eq(-1);
                },

                eq: function (index) {
                    return FakejQuery(this[index >= 0 ? index : this[LEXICON.l] + index]);
                },

                find: function (selector) {
                    var children = [];
                    var i;
                    this.each(function () {
                        var el = this;
                        var ch = el.querySelectorAll(selector);
                        for (i = 0; i < ch[LEXICON.l]; i++)
                            children.push(ch[i]);
                    });
                    return FakejQuery(children);
                },

                children: function (selector) {
                    var children = [];
                    var el;
                    var ch;
                    var i;

                    this.each(function () {
                        ch = this.children;
                        for (i = 0; i < ch[LEXICON.l]; i++) {
                            el = ch[i];
                            if (selector) {
                                if ((el.matches && el.matches(selector)) || matches(el, selector))
                                    children.push(el);
                            }
                            else
                                children.push(el);
                        }
                    });
                    return FakejQuery(children);
                },

                parent: function (selector) {
                    var parents = [];
                    var parent;
                    this.each(function () {
                        parent = this.parentNode;
                        if (selector ? FakejQuery(parent).is(selector) : true)
                            parents.push(parent);
                    });
                    return FakejQuery(parents);
                },

                is: function (selector) {

                    var el;
                    var i;
                    for (i = 0; i < this[LEXICON.l]; i++) {
                        el = this[i];
                        if (selector === ':visible')
                            return elementIsVisible(el);
                        if (selector === ':hidden')
                            return !elementIsVisible(el);
                        if ((el.matches && el.matches(selector)) || matches(el, selector))
                            return true;
                    }
                    return false;
                },

                contents: function () {
                    var contents = [];
                    var childs;
                    var i;

                    this.each(function () {
                        childs = this.childNodes;
                        for (i = 0; i < childs[LEXICON.l]; i++)
                            contents.push(childs[i]);
                    });

                    return FakejQuery(contents);
                },

                each: function (callback) {
                    return each(this, callback);
                },


                //ANIMATION:

                animate: function (props, duration, easing, complete) {
                    return this.each(function () { animate(this, props, duration, easing, complete); });
                },

                stop: function (clearQ, jump) {
                    return this.each(function () { stop(this, clearQ, jump); });
                }
            };

            extend(FakejQuery, {
                extend: extend,
                inArray: inArray,
                isEmptyObject: isEmptyObject,
                isPlainObject: isPlainObject,
                each: each
            });

            return FakejQuery;
        })();
        var INSTANCES = (function () {
            var _targets = [];
            var _instancePropertyString = '__overlayScrollbars__';

            /**
             * Register, unregister or get a certain (or all) instances.
             * Register: Pass the target and the instance.
             * Unregister: Pass the target and null.
             * Get Instance: Pass the target from which the instance shall be got.
             * Get Targets: Pass no arguments.
             * @param target The target to which the instance shall be registered / from which the instance shall be unregistered / the instance shall be got
             * @param instance The instance.
             * @returns {*|void} Returns the instance from the given target.
             */
            return function (target, instance) {
                var argLen = arguments[LEXICON.l];
                if (argLen < 1) {
                    //return all targets
                    return _targets;
                }
                else {
                    if (instance) {
                        //register instance
                        target[_instancePropertyString] = instance;
                        _targets.push(target);
                    }
                    else {
                        var index = COMPATIBILITY.inA(target, _targets);
                        if (index > -1) {
                            if (argLen > 1) {
                                //unregister instance
                                delete target[_instancePropertyString];
                                _targets.splice(index, 1);
                            }
                            else {
                                //get instance from target
                                return _targets[index][_instancePropertyString];
                            }
                        }
                    }
                }
            }
        })();
        var PLUGIN = (function () {
            var _plugin;
            var _pluginsGlobals;
            var _pluginsAutoUpdateLoop;
            var _pluginsExtensions = [];
            var _pluginsOptions = (function () {
                var type = COMPATIBILITY.type;
                var possibleTemplateTypes = [
                    TYPES.b, //boolean
                    TYPES.n, //number
                    TYPES.s, //string
                    TYPES.a, //array
                    TYPES.o, //object
                    TYPES.f, //function
                    TYPES.z  //null
                ];
                var restrictedStringsSplit = ' ';
                var restrictedStringsPossibilitiesSplit = ':';
                var classNameAllowedValues = [TYPES.z, TYPES.s];
                var numberAllowedValues = TYPES.n;
                var booleanNullAllowedValues = [TYPES.z, TYPES.b];
                var booleanTrueTemplate = [true, TYPES.b];
                var booleanFalseTemplate = [false, TYPES.b];
                var callbackTemplate = [null, [TYPES.z, TYPES.f]];
                var updateOnLoadTemplate = [['img'], [TYPES.s, TYPES.a, TYPES.z]];
                var inheritedAttrsTemplate = [['style', 'class'], [TYPES.s, TYPES.a, TYPES.z]];
                var resizeAllowedValues = 'n:none b:both h:horizontal v:vertical';
                var overflowBehaviorAllowedValues = 'v-h:visible-hidden v-s:visible-scroll s:scroll h:hidden';
                var scrollbarsVisibilityAllowedValues = 'v:visible h:hidden a:auto';
                var scrollbarsAutoHideAllowedValues = 'n:never s:scroll l:leave m:move';
                var optionsDefaultsAndTemplate = {
                    className: ['os-theme-dark', classNameAllowedValues],                //null || string
                    resize: ['none', resizeAllowedValues],                               //none || both  || horizontal || vertical || n || b || h || v
                    sizeAutoCapable: booleanTrueTemplate,                                //true || false
                    clipAlways: booleanTrueTemplate,                                     //true || false
                    normalizeRTL: booleanTrueTemplate,                                   //true || false
                    paddingAbsolute: booleanFalseTemplate,                               //true || false
                    autoUpdate: [null, booleanNullAllowedValues],                        //true || false || null
                    autoUpdateInterval: [33, numberAllowedValues],                       //number
                    updateOnLoad: updateOnLoadTemplate,                                  //string || array || null
                    nativeScrollbarsOverlaid: {
                        showNativeScrollbars: booleanFalseTemplate,                      //true || false
                        initialize: booleanTrueTemplate                                  //true || false
                    },
                    overflowBehavior: {
                        x: ['scroll', overflowBehaviorAllowedValues],                    //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s
                        y: ['scroll', overflowBehaviorAllowedValues]                     //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s
                    },
                    scrollbars: {
                        visibility: ['auto', scrollbarsVisibilityAllowedValues],         //visible || hidden || auto || v || h || a
                        autoHide: ['never', scrollbarsAutoHideAllowedValues],            //never || scroll || leave || move || n || s || l || m
                        autoHideDelay: [800, numberAllowedValues],                       //number
                        dragScrolling: booleanTrueTemplate,                              //true || false
                        clickScrolling: booleanFalseTemplate,                            //true || false
                        touchSupport: booleanTrueTemplate,                               //true || false
                        snapHandle: booleanFalseTemplate                                 //true || false
                    },
                    textarea: {
                        dynWidth: booleanFalseTemplate,                                  //true || false
                        dynHeight: booleanFalseTemplate,                                 //true || false
                        inheritedAttrs: inheritedAttrsTemplate                           //string || array || null
                    },
                    callbacks: {
                        onInitialized: callbackTemplate,                                 //null || function
                        onInitializationWithdrawn: callbackTemplate,                     //null || function
                        onDestroyed: callbackTemplate,                                   //null || function
                        onScrollStart: callbackTemplate,                                 //null || function
                        onScroll: callbackTemplate,                                      //null || function
                        onScrollStop: callbackTemplate,                                  //null || function
                        onOverflowChanged: callbackTemplate,                             //null || function
                        onOverflowAmountChanged: callbackTemplate,                       //null || function
                        onDirectionChanged: callbackTemplate,                            //null || function
                        onContentSizeChanged: callbackTemplate,                          //null || function
                        onHostSizeChanged: callbackTemplate,                             //null || function
                        onUpdated: callbackTemplate                                      //null || function
                    }
                };
                var convert = function (template) {
                    var recursive = function (obj) {
                        var key;
                        var val;
                        var valType;
                        for (key in obj) {
                            if (!obj[LEXICON.hOP](key))
                                continue;
                            val = obj[key];
                            valType = type(val);
                            if (valType == TYPES.a)
                                obj[key] = val[template ? 1 : 0];
                            else if (valType == TYPES.o)
                                obj[key] = recursive(val);
                        }
                        return obj;
                    };
                    return recursive(FRAMEWORK.extend(true, {}, optionsDefaultsAndTemplate));
                };

                return {
                    _defaults: convert(),

                    _template: convert(true),

                    /**
                     * Validates the passed object by the passed template.
                     * @param obj The object which shall be validated.
                     * @param template The template which defines the allowed values and types.
                     * @param writeErrors True if errors shall be logged to the console.
                     * @param diffObj If a object is passed then only valid differences to this object will be returned.
                     * @returns {{}} A object which contains two objects called "default" and "prepared" which contains only the valid properties of the passed original object and discards not different values compared to the passed diffObj.
                     */
                    _validate: function (obj, template, writeErrors, diffObj) {
                        var validatedOptions = {};
                        var validatedOptionsPrepared = {};
                        var objectCopy = FRAMEWORK.extend(true, {}, obj);
                        var inArray = FRAMEWORK.inArray;
                        var isEmptyObj = FRAMEWORK.isEmptyObject;
                        var checkObjectProps = function (data, template, diffData, validatedOptions, validatedOptionsPrepared, prevPropName) {
                            for (var prop in template) {
                                if (template[LEXICON.hOP](prop) && data[LEXICON.hOP](prop)) {
                                    var isValid = false;
                                    var isDiff = false;
                                    var templateValue = template[prop];
                                    var templateValueType = type(templateValue);
                                    var templateIsComplex = templateValueType == TYPES.o;
                                    var templateTypes = !COMPATIBILITY.isA(templateValue) ? [templateValue] : templateValue;
                                    var dataDiffValue = diffData[prop];
                                    var dataValue = data[prop];
                                    var dataValueType = type(dataValue);
                                    var propPrefix = prevPropName ? prevPropName + '.' : '';
                                    var error = "The option \"" + propPrefix + prop + "\" wasn't set, because";
                                    var errorPossibleTypes = [];
                                    var errorRestrictedStrings = [];
                                    var restrictedStringValuesSplit;
                                    var restrictedStringValuesPossibilitiesSplit;
                                    var isRestrictedValue;
                                    var mainPossibility;
                                    var currType;
                                    var i;
                                    var v;
                                    var j;

                                    dataDiffValue = dataDiffValue === undefined ? {} : dataDiffValue;

                                    //if the template has a object as value, it means that the options are complex (verschachtelt)
                                    if (templateIsComplex && dataValueType == TYPES.o) {
                                        validatedOptions[prop] = {};
                                        validatedOptionsPrepared[prop] = {};
                                        checkObjectProps(dataValue, templateValue, dataDiffValue, validatedOptions[prop], validatedOptionsPrepared[prop], propPrefix + prop);
                                        FRAMEWORK.each([data, validatedOptions, validatedOptionsPrepared], function (index, value) {
                                            if (isEmptyObj(value[prop])) {
                                                delete value[prop];
                                            }
                                        });
                                    }
                                    else if (!templateIsComplex) {
                                        for (i = 0; i < templateTypes[LEXICON.l]; i++) {
                                            currType = templateTypes[i];
                                            templateValueType = type(currType);
                                            //if currtype is string and starts with restrictedStringPrefix and end with restrictedStringSuffix
                                            isRestrictedValue = templateValueType == TYPES.s && inArray(currType, possibleTemplateTypes) === -1;
                                            if (isRestrictedValue) {
                                                errorPossibleTypes.push(TYPES.s);

                                                //split it into a array which contains all possible values for example: ["y:yes", "n:no", "m:maybe"]
                                                restrictedStringValuesSplit = currType.split(restrictedStringsSplit);
                                                errorRestrictedStrings = errorRestrictedStrings.concat(restrictedStringValuesSplit);
                                                for (v = 0; v < restrictedStringValuesSplit[LEXICON.l]; v++) {
                                                    //split the possible values into their possibiliteis for example: ["y", "yes"] -> the first is always the mainPossibility
                                                    restrictedStringValuesPossibilitiesSplit = restrictedStringValuesSplit[v].split(restrictedStringsPossibilitiesSplit);
                                                    mainPossibility = restrictedStringValuesPossibilitiesSplit[0];
                                                    for (j = 0; j < restrictedStringValuesPossibilitiesSplit[LEXICON.l]; j++) {
                                                        //if any possibility matches with the dataValue, its valid
                                                        if (dataValue === restrictedStringValuesPossibilitiesSplit[j]) {
                                                            isValid = true;
                                                            break;
                                                        }
                                                    }
                                                    if (isValid)
                                                        break;
                                                }
                                            }
                                            else {
                                                errorPossibleTypes.push(currType);

                                                if (dataValueType === currType) {
                                                    isValid = true;
                                                    break;
                                                }
                                            }
                                        }

                                        if (isValid) {
                                            isDiff = dataValue !== dataDiffValue;

                                            if (isDiff)
                                                validatedOptions[prop] = dataValue;

                                            if (isRestrictedValue ? inArray(dataDiffValue, restrictedStringValuesPossibilitiesSplit) < 0 : isDiff)
                                                validatedOptionsPrepared[prop] = isRestrictedValue ? mainPossibility : dataValue;
                                        }
                                        else if (writeErrors) {
                                            console.warn(error + " it doesn't accept the type [ " + dataValueType.toUpperCase() + " ] with the value of \"" + dataValue + "\".\r\n" +
                                                "Accepted types are: [ " + errorPossibleTypes.join(', ').toUpperCase() + " ]." +
                                                (errorRestrictedStrings[length] > 0 ? "\r\nValid strings are: [ " + errorRestrictedStrings.join(', ').split(restrictedStringsPossibilitiesSplit).join(', ') + " ]." : ''));
                                        }
                                        delete data[prop];
                                    }
                                }
                            }
                        };
                        checkObjectProps(objectCopy, template, diffObj || {}, validatedOptions, validatedOptionsPrepared);

                        //add values which aren't specified in the template to the finished validated object to prevent them from being discarded
                        /*
                        if(keepForeignProps) {
                            FRAMEWORK.extend(true, validatedOptions, objectCopy);
                            FRAMEWORK.extend(true, validatedOptionsPrepared, objectCopy);
                        }
                        */

                        if (!isEmptyObj(objectCopy) && writeErrors)
                            console.warn('The following options are discarded due to invalidity:\r\n' + window.JSON.stringify(objectCopy, null, 2));

                        return {
                            _default: validatedOptions,
                            _prepared: validatedOptionsPrepared
                        };
                    }
                }
            }());

            /**
             * Initializes the object which contains global information about the plugin and each instance of it.
             */
            function initOverlayScrollbarsStatics() {
                if (!_pluginsGlobals)
                    _pluginsGlobals = new OverlayScrollbarsGlobals(_pluginsOptions._defaults);
                if (!_pluginsAutoUpdateLoop)
                    _pluginsAutoUpdateLoop = new OverlayScrollbarsAutoUpdateLoop(_pluginsGlobals);
            }

            /**
             * The global object for the OverlayScrollbars objects. It contains resources which every OverlayScrollbars object needs. This object is initialized only once: if the first OverlayScrollbars object gets initialized.
             * @param defaultOptions
             * @constructor
             */
            function OverlayScrollbarsGlobals(defaultOptions) {
                var _base = this;
                var strOverflow = 'overflow';
                var strHidden = 'hidden';
                var strScroll = 'scroll';
                var bodyElement = FRAMEWORK('body');
                var scrollbarDummyElement = FRAMEWORK('<div id="os-dummy-scrollbar-size"><div></div></div>');
                var scrollbarDummyElement0 = scrollbarDummyElement[0];
                var dummyContainerChild = FRAMEWORK(scrollbarDummyElement.children('div').eq(0));

                bodyElement.append(scrollbarDummyElement);
                scrollbarDummyElement.hide().show(); //fix IE8 bug (incorrect measuring)

                var nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement0);
                var nativeScrollbarIsOverlaid = {
                    x: nativeScrollbarSize.x === 0,
                    y: nativeScrollbarSize.y === 0
                };
                var msie = (function () {
                    var ua = window.navigator.userAgent;
                    var strIndexOf = 'indexOf';
                    var strSubString = 'substring';
                    var msie = ua[strIndexOf]('MSIE ');
                    var trident = ua[strIndexOf]('Trident/');
                    var edge = ua[strIndexOf]('Edge/');
                    var rv = ua[strIndexOf]('rv:');
                    var result;
                    var parseIntFunc = parseInt;

                    // IE 10 or older => return version number
                    if (msie > 0)
                        result = parseIntFunc(ua[strSubString](msie + 5, ua[strIndexOf]('.', msie)), 10);

                    // IE 11 => return version number
                    else if (trident > 0)
                        result = parseIntFunc(ua[strSubString](rv + 3, ua[strIndexOf]('.', rv)), 10);

                    // Edge (IE 12+) => return version number
                    else if (edge > 0)
                        result = parseIntFunc(ua[strSubString](edge + 5, ua[strIndexOf]('.', edge)), 10);

                    // other browser
                    return result;
                })();

                FRAMEWORK.extend(_base, {
                    defaultOptions: defaultOptions,
                    msie: msie,
                    autoUpdateLoop: false,
                    autoUpdateRecommended: !COMPATIBILITY.mO(),
                    nativeScrollbarSize: nativeScrollbarSize,
                    nativeScrollbarIsOverlaid: nativeScrollbarIsOverlaid,
                    nativeScrollbarStyling: (function () {
                        var result = false;
                        scrollbarDummyElement.addClass('os-viewport-native-scrollbars-invisible');
                        try {
                            result = (scrollbarDummyElement.css('scrollbar-width') === 'none' && (msie > 9 || !msie)) || window.getComputedStyle(scrollbarDummyElement0, '::-webkit-scrollbar').getPropertyValue('display') === 'none';
                        } catch (ex) { }

                        //fix opera bug: scrollbar styles will only appear if overflow value is scroll or auto during the activation of the style.
                        //and set overflow to scroll
                        //scrollbarDummyElement.css(strOverflow, strHidden).hide().css(strOverflow, strScroll).show();
                        //return (scrollbarDummyElement0[LEXICON.oH] - scrollbarDummyElement0[LEXICON.cH]) === 0 && (scrollbarDummyElement0[LEXICON.oW] - scrollbarDummyElement0[LEXICON.cW]) === 0;

                        return result;
                    })(),
                    overlayScrollbarDummySize: { x: 30, y: 30 },
                    cssCalc: VENDORS._cssPropertyValue('width', 'calc', '(1px)') || null,
                    restrictedMeasuring: (function () {
                        //https://bugzilla.mozilla.org/show_bug.cgi?id=1439305
                        //since 1.11.0 always false -> fixed via CSS (hopefully)
                        scrollbarDummyElement.css(strOverflow, strHidden);
                        var scrollSize = {
                            w: scrollbarDummyElement0[LEXICON.sW],
                            h: scrollbarDummyElement0[LEXICON.sH]
                        };
                        scrollbarDummyElement.css(strOverflow, 'visible');
                        var scrollSize2 = {
                            w: scrollbarDummyElement0[LEXICON.sW],
                            h: scrollbarDummyElement0[LEXICON.sH]
                        };
                        return (scrollSize.w - scrollSize2.w) !== 0 || (scrollSize.h - scrollSize2.h) !== 0;
                    })(),
                    rtlScrollBehavior: (function () {
                        scrollbarDummyElement.css({ 'overflow-y': strHidden, 'overflow-x': strScroll, 'direction': 'rtl' }).scrollLeft(0);
                        var dummyContainerOffset = scrollbarDummyElement.offset();
                        var dummyContainerChildOffset = dummyContainerChild.offset();
                        //https://github.com/KingSora/OverlayScrollbars/issues/187
                        scrollbarDummyElement.scrollLeft(-999);
                        var dummyContainerChildOffsetAfterScroll = dummyContainerChild.offset();
                        return {
                            //origin direction = determines if the zero scroll position is on the left or right side
                            //'i' means 'invert' (i === true means that the axis must be inverted to be correct)
                            //true = on the left side
                            //false = on the right side
                            i: dummyContainerOffset.left === dummyContainerChildOffset.left,
                            //negative = determines if the maximum scroll is positive or negative
                            //'n' means 'negate' (n === true means that the axis must be negated to be correct)
                            //true = negative
                            //false = positive
                            n: dummyContainerChildOffset.left !== dummyContainerChildOffsetAfterScroll.left
                        };
                    })(),
                    supportTransform: !!VENDORS._cssProperty('transform'),
                    supportTransition: !!VENDORS._cssProperty('transition'),
                    supportPassiveEvents: (function () {
                        var supportsPassive = false;
                        try {
                            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {
                                get: function () {
                                    supportsPassive = true;
                                }
                            }));
                        } catch (e) { }
                        return supportsPassive;
                    })(),
                    supportResizeObserver: !!COMPATIBILITY.rO(),
                    supportMutationObserver: !!COMPATIBILITY.mO()
                });

                scrollbarDummyElement.removeAttr(LEXICON.s).remove();

                //Catch zoom event:
                (function () {
                    if (nativeScrollbarIsOverlaid.x && nativeScrollbarIsOverlaid.y)
                        return;

                    var abs = MATH.abs;
                    var windowWidth = COMPATIBILITY.wW();
                    var windowHeight = COMPATIBILITY.wH();
                    var windowDpr = getWindowDPR();
                    var onResize = function () {
                        if (INSTANCES().length > 0) {
                            var newW = COMPATIBILITY.wW();
                            var newH = COMPATIBILITY.wH();
                            var deltaW = newW - windowWidth;
                            var deltaH = newH - windowHeight;

                            if (deltaW === 0 && deltaH === 0)
                                return;

                            var deltaWRatio = MATH.round(newW / (windowWidth / 100.0));
                            var deltaHRatio = MATH.round(newH / (windowHeight / 100.0));
                            var absDeltaW = abs(deltaW);
                            var absDeltaH = abs(deltaH);
                            var absDeltaWRatio = abs(deltaWRatio);
                            var absDeltaHRatio = abs(deltaHRatio);
                            var newDPR = getWindowDPR();

                            var deltaIsBigger = absDeltaW > 2 && absDeltaH > 2;
                            var difference = !differenceIsBiggerThanOne(absDeltaWRatio, absDeltaHRatio);
                            var dprChanged = newDPR !== windowDpr && windowDpr > 0;
                            var isZoom = deltaIsBigger && difference && dprChanged;
                            var oldScrollbarSize = _base.nativeScrollbarSize;
                            var newScrollbarSize;

                            if (isZoom) {
                                bodyElement.append(scrollbarDummyElement);
                                newScrollbarSize = _base.nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement[0]);
                                scrollbarDummyElement.remove();
                                if (oldScrollbarSize.x !== newScrollbarSize.x || oldScrollbarSize.y !== newScrollbarSize.y) {
                                    FRAMEWORK.each(INSTANCES(), function () {
                                        if (INSTANCES(this))
                                            INSTANCES(this).update('zoom');
                                    });
                                }
                            }

                            windowWidth = newW;
                            windowHeight = newH;
                            windowDpr = newDPR;
                        }
                    };

                    function differenceIsBiggerThanOne(valOne, valTwo) {
                        var absValOne = abs(valOne);
                        var absValTwo = abs(valTwo);
                        return !(absValOne === absValTwo || absValOne + 1 === absValTwo || absValOne - 1 === absValTwo);
                    }

                    function getWindowDPR() {
                        var dDPI = window.screen.deviceXDPI || 0;
                        var sDPI = window.screen.logicalXDPI || 1;
                        return window.devicePixelRatio || (dDPI / sDPI);
                    }

                    FRAMEWORK(window).on('resize', onResize);
                })();

                function calcNativeScrollbarSize(measureElement) {
                    return {
                        x: measureElement[LEXICON.oH] - measureElement[LEXICON.cH],
                        y: measureElement[LEXICON.oW] - measureElement[LEXICON.cW]
                    };
                }
            }

            /**
             * The object which manages the auto update loop for all OverlayScrollbars objects. This object is initialized only once: if the first OverlayScrollbars object gets initialized.
             * @constructor
             */
            function OverlayScrollbarsAutoUpdateLoop(globals) {
                var _base = this;
                var _inArray = FRAMEWORK.inArray;
                var _getNow = COMPATIBILITY.now;
                var _strAutoUpdate = 'autoUpdate';
                var _strAutoUpdateInterval = _strAutoUpdate + 'Interval';
                var _strLength = LEXICON.l;
                var _loopingInstances = [];
                var _loopingInstancesIntervalCache = [];
                var _loopIsActive = false;
                var _loopIntervalDefault = 33;
                var _loopInterval = _loopIntervalDefault;
                var _loopTimeOld = _getNow();
                var _loopID;


                /**
                 * The auto update loop which will run every 50 milliseconds or less if the update interval of a instance is lower than 50 milliseconds.
                 */
                var loop = function () {
                    if (_loopingInstances[_strLength] > 0 && _loopIsActive) {
                        _loopID = COMPATIBILITY.rAF()(function () {
                            loop();
                        });
                        var timeNew = _getNow();
                        var timeDelta = timeNew - _loopTimeOld;
                        var lowestInterval;
                        var instance;
                        var instanceOptions;
                        var instanceAutoUpdateAllowed;
                        var instanceAutoUpdateInterval;
                        var now;

                        if (timeDelta > _loopInterval) {
                            _loopTimeOld = timeNew - (timeDelta % _loopInterval);
                            lowestInterval = _loopIntervalDefault;
                            for (var i = 0; i < _loopingInstances[_strLength]; i++) {
                                instance = _loopingInstances[i];
                                if (instance !== undefined) {
                                    instanceOptions = instance.options();
                                    instanceAutoUpdateAllowed = instanceOptions[_strAutoUpdate];
                                    instanceAutoUpdateInterval = MATH.max(1, instanceOptions[_strAutoUpdateInterval]);
                                    now = _getNow();

                                    if ((instanceAutoUpdateAllowed === true || instanceAutoUpdateAllowed === null) && (now - _loopingInstancesIntervalCache[i]) > instanceAutoUpdateInterval) {
                                        instance.update('auto');
                                        _loopingInstancesIntervalCache[i] = new Date(now += instanceAutoUpdateInterval);
                                    }

                                    lowestInterval = MATH.max(1, MATH.min(lowestInterval, instanceAutoUpdateInterval));
                                }
                            }
                            _loopInterval = lowestInterval;
                        }
                    } else {
                        _loopInterval = _loopIntervalDefault;
                    }
                };

                /**
                 * Add OverlayScrollbars instance to the auto update loop. Only successful if the instance isn't already added.
                 * @param instance The instance which shall be updated in a loop automatically.
                 */
                _base.add = function (instance) {
                    if (_inArray(instance, _loopingInstances) === -1) {
                        _loopingInstances.push(instance);
                        _loopingInstancesIntervalCache.push(_getNow());
                        if (_loopingInstances[_strLength] > 0 && !_loopIsActive) {
                            _loopIsActive = true;
                            globals.autoUpdateLoop = _loopIsActive;
                            loop();
                        }
                    }
                };

                /**
                 * Remove OverlayScrollbars instance from the auto update loop. Only successful if the instance was added before.
                 * @param instance The instance which shall be updated in a loop automatically.
                 */
                _base.remove = function (instance) {
                    var index = _inArray(instance, _loopingInstances);
                    if (index > -1) {
                        //remove from loopingInstances list
                        _loopingInstancesIntervalCache.splice(index, 1);
                        _loopingInstances.splice(index, 1);

                        //correct update loop behavior
                        if (_loopingInstances[_strLength] === 0 && _loopIsActive) {
                            _loopIsActive = false;
                            globals.autoUpdateLoop = _loopIsActive;
                            if (_loopID !== undefined) {
                                COMPATIBILITY.cAF()(_loopID);
                                _loopID = -1;
                            }
                        }
                    }
                };
            }

            /**
             * A object which manages the scrollbars visibility of the target element.
             * @param pluginTargetElement The element from which the scrollbars shall be hidden.
             * @param options The custom options.
             * @param extensions The custom extensions.
             * @param globals
             * @param autoUpdateLoop
             * @returns {*}
             * @constructor
             */
            function OverlayScrollbarsInstance(pluginTargetElement, options, extensions, globals, autoUpdateLoop) {
                //shortcuts
                var type = COMPATIBILITY.type;
                var inArray = FRAMEWORK.inArray;
                var each = FRAMEWORK.each;

                //make correct instanceof
                var _base = new _plugin();
                var _frameworkProto = FRAMEWORK[LEXICON.p];

                //if passed element is no HTML element: skip and return
                if (!isHTMLElement(pluginTargetElement))
                    return;

                //if passed element is already initialized: set passed options if there are any and return its instance
                if (INSTANCES(pluginTargetElement)) {
                    var inst = INSTANCES(pluginTargetElement);
                    inst.options(options);
                    return inst;
                }

                //globals:
                var _nativeScrollbarIsOverlaid;
                var _overlayScrollbarDummySize;
                var _rtlScrollBehavior;
                var _autoUpdateRecommended;
                var _msieVersion;
                var _nativeScrollbarStyling;
                var _cssCalc;
                var _nativeScrollbarSize;
                var _supportTransition;
                var _supportTransform;
                var _supportPassiveEvents;
                var _supportResizeObserver;
                var _supportMutationObserver;
                var _restrictedMeasuring;

                //general readonly:
                var _initialized;
                var _destroyed;
                var _isTextarea;
                var _isBody;
                var _documentMixed;
                var _domExists;

                //general:
                var _isBorderBox;
                var _sizeAutoObserverAdded;
                var _paddingX;
                var _paddingY;
                var _borderX;
                var _borderY;
                var _marginX;
                var _marginY;
                var _isRTL;
                var _sleeping;
                var _contentBorderSize = {};
                var _scrollHorizontalInfo = {};
                var _scrollVerticalInfo = {};
                var _viewportSize = {};
                var _nativeScrollbarMinSize = {};

                //naming:	
                var _strMinusHidden = '-hidden';
                var _strMarginMinus = 'margin-';
                var _strPaddingMinus = 'padding-';
                var _strBorderMinus = 'border-';
                var _strTop = 'top';
                var _strRight = 'right';
                var _strBottom = 'bottom';
                var _strLeft = 'left';
                var _strMinMinus = 'min-';
                var _strMaxMinus = 'max-';
                var _strWidth = 'width';
                var _strHeight = 'height';
                var _strFloat = 'float';
                var _strEmpty = '';
                var _strAuto = 'auto';
                var _strSync = 'sync';
                var _strScroll = 'scroll';
                var _strHundredPercent = '100%';
                var _strX = 'x';
                var _strY = 'y';
                var _strDot = '.';
                var _strSpace = ' ';
                var _strScrollbar = 'scrollbar';
                var _strMinusHorizontal = '-horizontal';
                var _strMinusVertical = '-vertical';
                var _strScrollLeft = _strScroll + 'Left';
                var _strScrollTop = _strScroll + 'Top';
                var _strMouseTouchDownEvent = 'mousedown touchstart';
                var _strMouseTouchUpEvent = 'mouseup touchend touchcancel';
                var _strMouseTouchMoveEvent = 'mousemove touchmove';
                var _strMouseEnter = 'mouseenter';
                var _strMouseLeave = 'mouseleave';
                var _strKeyDownEvent = 'keydown';
                var _strKeyUpEvent = 'keyup';
                var _strSelectStartEvent = 'selectstart';
                var _strTransitionEndEvent = 'transitionend webkitTransitionEnd oTransitionEnd';
                var _strResizeObserverProperty = '__overlayScrollbarsRO__';

                //class names:	
                var _cassNamesPrefix = 'os-';
                var _classNameHTMLElement = _cassNamesPrefix + 'html';
                var _classNameHostElement = _cassNamesPrefix + 'host';
                var _classNameHostElementForeign = _classNameHostElement + '-foreign';
                var _classNameHostTextareaElement = _classNameHostElement + '-textarea';
                var _classNameHostScrollbarHorizontalHidden = _classNameHostElement + '-' + _strScrollbar + _strMinusHorizontal + _strMinusHidden;
                var _classNameHostScrollbarVerticalHidden = _classNameHostElement + '-' + _strScrollbar + _strMinusVertical + _strMinusHidden;
                var _classNameHostTransition = _classNameHostElement + '-transition';
                var _classNameHostRTL = _classNameHostElement + '-rtl';
                var _classNameHostResizeDisabled = _classNameHostElement + '-resize-disabled';
                var _classNameHostScrolling = _classNameHostElement + '-scrolling';
                var _classNameHostOverflow = _classNameHostElement + '-overflow';
                var _classNameHostOverflow = _classNameHostElement + '-overflow';
                var _classNameHostOverflowX = _classNameHostOverflow + '-x';
                var _classNameHostOverflowY = _classNameHostOverflow + '-y';
                var _classNameTextareaElement = _cassNamesPrefix + 'textarea';
                var _classNameTextareaCoverElement = _classNameTextareaElement + '-cover';
                var _classNamePaddingElement = _cassNamesPrefix + 'padding';
                var _classNameViewportElement = _cassNamesPrefix + 'viewport';
                var _classNameViewportNativeScrollbarsInvisible = _classNameViewportElement + '-native-scrollbars-invisible';
                var _classNameViewportNativeScrollbarsOverlaid = _classNameViewportElement + '-native-scrollbars-overlaid';
                var _classNameContentElement = _cassNamesPrefix + 'content';
                var _classNameContentArrangeElement = _cassNamesPrefix + 'content-arrange';
                var _classNameContentGlueElement = _cassNamesPrefix + 'content-glue';
                var _classNameSizeAutoObserverElement = _cassNamesPrefix + 'size-auto-observer';
                var _classNameResizeObserverElement = _cassNamesPrefix + 'resize-observer';
                var _classNameResizeObserverItemElement = _cassNamesPrefix + 'resize-observer-item';
                var _classNameResizeObserverItemFinalElement = _classNameResizeObserverItemElement + '-final';
                var _classNameTextInherit = _cassNamesPrefix + 'text-inherit';
                var _classNameScrollbar = _cassNamesPrefix + _strScrollbar;
                var _classNameScrollbarTrack = _classNameScrollbar + '-track';
                var _classNameScrollbarTrackOff = _classNameScrollbarTrack + '-off';
                var _classNameScrollbarHandle = _classNameScrollbar + '-handle';
                var _classNameScrollbarHandleOff = _classNameScrollbarHandle + '-off';
                var _classNameScrollbarUnusable = _classNameScrollbar + '-unusable';
                var _classNameScrollbarAutoHidden = _classNameScrollbar + '-' + _strAuto + _strMinusHidden;
                var _classNameScrollbarCorner = _classNameScrollbar + '-corner';
                var _classNameScrollbarCornerResize = _classNameScrollbarCorner + '-resize';
                var _classNameScrollbarCornerResizeB = _classNameScrollbarCornerResize + '-both';
                var _classNameScrollbarCornerResizeH = _classNameScrollbarCornerResize + _strMinusHorizontal;
                var _classNameScrollbarCornerResizeV = _classNameScrollbarCornerResize + _strMinusVertical;
                var _classNameScrollbarHorizontal = _classNameScrollbar + _strMinusHorizontal;
                var _classNameScrollbarVertical = _classNameScrollbar + _strMinusVertical;
                var _classNameDragging = _cassNamesPrefix + 'dragging';
                var _classNameThemeNone = _cassNamesPrefix + 'theme-none';
                var _classNamesDynamicDestroy = [
                    _classNameViewportNativeScrollbarsInvisible,
                    _classNameViewportNativeScrollbarsOverlaid,
                    _classNameScrollbarTrackOff,
                    _classNameScrollbarHandleOff,
                    _classNameScrollbarUnusable,
                    _classNameScrollbarAutoHidden,
                    _classNameScrollbarCornerResize,
                    _classNameScrollbarCornerResizeB,
                    _classNameScrollbarCornerResizeH,
                    _classNameScrollbarCornerResizeV,
                    _classNameDragging].join(_strSpace);

                //callbacks:	
                var _callbacksInitQeueue = [];

                //attrs viewport shall inherit from target	
                var _viewportAttrsFromTarget = [LEXICON.ti];

                //options:	
                var _defaultOptions;
                var _currentOptions;
                var _currentPreparedOptions;

                //extensions:	
                var _extensions = {};
                var _extensionsPrivateMethods = 'added removed on contract';

                //update	
                var _lastUpdateTime;
                var _swallowedUpdateHints = {};
                var _swallowedUpdateTimeout;
                var _swallowUpdateLag = 42;
                var _updateOnLoadEventName = 'load';
                var _updateOnLoadElms = [];

                //DOM elements:	
                var _windowElement;
                var _documentElement;
                var _htmlElement;
                var _bodyElement;
                var _targetElement;                     //the target element of this OverlayScrollbars object	
                var _hostElement;                       //the host element of this OverlayScrollbars object -> may be the same as targetElement	
                var _sizeAutoObserverElement;           //observes size auto changes	
                var _sizeObserverElement;               //observes size and padding changes	
                var _paddingElement;                    //manages the padding	
                var _viewportElement;                   //is the viewport of our scrollbar model	
                var _contentElement;                    //the element which holds the content	
                var _contentArrangeElement;             //is needed for correct sizing of the content element (only if native scrollbars are overlays)	
                var _contentGlueElement;                //has always the size of the content element	
                var _textareaCoverElement;              //only applied if target is a textarea element. Used for correct size calculation and for prevention of uncontrolled scrolling	
                var _scrollbarCornerElement;
                var _scrollbarHorizontalElement;
                var _scrollbarHorizontalTrackElement;
                var _scrollbarHorizontalHandleElement;
                var _scrollbarVerticalElement;
                var _scrollbarVerticalTrackElement;
                var _scrollbarVerticalHandleElement;
                var _windowElementNative;
                var _documentElementNative;
                var _targetElementNative;
                var _hostElementNative;
                var _sizeAutoObserverElementNative;
                var _sizeObserverElementNative;
                var _paddingElementNative;
                var _viewportElementNative;
                var _contentElementNative;

                //Cache:	
                var _hostSizeCache;
                var _contentScrollSizeCache;
                var _arrangeContentSizeCache;
                var _hasOverflowCache;
                var _hideOverflowCache;
                var _widthAutoCache;
                var _heightAutoCache;
                var _cssBoxSizingCache;
                var _cssPaddingCache;
                var _cssBorderCache;
                var _cssMarginCache;
                var _cssDirectionCache;
                var _cssDirectionDetectedCache;
                var _paddingAbsoluteCache;
                var _clipAlwaysCache;
                var _contentGlueSizeCache;
                var _overflowBehaviorCache;
                var _overflowAmountCache;
                var _ignoreOverlayScrollbarHidingCache;
                var _autoUpdateCache;
                var _sizeAutoCapableCache;
                var _contentElementScrollSizeChangeDetectedCache;
                var _hostElementSizeChangeDetectedCache;
                var _scrollbarsVisibilityCache;
                var _scrollbarsAutoHideCache;
                var _scrollbarsClickScrollingCache;
                var _scrollbarsDragScrollingCache;
                var _resizeCache;
                var _normalizeRTLCache;
                var _classNameCache;
                var _oldClassName;
                var _textareaAutoWrappingCache;
                var _textareaInfoCache;
                var _textareaSizeCache;
                var _textareaDynHeightCache;
                var _textareaDynWidthCache;
                var _bodyMinSizeCache;
                var _updateAutoCache = {};

                //MutationObserver:	
                var _mutationObserverHost;
                var _mutationObserverContent;
                var _mutationObserverHostCallback;
                var _mutationObserverContentCallback;
                var _mutationObserversConnected;
                var _mutationObserverAttrsTextarea = ['wrap', 'cols', 'rows'];
                var _mutationObserverAttrsHost = [LEXICON.i, LEXICON.c, LEXICON.s, 'open'].concat(_viewportAttrsFromTarget);

                //events:	
                var _destroyEvents = [];

                //textarea:	
                var _textareaHasFocus;

                //scrollbars:	
                var _scrollbarsAutoHideTimeoutId;
                var _scrollbarsAutoHideMoveTimeoutId;
                var _scrollbarsAutoHideDelay;
                var _scrollbarsAutoHideNever;
                var _scrollbarsAutoHideScroll;
                var _scrollbarsAutoHideMove;
                var _scrollbarsAutoHideLeave;
                var _scrollbarsHandleHovered;
                var _scrollbarsHandlesDefineScrollPos;

                //resize	
                var _resizeNone;
                var _resizeBoth;
                var _resizeHorizontal;
                var _resizeVertical;


                //==== Event Listener ====//	

                /**	
                 * Adds or removes a event listener from the given element. 	
                 * @param element The element to which the event listener shall be applied or removed.	
                 * @param eventNames The name(s) of the events.	
                 * @param listener The method which shall be called.	
                 * @param remove True if the handler shall be removed, false or undefined if the handler shall be added.	
                 * @param passiveOrOptions The options for the event.
                 */
                function setupResponsiveEventListener(element, eventNames, listener, remove, passiveOrOptions) {
                    var collected = COMPATIBILITY.isA(eventNames) && COMPATIBILITY.isA(listener);
                    var method = remove ? 'removeEventListener' : 'addEventListener';
                    var onOff = remove ? 'off' : 'on';
                    var events = collected ? false : eventNames.split(_strSpace)
                    var i = 0;

                    var passiveOrOptionsIsObj = FRAMEWORK.isPlainObject(passiveOrOptions);
                    var passive = _supportPassiveEvents && (passiveOrOptionsIsObj ? (passiveOrOptions._passive || false) : passiveOrOptions);
                    var capture = passiveOrOptionsIsObj && (passiveOrOptions._capture || false);
                    var useNative = capture || passive;
                    var nativeParam = passive ? {
                        passive: passive,
                        capture: capture,
                    } : capture;

                    if (collected) {
                        for (; i < eventNames[LEXICON.l]; i++)
                            setupResponsiveEventListener(element, eventNames[i], listener[i], remove, passiveOrOptions);
                    }
                    else {
                        for (; i < events[LEXICON.l]; i++) {
                            if(useNative) {
                                element[0][method](events[i], listener, nativeParam);
                            }
                            else {
                                element[onOff](events[i], listener);
                            }     
                        }
                    }
                }


                function addDestroyEventListener(element, eventNames, listener, passive) {
                    setupResponsiveEventListener(element, eventNames, listener, false, passive);
                    _destroyEvents.push(COMPATIBILITY.bind(setupResponsiveEventListener, 0, element, eventNames, listener, true, passive));
                }

                //==== Resize Observer ====//

                /**
                 * Adds or removes a resize observer from the given element.
                 * @param targetElement The element to which the resize observer shall be added or removed.
                 * @param onElementResizedCallback The callback which is fired every time the resize observer registers a size change or false / undefined if the resizeObserver shall be removed.
                 */
                function setupResizeObserver(targetElement, onElementResizedCallback) {
                    if (targetElement) {
                        var resizeObserver = COMPATIBILITY.rO();
                        var strAnimationStartEvent = 'animationstart mozAnimationStart webkitAnimationStart MSAnimationStart';
                        var strChildNodes = 'childNodes';
                        var constScroll = 3333333;
                        var callback = function () {
                            targetElement[_strScrollTop](constScroll)[_strScrollLeft](_isRTL ? _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll : constScroll);
                            onElementResizedCallback();
                        };
                        //add resize observer:
                        if (onElementResizedCallback) {
                            if (_supportResizeObserver) {
                                var element = targetElement.addClass('observed').append(generateDiv(_classNameResizeObserverElement)).contents()[0];
                                var observer = element[_strResizeObserverProperty] = new resizeObserver(callback);
                                observer.observe(element);
                            }
                            else {
                                if (_msieVersion > 9 || !_autoUpdateRecommended) {
                                    targetElement.prepend(
                                        generateDiv(_classNameResizeObserverElement,
                                            generateDiv({ c: _classNameResizeObserverItemElement, dir: 'ltr' },
                                                generateDiv(_classNameResizeObserverItemElement,
                                                    generateDiv(_classNameResizeObserverItemFinalElement)
                                                ) +
                                                generateDiv(_classNameResizeObserverItemElement,
                                                    generateDiv({ c: _classNameResizeObserverItemFinalElement, style: 'width: 200%; height: 200%' })
                                                )
                                            )
                                        )
                                    );

                                    var observerElement = targetElement[0][strChildNodes][0][strChildNodes][0];
                                    var shrinkElement = FRAMEWORK(observerElement[strChildNodes][1]);
                                    var expandElement = FRAMEWORK(observerElement[strChildNodes][0]);
                                    var expandElementChild = FRAMEWORK(expandElement[0][strChildNodes][0]);
                                    var widthCache = observerElement[LEXICON.oW];
                                    var heightCache = observerElement[LEXICON.oH];
                                    var isDirty;
                                    var rAFId;
                                    var currWidth;
                                    var currHeight;
                                    var factor = 2;
                                    var nativeScrollbarSize = globals.nativeScrollbarSize; //care don't make changes to this object!!!
                                    var reset = function () {
                                        /*
                                         var sizeResetWidth = observerElement[LEXICON.oW] + nativeScrollbarSize.x * factor + nativeScrollbarSize.y * factor + _overlayScrollbarDummySize.x + _overlayScrollbarDummySize.y;
                                         var sizeResetHeight = observerElement[LEXICON.oH] + nativeScrollbarSize.x * factor + nativeScrollbarSize.y * factor + _overlayScrollbarDummySize.x + _overlayScrollbarDummySize.y;
                                         var expandChildCSS = {};
                                         expandChildCSS[_strWidth] = sizeResetWidth;
                                         expandChildCSS[_strHeight] = sizeResetHeight;
                                         expandElementChild.css(expandChildCSS);


                                         expandElement[_strScrollLeft](sizeResetWidth)[_strScrollTop](sizeResetHeight);
                                         shrinkElement[_strScrollLeft](sizeResetWidth)[_strScrollTop](sizeResetHeight);
                                         */
                                        expandElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);
                                        shrinkElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);
                                    };
                                    var onResized = function () {
                                        rAFId = 0;
                                        if (!isDirty)
                                            return;

                                        widthCache = currWidth;
                                        heightCache = currHeight;
                                        callback();
                                    };
                                    var onScroll = function (event) {
                                        currWidth = observerElement[LEXICON.oW];
                                        currHeight = observerElement[LEXICON.oH];
                                        isDirty = currWidth != widthCache || currHeight != heightCache;

                                        if (event && isDirty && !rAFId) {
                                            COMPATIBILITY.cAF()(rAFId);
                                            rAFId = COMPATIBILITY.rAF()(onResized);
                                        }
                                        else if (!event)
                                            onResized();

                                        reset();
                                        if (event) {
                                            COMPATIBILITY.prvD(event);
                                            COMPATIBILITY.stpP(event);
                                        }
                                        return false;
                                    };
                                    var expandChildCSS = {};
                                    var observerElementCSS = {};

                                    setTopRightBottomLeft(observerElementCSS, _strEmpty, [
                                        -((nativeScrollbarSize.y + 1) * factor),
                                        nativeScrollbarSize.x * -factor,
                                        nativeScrollbarSize.y * -factor,
                                        -((nativeScrollbarSize.x + 1) * factor)
                                    ]);

                                    FRAMEWORK(observerElement).css(observerElementCSS);
                                    expandElement.on(_strScroll, onScroll);
                                    shrinkElement.on(_strScroll, onScroll);
                                    targetElement.on(strAnimationStartEvent, function () {
                                        onScroll(false);
                                    });
                                    //lets assume that the divs will never be that large and a constant value is enough
                                    expandChildCSS[_strWidth] = constScroll;
                                    expandChildCSS[_strHeight] = constScroll;
                                    expandElementChild.css(expandChildCSS);

                                    reset();
                                }
                                else {
                                    var attachEvent = _documentElementNative.attachEvent;
                                    var isIE = _msieVersion !== undefined;
                                    if (attachEvent) {
                                        targetElement.prepend(generateDiv(_classNameResizeObserverElement));
                                        findFirst(targetElement, _strDot + _classNameResizeObserverElement)[0].attachEvent('onresize', callback);
                                    }
                                    else {
                                        var obj = _documentElementNative.createElement(TYPES.o);
                                        obj.setAttribute(LEXICON.ti, '-1');
                                        obj.setAttribute(LEXICON.c, _classNameResizeObserverElement);
                                        obj.onload = function () {
                                            var wnd = this.contentDocument.defaultView;
                                            wnd.addEventListener('resize', callback);
                                            wnd.document.documentElement.style.display = 'none';
                                        };
                                        obj.type = 'text/html';
                                        if (isIE)
                                            targetElement.prepend(obj);
                                        obj.data = 'about:blank';
                                        if (!isIE)
                                            targetElement.prepend(obj);
                                        targetElement.on(strAnimationStartEvent, callback);
                                    }
                                }
                            }

                            if (targetElement[0] === _sizeObserverElementNative) {
                                var directionChanged = function () {
                                    var dir = _hostElement.css('direction');
                                    var css = {};
                                    var scrollLeftValue = 0;
                                    var result = false;
                                    if (dir !== _cssDirectionDetectedCache) {
                                        if (dir === 'ltr') {
                                            css[_strLeft] = 0;
                                            css[_strRight] = _strAuto;
                                            scrollLeftValue = constScroll;
                                        }
                                        else {
                                            css[_strLeft] = _strAuto;
                                            css[_strRight] = 0;
                                            scrollLeftValue = _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll;
                                        }
                                        //execution order is important for IE!!!
                                        _sizeObserverElement.children().eq(0).css(css);
                                        _sizeObserverElement[_strScrollLeft](scrollLeftValue)[_strScrollTop](constScroll);
                                        _cssDirectionDetectedCache = dir;
                                        result = true;
                                    }
                                    return result;
                                };
                                directionChanged();
                                addDestroyEventListener(targetElement, _strScroll, function (event) {
                                    if (directionChanged())
                                        update();
                                    COMPATIBILITY.prvD(event);
                                    COMPATIBILITY.stpP(event);
                                    return false;
                                });
                            }
                        }
                        //remove resize observer:
                        else {
                            if (_supportResizeObserver) {
                                var element = targetElement.contents()[0];
                                var resizeObserverObj = element[_strResizeObserverProperty];
                                if (resizeObserverObj) {
                                    resizeObserverObj.disconnect();
                                    delete element[_strResizeObserverProperty];
                                }
                            }
                            else {
                                remove(targetElement.children(_strDot + _classNameResizeObserverElement).eq(0));
                            }
                        }
                    }
                }

                /**
                 * Freezes or unfreezes the given resize observer.
                 * @param targetElement The element to which the target resize observer is applied.
                 * @param freeze True if the resize observer shall be frozen, false otherwise.
                 
                function freezeResizeObserver(targetElement, freeze) {
                    if (targetElement !== undefined) {
                        if(freeze) {
                            if (_supportResizeObserver) {
                                var element = targetElement.contents()[0];
                                element[_strResizeObserverProperty].unobserve(element);
                            }
                            else {
                                targetElement = targetElement.children(_strDot + _classNameResizeObserverElement).eq(0);
                                var w = targetElement.css(_strWidth);
                                var h = targetElement.css(_strHeight);
                                var css = {};
                                css[_strWidth] = w;
                                css[_strHeight] = h;
                                targetElement.css(css);
                            }
                        }
                        else {
                            if (_supportResizeObserver) {
                                var element = targetElement.contents()[0];
                                element[_strResizeObserverProperty].observe(element);
                            }
                            else {
                                var css = { };
                                css[_strHeight] = _strEmpty;
                                css[_strWidth] = _strEmpty;
                                targetElement.children(_strDot + _classNameResizeObserverElement).eq(0).css(css);
                            }
                        }
                    }
                }
                */


                //==== Mutation Observers ====//

                /**
                 * Creates MutationObservers for the host and content Element if they are supported.
                 */
                function createMutationObservers() {
                    if (_supportMutationObserver) {
                        var mutationObserverContentLag = 11;
                        var mutationObserver = COMPATIBILITY.mO();
                        var contentLastUpdate = COMPATIBILITY.now();
                        var mutationTarget;
                        var mutationAttrName;
                        var mutationIsClass;
                        var oldMutationVal;
                        var newClassVal;
                        var hostClassNameRegex;
                        var contentTimeout;
                        var now;
                        var sizeAuto;
                        var action;

                        _mutationObserverHostCallback = function (mutations) {

                            var doUpdate = false;
                            var doUpdateForce = false;
                            var mutation;
                            var mutatedAttrs = [];

                            if (_initialized && !_sleeping) {
                                each(mutations, function () {
                                    mutation = this;
                                    mutationTarget = mutation.target;
                                    mutationAttrName = mutation.attributeName;
                                    mutationIsClass = mutationAttrName === LEXICON.c;
                                    oldMutationVal = mutation.oldValue;
                                    newClassVal = mutationTarget.className;

                                    if (_domExists && mutationIsClass && !doUpdateForce) {
                                        // if old class value contains _classNameHostElementForeign and new class value doesn't
                                        if (oldMutationVal.indexOf(_classNameHostElementForeign) > -1 && newClassVal.indexOf(_classNameHostElementForeign) < 0) {
                                            hostClassNameRegex = createHostClassNameRegExp(true);
                                            _hostElementNative.className = newClassVal.split(_strSpace).concat(oldMutationVal.split(_strSpace).filter(function (name) {
                                                return name.match(hostClassNameRegex);
                                            })).join(_strSpace);
                                            doUpdate = doUpdateForce = true;
                                        }
                                    }

                                    if (!doUpdate) {
                                        doUpdate = mutationIsClass
                                            ? hostClassNamesChanged(oldMutationVal, newClassVal)
                                            : mutationAttrName === LEXICON.s
                                                ? oldMutationVal !== mutationTarget[LEXICON.s].cssText
                                                : true;
                                    }

                                    mutatedAttrs.push(mutationAttrName);
                                });

                                updateViewportAttrsFromTarget(mutatedAttrs);

                                if (doUpdate)
                                    _base.update(doUpdateForce || _strAuto);
                            }
                            return doUpdate;
                        };
                        _mutationObserverContentCallback = function (mutations) {
                            var doUpdate = false;
                            var mutation;

                            if (_initialized && !_sleeping) {
                                each(mutations, function () {
                                    mutation = this;
                                    doUpdate = isUnknownMutation(mutation);
                                    return !doUpdate;
                                });

                                if (doUpdate) {
                                    now = COMPATIBILITY.now();
                                    sizeAuto = (_heightAutoCache || _widthAutoCache);
                                    action = function () {
                                        if (!_destroyed) {
                                            contentLastUpdate = now;

                                            //if cols, rows or wrap attr was changed
                                            if (_isTextarea)
                                                textareaUpdate();

                                            if (sizeAuto)
                                                update();
                                            else
                                                _base.update(_strAuto);
                                        }
                                    };
                                    clearTimeout(contentTimeout);
                                    if (mutationObserverContentLag <= 0 || now - contentLastUpdate > mutationObserverContentLag || !sizeAuto)
                                        action();
                                    else
                                        contentTimeout = setTimeout(action, mutationObserverContentLag);
                                }
                            }
                            return doUpdate;
                        }

                        _mutationObserverHost = new mutationObserver(_mutationObserverHostCallback);
                        _mutationObserverContent = new mutationObserver(_mutationObserverContentCallback);
                    }
                }

                /**
                 * Connects the MutationObservers if they are supported.
                 */
                function connectMutationObservers() {
                    if (_supportMutationObserver && !_mutationObserversConnected) {
                        _mutationObserverHost.observe(_hostElementNative, {
                            attributes: true,
                            attributeOldValue: true,
                            attributeFilter: _mutationObserverAttrsHost
                        });

                        _mutationObserverContent.observe(_isTextarea ? _targetElementNative : _contentElementNative, {
                            attributes: true,
                            attributeOldValue: true,
                            subtree: !_isTextarea,
                            childList: !_isTextarea,
                            characterData: !_isTextarea,
                            attributeFilter: _isTextarea ? _mutationObserverAttrsTextarea : _mutationObserverAttrsHost
                        });

                        _mutationObserversConnected = true;
                    }
                }

                /**
                 * Disconnects the MutationObservers if they are supported.
                 */
                function disconnectMutationObservers() {
                    if (_supportMutationObserver && _mutationObserversConnected) {
                        _mutationObserverHost.disconnect();
                        _mutationObserverContent.disconnect();

                        _mutationObserversConnected = false;
                    }
                }


                //==== Events of elements ====//

                /**
                 * This method gets called every time the host element gets resized. IMPORTANT: Padding changes are detected too!!
                 * It refreshes the hostResizedEventArgs and the hostSizeResizeCache.
                 * If there are any size changes, the update method gets called.
                 */
                function hostOnResized() {
                    if (!_sleeping) {
                        var changed;
                        var hostSize = {
                            w: _sizeObserverElementNative[LEXICON.sW],
                            h: _sizeObserverElementNative[LEXICON.sH]
                        };

                        changed = checkCache(hostSize, _hostElementSizeChangeDetectedCache);
                        _hostElementSizeChangeDetectedCache = hostSize;
                        if (changed)
                            update({ _hostSizeChanged: true });
                    }
                }

                /**
                 * The mouse enter event of the host element. This event is only needed for the autoHide feature.
                 */
                function hostOnMouseEnter() {
                    if (_scrollbarsAutoHideLeave)
                        refreshScrollbarsAutoHide(true);
                }

                /**
                 * The mouse leave event of the host element. This event is only needed for the autoHide feature.
                 */
                function hostOnMouseLeave() {
                    if (_scrollbarsAutoHideLeave && !_bodyElement.hasClass(_classNameDragging))
                        refreshScrollbarsAutoHide(false);
                }

                /**
                 * The mouse move event of the host element. This event is only needed for the autoHide "move" feature.
                 */
                function hostOnMouseMove() {
                    if (_scrollbarsAutoHideMove) {
                        refreshScrollbarsAutoHide(true);
                        clearTimeout(_scrollbarsAutoHideMoveTimeoutId);
                        _scrollbarsAutoHideMoveTimeoutId = setTimeout(function () {
                            if (_scrollbarsAutoHideMove && !_destroyed)
                                refreshScrollbarsAutoHide(false);
                        }, 100);
                    }
                }

                /**
                 * Prevents text from deselection if attached to the document element on the mousedown event of a DOM element.
                 * @param event The select start event.
                 */
                function documentOnSelectStart(event) {
                    COMPATIBILITY.prvD(event);
                    return false;
                }

                /**	
                 * A callback which will be called after a element has loaded.	
                 */
                function updateOnLoadCallback(event) {
                    var elm = FRAMEWORK(event.target);

                    eachUpdateOnLoad(function (i, updateOnLoadSelector) {
                        if (elm.is(updateOnLoadSelector)) {
                            update({ _contentSizeChanged: true });
                        }
                    });
                }

                /**
                * Adds or removes mouse & touch events of the host element. (for handling auto-hiding of the scrollbars)
                * @param destroy Indicates whether the events shall be added or removed.
                */
                function setupHostMouseTouchEvents(destroy) {
                    if (!destroy)
                        setupHostMouseTouchEvents(true);

                    setupResponsiveEventListener(_hostElement,
                        _strMouseTouchMoveEvent.split(_strSpace)[0],
                        hostOnMouseMove,
                        (!_scrollbarsAutoHideMove || destroy), true);
                    setupResponsiveEventListener(_hostElement,
                        [_strMouseEnter, _strMouseLeave],
                        [hostOnMouseEnter, hostOnMouseLeave],
                        (!_scrollbarsAutoHideLeave || destroy), true);

                    //if the plugin is initialized and the mouse is over the host element, make the scrollbars visible
                    if (!_initialized && !destroy)
                        _hostElement.one('mouseover', hostOnMouseEnter);
                }


                //==== Update Detection ====//

                /**
                 * Measures the min width and min height of the body element and refreshes the related cache.
                 * @returns {boolean} True if the min width or min height has changed, false otherwise.
                 */
                function bodyMinSizeChanged() {
                    var bodyMinSize = {};
                    if (_isBody && _contentArrangeElement) {
                        bodyMinSize.w = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strWidth));
                        bodyMinSize.h = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strHeight));
                        bodyMinSize.c = checkCache(bodyMinSize, _bodyMinSizeCache);
                        bodyMinSize.f = true; //flag for "measured at least once"
                    }
                    _bodyMinSizeCache = bodyMinSize;
                    return !!bodyMinSize.c;
                }

                /**
                 * Returns true if the class names really changed (new class without plugin host prefix)
                 * @param oldClassNames The old ClassName string or array.
                 * @param newClassNames The new ClassName string or array.
                 * @returns {boolean} True if the class names has really changed, false otherwise.
                 */
                function hostClassNamesChanged(oldClassNames, newClassNames) {
                    var currClasses = typeof newClassNames == TYPES.s ? newClassNames.split(_strSpace) : [];
                    var oldClasses = typeof oldClassNames == TYPES.s ? oldClassNames.split(_strSpace) : [];
                    var diff = getArrayDifferences(oldClasses, currClasses);

                    // remove none theme from diff list to prevent update
                    var idx = inArray(_classNameThemeNone, diff);
                    var i;
                    var regex;

                    if (idx > -1)
                        diff.splice(idx, 1);

                    if (diff[LEXICON.l] > 0) {
                        regex = createHostClassNameRegExp(true, true);
                        for (i = 0; i < diff.length; i++) {
                            if (!diff[i].match(regex)) {
                                return true;
                            }
                        }
                    }
                    return false;
                }

                /**
                 * Returns true if the given mutation is not from a from the plugin generated element. If the target element is a textarea the mutation is always unknown.
                 * @param mutation The mutation which shall be checked.
                 * @returns {boolean} True if the mutation is from a unknown element, false otherwise.
                 */
                function isUnknownMutation(mutation) {
                    var attributeName = mutation.attributeName;
                    var mutationTarget = mutation.target;
                    var mutationType = mutation.type;
                    var strClosest = 'closest';

                    if (mutationTarget === _contentElementNative)
                        return attributeName === null;
                    if (mutationType === 'attributes' && (attributeName === LEXICON.c || attributeName === LEXICON.s) && !_isTextarea) {
                        //ignore className changes by the plugin	
                        if (attributeName === LEXICON.c && FRAMEWORK(mutationTarget).hasClass(_classNameHostElement))
                            return hostClassNamesChanged(mutation.oldValue, mutationTarget.className);

                        //only do it of browser support it natively	
                        if (typeof mutationTarget[strClosest] != TYPES.f)
                            return true;
                        if (mutationTarget[strClosest](_strDot + _classNameResizeObserverElement) !== null ||
                            mutationTarget[strClosest](_strDot + _classNameScrollbar) !== null ||
                            mutationTarget[strClosest](_strDot + _classNameScrollbarCorner) !== null)
                            return false;
                    }
                    return true;
                }

                /**
                 * Returns true if the content size was changed since the last time this method was called.
                 * @returns {boolean} True if the content size was changed, false otherwise.
                 */
                function updateAutoContentSizeChanged() {
                    if (_sleeping)
                        return false;

                    var contentMeasureElement = getContentMeasureElement();
                    var textareaValueLength = _isTextarea && _widthAutoCache && !_textareaAutoWrappingCache ? _targetElement.val().length : 0;
                    var setCSS = !_mutationObserversConnected && _widthAutoCache && !_isTextarea;
                    var css = {};
                    var float;
                    var bodyMinSizeC;
                    var changed;
                    var contentElementScrollSize;

                    if (setCSS) {
                        float = _contentElement.css(_strFloat);
                        css[_strFloat] = _isRTL ? _strRight : _strLeft;
                        css[_strWidth] = _strAuto;
                        _contentElement.css(css);
                    }
                    contentElementScrollSize = {
                        w: contentMeasureElement[LEXICON.sW] + textareaValueLength,
                        h: contentMeasureElement[LEXICON.sH] + textareaValueLength
                    };
                    if (setCSS) {
                        css[_strFloat] = float;
                        css[_strWidth] = _strHundredPercent;
                        _contentElement.css(css);
                    }

                    bodyMinSizeC = bodyMinSizeChanged();
                    changed = checkCache(contentElementScrollSize, _contentElementScrollSizeChangeDetectedCache);

                    _contentElementScrollSizeChangeDetectedCache = contentElementScrollSize;

                    return changed || bodyMinSizeC;
                }

                /**
                 * Returns true when a attribute which the MutationObserver would observe has changed.  
                 * @returns {boolean} True if one of the attributes which a MutationObserver would observe has changed, false or undefined otherwise.
                 */
                function meaningfulAttrsChanged() {
                    if (_sleeping || _mutationObserversConnected)
                        return;

                    var elem;
                    var curr;
                    var cache;
                    var changedAttrs = [];
                    var checks = [
                        {
                            _elem: _hostElement,
                            _attrs: _mutationObserverAttrsHost.concat(':visible')
                        },
                        {
                            _elem: _isTextarea ? _targetElement : undefined,
                            _attrs: _mutationObserverAttrsTextarea
                        }
                    ];

                    each(checks, function (index, check) {
                        elem = check._elem;
                        if (elem) {
                            each(check._attrs, function (index, attr) {
                                curr = attr.charAt(0) === ':' ? elem.is(attr) : elem.attr(attr);
                                cache = _updateAutoCache[attr];

                                if (checkCache(curr, cache)) {
                                    changedAttrs.push(attr);
                                }

                                _updateAutoCache[attr] = curr;
                            });
                        }
                    });

                    updateViewportAttrsFromTarget(changedAttrs);

                    return changedAttrs[LEXICON.l] > 0;
                }

                /**
                 * Checks is a CSS Property of a child element is affecting the scroll size of the content.
                 * @param propertyName The CSS property name.
                 * @returns {boolean} True if the property is affecting the content scroll size, false otherwise.
                 */
                function isSizeAffectingCSSProperty(propertyName) {
                    if (!_initialized)
                        return true;
                    var flexGrow = 'flex-grow';
                    var flexShrink = 'flex-shrink';
                    var flexBasis = 'flex-basis';
                    var affectingPropsX = [
                        _strWidth,
                        _strMinMinus + _strWidth,
                        _strMaxMinus + _strWidth,
                        _strMarginMinus + _strLeft,
                        _strMarginMinus + _strRight,
                        _strLeft,
                        _strRight,
                        'font-weight',
                        'word-spacing',
                        flexGrow,
                        flexShrink,
                        flexBasis
                    ];
                    var affectingPropsXContentBox = [
                        _strPaddingMinus + _strLeft,
                        _strPaddingMinus + _strRight,
                        _strBorderMinus + _strLeft + _strWidth,
                        _strBorderMinus + _strRight + _strWidth
                    ];
                    var affectingPropsY = [
                        _strHeight,
                        _strMinMinus + _strHeight,
                        _strMaxMinus + _strHeight,
                        _strMarginMinus + _strTop,
                        _strMarginMinus + _strBottom,
                        _strTop,
                        _strBottom,
                        'line-height',
                        flexGrow,
                        flexShrink,
                        flexBasis
                    ];
                    var affectingPropsYContentBox = [
                        _strPaddingMinus + _strTop,
                        _strPaddingMinus + _strBottom,
                        _strBorderMinus + _strTop + _strWidth,
                        _strBorderMinus + _strBottom + _strWidth
                    ];
                    var _strS = 's';
                    var _strVS = 'v-s';
                    var checkX = _overflowBehaviorCache.x === _strS || _overflowBehaviorCache.x === _strVS;
                    var checkY = _overflowBehaviorCache.y === _strS || _overflowBehaviorCache.y === _strVS;
                    var sizeIsAffected = false;
                    var checkPropertyName = function (arr, name) {
                        for (var i = 0; i < arr[LEXICON.l]; i++) {
                            if (arr[i] === name)
                                return true;
                        }
                        return false;
                    };

                    if (checkY) {
                        sizeIsAffected = checkPropertyName(affectingPropsY, propertyName);
                        if (!sizeIsAffected && !_isBorderBox)
                            sizeIsAffected = checkPropertyName(affectingPropsYContentBox, propertyName);
                    }
                    if (checkX && !sizeIsAffected) {
                        sizeIsAffected = checkPropertyName(affectingPropsX, propertyName);
                        if (!sizeIsAffected && !_isBorderBox)
                            sizeIsAffected = checkPropertyName(affectingPropsXContentBox, propertyName);
                    }
                    return sizeIsAffected;
                }


                //==== Update ====//

                /**
                 * Sets the attribute values of the viewport element to the values from the target element.
                 * The value of a attribute is only set if the attribute is whitelisted.
                 * @attrs attrs The array of attributes which shall be set or undefined if all whitelisted shall be set.
                 */
                function updateViewportAttrsFromTarget(attrs) {
                    attrs = attrs || _viewportAttrsFromTarget;
                    each(attrs, function (index, attr) {
                        if (COMPATIBILITY.inA(attr, _viewportAttrsFromTarget) > -1) {
                            var targetAttr = _targetElement.attr(attr);
                            if (type(targetAttr) == TYPES.s) {
                                _viewportElement.attr(attr, targetAttr);
                            }
                            else {
                                _viewportElement.removeAttr(attr);
                            }
                        }
                    });
                }

                /**
                 * Updates the variables and size of the textarea element, and manages the scroll on new line or new character.
                 */
                function textareaUpdate() {
                    if (!_sleeping) {
                        var wrapAttrOff = !_textareaAutoWrappingCache;
                        var minWidth = _viewportSize.w;
                        var minHeight = _viewportSize.h;
                        var css = {};
                        var doMeasure = _widthAutoCache || wrapAttrOff;
                        var origWidth;
                        var width;
                        var origHeight;
                        var height;

                        //reset min size
                        css[_strMinMinus + _strWidth] = _strEmpty;
                        css[_strMinMinus + _strHeight] = _strEmpty;

                        //set width auto
                        css[_strWidth] = _strAuto;
                        _targetElement.css(css);

                        //measure width
                        origWidth = _targetElementNative[LEXICON.oW];
                        width = doMeasure ? MATH.max(origWidth, _targetElementNative[LEXICON.sW] - 1) : 1;
                        /*width += (_widthAutoCache ? _marginX + (!_isBorderBox ? wrapAttrOff ? 0 : _paddingX + _borderX : 0) : 0);*/

                        //set measured width
                        css[_strWidth] = _widthAutoCache ? _strAuto /*width*/ : _strHundredPercent;
                        css[_strMinMinus + _strWidth] = _strHundredPercent;

                        //set height auto
                        css[_strHeight] = _strAuto;
                        _targetElement.css(css);

                        //measure height
                        origHeight = _targetElementNative[LEXICON.oH];
                        height = MATH.max(origHeight, _targetElementNative[LEXICON.sH] - 1);

                        //append correct size values
                        css[_strWidth] = width;
                        css[_strHeight] = height;
                        _textareaCoverElement.css(css);

                        //apply min width / min height to prevent textarea collapsing
                        css[_strMinMinus + _strWidth] = minWidth /*+ (!_isBorderBox && _widthAutoCache ? _paddingX + _borderX : 0)*/;
                        css[_strMinMinus + _strHeight] = minHeight /*+ (!_isBorderBox && _heightAutoCache ? _paddingY + _borderY : 0)*/;
                        _targetElement.css(css);

                        return {
                            _originalWidth: origWidth,
                            _originalHeight: origHeight,
                            _dynamicWidth: width,
                            _dynamicHeight: height
                        };
                    }
                }

                /**
                 * Updates the plugin and DOM to the current options.
                 * This method should only be called if a update is 100% required.
                 * @param updateHints A objects which contains hints for this update:
                 * {
                 *   _hostSizeChanged : boolean,
                 *   _contentSizeChanged : boolean,
                 *   _force : boolean,                             == preventSwallowing
                 *   _changedOptions : { },                        == preventSwallowing && preventSleep
                *  }
                 */
                function update(updateHints) {
                    clearTimeout(_swallowedUpdateTimeout);
                    updateHints = updateHints || {};
                    _swallowedUpdateHints._hostSizeChanged |= updateHints._hostSizeChanged;
                    _swallowedUpdateHints._contentSizeChanged |= updateHints._contentSizeChanged;
                    _swallowedUpdateHints._force |= updateHints._force;

                    var now = COMPATIBILITY.now();
                    var hostSizeChanged = !!_swallowedUpdateHints._hostSizeChanged;
                    var contentSizeChanged = !!_swallowedUpdateHints._contentSizeChanged;
                    var force = !!_swallowedUpdateHints._force;
                    var changedOptions = updateHints._changedOptions;
                    var swallow = _swallowUpdateLag > 0 && _initialized && !_destroyed && !force && !changedOptions && (now - _lastUpdateTime) < _swallowUpdateLag && (!_heightAutoCache && !_widthAutoCache);
                    var displayIsHidden;

                    if (swallow)
                        _swallowedUpdateTimeout = setTimeout(update, _swallowUpdateLag);

                    //abort update due to:
                    //destroyed
                    //swallowing
                    //sleeping
                    //host is hidden or has false display
                    if (_destroyed || swallow || (_sleeping && !changedOptions) || (_initialized && !force && (displayIsHidden = _hostElement.is(':hidden'))) || _hostElement.css('display') === 'inline')
                        return;

                    _lastUpdateTime = now;
                    _swallowedUpdateHints = {};

                    //if scrollbar styling is possible and native scrollbars aren't overlaid the scrollbar styling will be applied which hides the native scrollbars completely.
                    if (_nativeScrollbarStyling && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {
                        //native scrollbars are hidden, so change the values to zero
                        _nativeScrollbarSize.x = 0;
                        _nativeScrollbarSize.y = 0;
                    }
                    else {
                        //refresh native scrollbar size (in case of zoom)
                        _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);
                    }

                    // Scrollbar padding is needed for firefox, because firefox hides scrollbar automatically if the size of the div is too small.
                    // The calculation: [scrollbar size +3 *3]
                    // (+3 because of possible decoration e.g. borders, margins etc., but only if native scrollbar is NOT a overlaid scrollbar)
                    // (*3 because (1)increase / (2)decrease -button and (3)resize handle)
                    _nativeScrollbarMinSize = {
                        x: (_nativeScrollbarSize.x + (_nativeScrollbarIsOverlaid.x ? 0 : 3)) * 3,
                        y: (_nativeScrollbarSize.y + (_nativeScrollbarIsOverlaid.y ? 0 : 3)) * 3
                    };

                    changedOptions = changedOptions || {};
                    //freezeResizeObserver(_sizeObserverElement, true);
                    //freezeResizeObserver(_sizeAutoObserverElement, true);

                    var checkCacheAutoForce = function () {
                        return checkCache.apply(this, [].slice.call(arguments).concat([force]));
                    };

                    //save current scroll offset
                    var currScroll = {
                        x: _viewportElement[_strScrollLeft](),
                        y: _viewportElement[_strScrollTop]()
                    };

                    var currentPreparedOptionsScrollbars = _currentPreparedOptions.scrollbars;
                    var currentPreparedOptionsTextarea = _currentPreparedOptions.textarea;

                    //scrollbars visibility:
                    var scrollbarsVisibility = currentPreparedOptionsScrollbars.visibility;
                    var scrollbarsVisibilityChanged = checkCacheAutoForce(scrollbarsVisibility, _scrollbarsVisibilityCache);

                    //scrollbars autoHide:
                    var scrollbarsAutoHide = currentPreparedOptionsScrollbars.autoHide;
                    var scrollbarsAutoHideChanged = checkCacheAutoForce(scrollbarsAutoHide, _scrollbarsAutoHideCache);

                    //scrollbars click scrolling
                    var scrollbarsClickScrolling = currentPreparedOptionsScrollbars.clickScrolling;
                    var scrollbarsClickScrollingChanged = checkCacheAutoForce(scrollbarsClickScrolling, _scrollbarsClickScrollingCache);

                    //scrollbars drag scrolling
                    var scrollbarsDragScrolling = currentPreparedOptionsScrollbars.dragScrolling;
                    var scrollbarsDragScrollingChanged = checkCacheAutoForce(scrollbarsDragScrolling, _scrollbarsDragScrollingCache);

                    //className
                    var className = _currentPreparedOptions.className;
                    var classNameChanged = checkCacheAutoForce(className, _classNameCache);

                    //resize
                    var resize = _currentPreparedOptions.resize;
                    var resizeChanged = checkCacheAutoForce(resize, _resizeCache) && !_isBody; //body can't be resized since the window itself acts as resize possibility.

                    //paddingAbsolute
                    var paddingAbsolute = _currentPreparedOptions.paddingAbsolute;
                    var paddingAbsoluteChanged = checkCacheAutoForce(paddingAbsolute, _paddingAbsoluteCache);

                    //clipAlways
                    var clipAlways = _currentPreparedOptions.clipAlways;
                    var clipAlwaysChanged = checkCacheAutoForce(clipAlways, _clipAlwaysCache);

                    //sizeAutoCapable
                    var sizeAutoCapable = _currentPreparedOptions.sizeAutoCapable && !_isBody; //body can never be size auto, because it shall be always as big as the viewport.
                    var sizeAutoCapableChanged = checkCacheAutoForce(sizeAutoCapable, _sizeAutoCapableCache);

                    //showNativeScrollbars
                    var ignoreOverlayScrollbarHiding = _currentPreparedOptions.nativeScrollbarsOverlaid.showNativeScrollbars;
                    var ignoreOverlayScrollbarHidingChanged = checkCacheAutoForce(ignoreOverlayScrollbarHiding, _ignoreOverlayScrollbarHidingCache);

                    //autoUpdate
                    var autoUpdate = _currentPreparedOptions.autoUpdate;
                    var autoUpdateChanged = checkCacheAutoForce(autoUpdate, _autoUpdateCache);

                    //overflowBehavior
                    var overflowBehavior = _currentPreparedOptions.overflowBehavior;
                    var overflowBehaviorChanged = checkCacheAutoForce(overflowBehavior, _overflowBehaviorCache, force);

                    //dynWidth:
                    var textareaDynWidth = currentPreparedOptionsTextarea.dynWidth;
                    var textareaDynWidthChanged = checkCacheAutoForce(_textareaDynWidthCache, textareaDynWidth);

                    //dynHeight:
                    var textareaDynHeight = currentPreparedOptionsTextarea.dynHeight;
                    var textareaDynHeightChanged = checkCacheAutoForce(_textareaDynHeightCache, textareaDynHeight);

                    //scrollbars visibility
                    _scrollbarsAutoHideNever = scrollbarsAutoHide === 'n';
                    _scrollbarsAutoHideScroll = scrollbarsAutoHide === 's';
                    _scrollbarsAutoHideMove = scrollbarsAutoHide === 'm';
                    _scrollbarsAutoHideLeave = scrollbarsAutoHide === 'l';

                    //scrollbars autoHideDelay
                    _scrollbarsAutoHideDelay = currentPreparedOptionsScrollbars.autoHideDelay;

                    //old className
                    _oldClassName = _classNameCache;

                    //resize
                    _resizeNone = resize === 'n';
                    _resizeBoth = resize === 'b';
                    _resizeHorizontal = resize === 'h';
                    _resizeVertical = resize === 'v';

                    //normalizeRTL
                    _normalizeRTLCache = _currentPreparedOptions.normalizeRTL;

                    //ignore overlay scrollbar hiding
                    ignoreOverlayScrollbarHiding = ignoreOverlayScrollbarHiding && (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y);

                    //refresh options cache
                    _scrollbarsVisibilityCache = scrollbarsVisibility;
                    _scrollbarsAutoHideCache = scrollbarsAutoHide;
                    _scrollbarsClickScrollingCache = scrollbarsClickScrolling;
                    _scrollbarsDragScrollingCache = scrollbarsDragScrolling;
                    _classNameCache = className;
                    _resizeCache = resize;
                    _paddingAbsoluteCache = paddingAbsolute;
                    _clipAlwaysCache = clipAlways;
                    _sizeAutoCapableCache = sizeAutoCapable;
                    _ignoreOverlayScrollbarHidingCache = ignoreOverlayScrollbarHiding;
                    _autoUpdateCache = autoUpdate;
                    _overflowBehaviorCache = extendDeep({}, overflowBehavior);
                    _textareaDynWidthCache = textareaDynWidth;
                    _textareaDynHeightCache = textareaDynHeight;
                    _hasOverflowCache = _hasOverflowCache || { x: false, y: false };

                    //set correct class name to the host element
                    if (classNameChanged) {
                        removeClass(_hostElement, _oldClassName + _strSpace + _classNameThemeNone);
                        addClass(_hostElement, className !== undefined && className !== null && className.length > 0 ? className : _classNameThemeNone);
                    }

                    //set correct auto Update
                    if (autoUpdateChanged) {
                        if (autoUpdate === true || (autoUpdate === null && _autoUpdateRecommended)) {
                            disconnectMutationObservers();
                            autoUpdateLoop.add(_base);
                        }
                        else {
                            autoUpdateLoop.remove(_base);
                            connectMutationObservers();
                        }
                    }

                    //activate or deactivate size auto capability
                    if (sizeAutoCapableChanged) {
                        if (sizeAutoCapable) {
                            if (_contentGlueElement) {
                                _contentGlueElement.show();
                            }
                            else {
                                _contentGlueElement = FRAMEWORK(generateDiv(_classNameContentGlueElement));
                                _paddingElement.before(_contentGlueElement);
                            }
                            if (_sizeAutoObserverAdded) {
                                _sizeAutoObserverElement.show();
                            }
                            else {
                                _sizeAutoObserverElement = FRAMEWORK(generateDiv(_classNameSizeAutoObserverElement));
                                _sizeAutoObserverElementNative = _sizeAutoObserverElement[0];

                                _contentGlueElement.before(_sizeAutoObserverElement);
                                var oldSize = { w: -1, h: -1 };
                                setupResizeObserver(_sizeAutoObserverElement, function () {
                                    var newSize = {
                                        w: _sizeAutoObserverElementNative[LEXICON.oW],
                                        h: _sizeAutoObserverElementNative[LEXICON.oH]
                                    };
                                    if (checkCache(newSize, oldSize)) {
                                        if (_initialized && (_heightAutoCache && newSize.h > 0) || (_widthAutoCache && newSize.w > 0)) {
                                            update();
                                        }
                                        else if (_initialized && (!_heightAutoCache && newSize.h === 0) || (!_widthAutoCache && newSize.w === 0)) {
                                            update();
                                        }
                                    }
                                    oldSize = newSize;
                                });
                                _sizeAutoObserverAdded = true;
                                //fix heightAuto detector bug if height is fixed but contentHeight is 0.
                                //the probability this bug will ever happen is very very low, thats why its ok if we use calc which isn't supported in IE8.
                                if (_cssCalc !== null)
                                    _sizeAutoObserverElement.css(_strHeight, _cssCalc + '(100% + 1px)');
                            }
                        }
                        else {
                            if (_sizeAutoObserverAdded)
                                _sizeAutoObserverElement.hide();
                            if (_contentGlueElement)
                                _contentGlueElement.hide();
                        }
                    }

                    //if force, update all resizeObservers too
                    if (force) {
                        _sizeObserverElement.find('*').trigger(_strScroll);
                        if (_sizeAutoObserverAdded)
                            _sizeAutoObserverElement.find('*').trigger(_strScroll);
                    }

                    //display hidden:
                    displayIsHidden = displayIsHidden === undefined ? _hostElement.is(':hidden') : displayIsHidden;

                    //textarea AutoWrapping:
                    var textareaAutoWrapping = _isTextarea ? _targetElement.attr('wrap') !== 'off' : false;
                    var textareaAutoWrappingChanged = checkCacheAutoForce(textareaAutoWrapping, _textareaAutoWrappingCache);

                    //detect direction:
                    var cssDirection = _hostElement.css('direction');
                    var cssDirectionChanged = checkCacheAutoForce(cssDirection, _cssDirectionCache);

                    //detect box-sizing:
                    var boxSizing = _hostElement.css('box-sizing');
                    var boxSizingChanged = checkCacheAutoForce(boxSizing, _cssBoxSizingCache);

                    //detect padding:
                    var padding = getTopRightBottomLeftHost(_strPaddingMinus);

                    //width + height auto detecting var:
                    var sizeAutoObserverElementBCRect;
                    //exception occurs in IE8 sometimes (unknown exception)
                    try {
                        sizeAutoObserverElementBCRect = _sizeAutoObserverAdded ? _sizeAutoObserverElementNative[LEXICON.bCR]() : null;
                    } catch (ex) {
                        return;
                    }

                    _isRTL = cssDirection === 'rtl';
                    _isBorderBox = (boxSizing === 'border-box');
                    var isRTLLeft = _isRTL ? _strLeft : _strRight;
                    var isRTLRight = _isRTL ? _strRight : _strLeft;

                    //detect width auto:
                    var widthAutoResizeDetection = false;
                    var widthAutoObserverDetection = (_sizeAutoObserverAdded && (_hostElement.css(_strFloat) !== 'none' /*|| _isTextarea */)) ? (MATH.round(sizeAutoObserverElementBCRect.right - sizeAutoObserverElementBCRect.left) === 0) && (!paddingAbsolute ? (_hostElementNative[LEXICON.cW] - _paddingX) > 0 : true) : false;
                    if (sizeAutoCapable && !widthAutoObserverDetection) {
                        var tmpCurrHostWidth = _hostElementNative[LEXICON.oW];
                        var tmpCurrContentGlueWidth = _contentGlueElement.css(_strWidth);
                        _contentGlueElement.css(_strWidth, _strAuto);

                        var tmpNewHostWidth = _hostElementNative[LEXICON.oW];
                        _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);
                        widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;
                        if (!widthAutoResizeDetection) {
                            _contentGlueElement.css(_strWidth, tmpCurrHostWidth + 1);
                            tmpNewHostWidth = _hostElementNative[LEXICON.oW];
                            _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);
                            widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;
                        }
                    }
                    var widthAuto = (widthAutoObserverDetection || widthAutoResizeDetection) && sizeAutoCapable && !displayIsHidden;
                    var widthAutoChanged = checkCacheAutoForce(widthAuto, _widthAutoCache);
                    var wasWidthAuto = !widthAuto && _widthAutoCache;

                    //detect height auto:
                    var heightAuto = _sizeAutoObserverAdded && sizeAutoCapable && !displayIsHidden ? (MATH.round(sizeAutoObserverElementBCRect.bottom - sizeAutoObserverElementBCRect.top) === 0) /* && (!paddingAbsolute && (_msieVersion > 9 || !_msieVersion) ? true : true) */ : false;
                    var heightAutoChanged = checkCacheAutoForce(heightAuto, _heightAutoCache);
                    var wasHeightAuto = !heightAuto && _heightAutoCache;

                    //detect border:
                    //we need the border only if border box and auto size
                    var updateBorderX = (widthAuto && _isBorderBox) || !_isBorderBox;
                    var updateBorderY = (heightAuto && _isBorderBox) || !_isBorderBox;
                    var border = getTopRightBottomLeftHost(_strBorderMinus, '-' + _strWidth, !updateBorderX, !updateBorderY)

                    //detect margin:
                    var margin = getTopRightBottomLeftHost(_strMarginMinus);

                    //vars to apply correct css
                    var contentElementCSS = {};
                    var contentGlueElementCSS = {};

                    //funcs
                    var getHostSize = function () {
                        //has to be clientSize because offsetSize respect borders
                        return {
                            w: _hostElementNative[LEXICON.cW],
                            h: _hostElementNative[LEXICON.cH]
                        };
                    };
                    var getViewportSize = function () {
                        //viewport size is padding container because it never has padding, margin and a border
                        //determine zoom rounding error -> sometimes scrollWidth/Height is smaller than clientWidth/Height
                        //if this happens add the difference to the viewportSize to compensate the rounding error
                        return {
                            w: _paddingElementNative[LEXICON.oW] + MATH.max(0, _contentElementNative[LEXICON.cW] - _contentElementNative[LEXICON.sW]),
                            h: _paddingElementNative[LEXICON.oH] + MATH.max(0, _contentElementNative[LEXICON.cH] - _contentElementNative[LEXICON.sH])
                        };
                    };

                    //set info for padding
                    var paddingAbsoluteX = _paddingX = padding.l + padding.r;
                    var paddingAbsoluteY = _paddingY = padding.t + padding.b;
                    paddingAbsoluteX *= paddingAbsolute ? 1 : 0;
                    paddingAbsoluteY *= paddingAbsolute ? 1 : 0;
                    padding.c = checkCacheAutoForce(padding, _cssPaddingCache);

                    //set info for border
                    _borderX = border.l + border.r;
                    _borderY = border.t + border.b;
                    border.c = checkCacheAutoForce(border, _cssBorderCache);

                    //set info for margin
                    _marginX = margin.l + margin.r;
                    _marginY = margin.t + margin.b;
                    margin.c = checkCacheAutoForce(margin, _cssMarginCache);

                    //refresh cache
                    _textareaAutoWrappingCache = textareaAutoWrapping;
                    _cssDirectionCache = cssDirection;
                    _cssBoxSizingCache = boxSizing;
                    _widthAutoCache = widthAuto;
                    _heightAutoCache = heightAuto;
                    _cssPaddingCache = padding;
                    _cssBorderCache = border;
                    _cssMarginCache = margin;

                    //IEFix direction changed
                    if (cssDirectionChanged && _sizeAutoObserverAdded)
                        _sizeAutoObserverElement.css(_strFloat, isRTLRight);

                    //apply padding:
                    if (padding.c || cssDirectionChanged || paddingAbsoluteChanged || widthAutoChanged || heightAutoChanged || boxSizingChanged || sizeAutoCapableChanged) {
                        var paddingElementCSS = {};
                        var textareaCSS = {};
                        var paddingValues = [padding.t, padding.r, padding.b, padding.l];

                        setTopRightBottomLeft(contentGlueElementCSS, _strMarginMinus, [-padding.t, -padding.r, -padding.b, -padding.l]);
                        if (paddingAbsolute) {
                            setTopRightBottomLeft(paddingElementCSS, _strEmpty, paddingValues);
                            setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus);
                        }
                        else {
                            setTopRightBottomLeft(paddingElementCSS, _strEmpty);
                            setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus, paddingValues);
                        }

                        _paddingElement.css(paddingElementCSS);
                        _targetElement.css(textareaCSS);
                    }

                    //viewport size is padding container because it never has padding, margin and a border.
                    _viewportSize = getViewportSize();

                    //update Textarea
                    var textareaSize = _isTextarea ? textareaUpdate() : false;
                    var textareaSizeChanged = _isTextarea && checkCacheAutoForce(textareaSize, _textareaSizeCache);
                    var textareaDynOrigSize = _isTextarea && textareaSize ? {
                        w: textareaDynWidth ? textareaSize._dynamicWidth : textareaSize._originalWidth,
                        h: textareaDynHeight ? textareaSize._dynamicHeight : textareaSize._originalHeight
                    } : {};
                    _textareaSizeCache = textareaSize;

                    //fix height auto / width auto in cooperation with current padding & boxSizing behavior:
                    if (heightAuto && (heightAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c)) {
                        contentElementCSS[_strHeight] = _strAuto;
                    }
                    else if (heightAutoChanged || paddingAbsoluteChanged) {
                        contentElementCSS[_strHeight] = _strHundredPercent;
                    }
                    if (widthAuto && (widthAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c || cssDirectionChanged)) {
                        contentElementCSS[_strWidth] = _strAuto;
                        contentGlueElementCSS[_strMaxMinus + _strWidth] = _strHundredPercent; //IE Fix
                    }
                    else if (widthAutoChanged || paddingAbsoluteChanged) {
                        contentElementCSS[_strWidth] = _strHundredPercent;
                        contentElementCSS[_strFloat] = _strEmpty;
                        contentGlueElementCSS[_strMaxMinus + _strWidth] = _strEmpty; //IE Fix
                    }
                    if (widthAuto) {
                        //textareaDynOrigSize.w || _strAuto :: doesnt works because applied margin will shift width
                        contentGlueElementCSS[_strWidth] = _strAuto;

                        contentElementCSS[_strWidth] = VENDORS._cssPropertyValue(_strWidth, 'max-content intrinsic') || _strAuto;
                        contentElementCSS[_strFloat] = isRTLRight;
                    }
                    else {
                        contentGlueElementCSS[_strWidth] = _strEmpty;
                    }
                    if (heightAuto) {
                        //textareaDynOrigSize.h || _contentElementNative[LEXICON.cH] :: use for anti scroll jumping
                        contentGlueElementCSS[_strHeight] = textareaDynOrigSize.h || _contentElementNative[LEXICON.cH];
                    }
                    else {
                        contentGlueElementCSS[_strHeight] = _strEmpty;
                    }
                    if (sizeAutoCapable)
                        _contentGlueElement.css(contentGlueElementCSS);
                    _contentElement.css(contentElementCSS);

                    //CHECKPOINT HERE ~
                    contentElementCSS = {};
                    contentGlueElementCSS = {};

                    //if [content(host) client / scroll size, or target element direction, or content(host) max-sizes] changed, or force is true
                    if (hostSizeChanged || contentSizeChanged || textareaSizeChanged || cssDirectionChanged || boxSizingChanged || paddingAbsoluteChanged || widthAutoChanged || widthAuto || heightAutoChanged || heightAuto || ignoreOverlayScrollbarHidingChanged || overflowBehaviorChanged || clipAlwaysChanged || resizeChanged || scrollbarsVisibilityChanged || scrollbarsAutoHideChanged || scrollbarsDragScrollingChanged || scrollbarsClickScrollingChanged || textareaDynWidthChanged || textareaDynHeightChanged || textareaAutoWrappingChanged) {
                        var strOverflow = 'overflow';
                        var strOverflowX = strOverflow + '-x';
                        var strOverflowY = strOverflow + '-y';
                        var strHidden = 'hidden';
                        var strVisible = 'visible';

                        //Reset the viewport (very important for natively overlaid scrollbars and zoom change
                        //don't change the overflow prop as it is very expensive and affects performance !A LOT!
                        if (!_nativeScrollbarStyling) {
                            var viewportElementResetCSS = {};
                            var resetXTmp = _hasOverflowCache.y && _hideOverflowCache.ys && !ignoreOverlayScrollbarHiding ? (_nativeScrollbarIsOverlaid.y ? _viewportElement.css(isRTLLeft) : -_nativeScrollbarSize.y) : 0;
                            var resetBottomTmp = _hasOverflowCache.x && _hideOverflowCache.xs && !ignoreOverlayScrollbarHiding ? (_nativeScrollbarIsOverlaid.x ? _viewportElement.css(_strBottom) : -_nativeScrollbarSize.x) : 0;
                            setTopRightBottomLeft(viewportElementResetCSS, _strEmpty);
                            _viewportElement.css(viewportElementResetCSS);
                        }

                        //measure several sizes:
                        var contentMeasureElement = getContentMeasureElement();
                        //in Firefox content element has to have overflow hidden, else element margins aren't calculated properly, this element prevents this bug, but only if scrollbars aren't overlaid
                        var contentSize = {
                            //use clientSize because natively overlaidScrollbars add borders
                            w: textareaDynOrigSize.w || contentMeasureElement[LEXICON.cW],
                            h: textareaDynOrigSize.h || contentMeasureElement[LEXICON.cH]
                        };
                        var scrollSize = {
                            w: contentMeasureElement[LEXICON.sW],
                            h: contentMeasureElement[LEXICON.sH]
                        };

                        //apply the correct viewport style and measure viewport size
                        if (!_nativeScrollbarStyling) {
                            viewportElementResetCSS[_strBottom] = wasHeightAuto ? _strEmpty : resetBottomTmp;
                            viewportElementResetCSS[isRTLLeft] = wasWidthAuto ? _strEmpty : resetXTmp;
                            _viewportElement.css(viewportElementResetCSS);
                        }
                        _viewportSize = getViewportSize();

                        //measure and correct several sizes
                        var hostSize = getHostSize();
                        var hostAbsoluteRectSize = {
                            w: hostSize.w - _marginX - _borderX - (_isBorderBox ? 0 : _paddingX),
                            h: hostSize.h - _marginY - _borderY - (_isBorderBox ? 0 : _paddingY)
                        };
                        var contentGlueSize = {
                            //client/scrollSize + AbsolutePadding -> because padding is only applied to the paddingElement if its absolute, so you have to add it manually
                            //hostSize is clientSize -> so padding should be added manually, right? FALSE! Because content glue is inside hostElement, so we don't have to worry about padding
                            w: MATH.max((widthAuto ? contentSize.w : scrollSize.w) + paddingAbsoluteX, hostAbsoluteRectSize.w),
                            h: MATH.max((heightAuto ? contentSize.h : scrollSize.h) + paddingAbsoluteY, hostAbsoluteRectSize.h)
                        };
                        contentGlueSize.c = checkCacheAutoForce(contentGlueSize, _contentGlueSizeCache);
                        _contentGlueSizeCache = contentGlueSize;

                        //apply correct contentGlue size
                        if (sizeAutoCapable) {
                            //size contentGlue correctly to make sure the element has correct size if the sizing switches to auto
                            if (contentGlueSize.c || (heightAuto || widthAuto)) {
                                contentGlueElementCSS[_strWidth] = contentGlueSize.w;
                                contentGlueElementCSS[_strHeight] = contentGlueSize.h;

                                //textarea-sizes are already calculated correctly at this point
                                if (!_isTextarea) {
                                    contentSize = {
                                        //use clientSize because natively overlaidScrollbars add borders
                                        w: contentMeasureElement[LEXICON.cW],
                                        h: contentMeasureElement[LEXICON.cH]
                                    };
                                }
                            }
                            var textareaCoverCSS = {};
                            var setContentGlueElementCSSfunction = function (horizontal) {
                                var scrollbarVars = getScrollbarVars(horizontal);
                                var wh = scrollbarVars._w_h;
                                var strWH = scrollbarVars._width_height;
                                var autoSize = horizontal ? widthAuto : heightAuto;
                                var borderSize = horizontal ? _borderX : _borderY;
                                var paddingSize = horizontal ? _paddingX : _paddingY;
                                var marginSize = horizontal ? _marginX : _marginY;
                                var viewportSize = _viewportSize[wh] - borderSize - marginSize - (_isBorderBox ? 0 : paddingSize);

                                //make contentGlue size -1 if element is not auto sized, to make sure that a resize event happens when the element shrinks
                                if (!autoSize || (!autoSize && border.c))
                                    contentGlueElementCSS[strWH] = hostAbsoluteRectSize[wh] - 1;

                                //if size is auto and host is smaller than size as min size, make content glue size -1 to make sure size changes will be detected (this is only needed if padding is 0)
                                if (autoSize && (contentSize[wh] < viewportSize) && (horizontal && _isTextarea ? !textareaAutoWrapping : true)) {
                                    if (_isTextarea)
                                        textareaCoverCSS[strWH] = parseToZeroOrNumber(_textareaCoverElement.css(strWH)) - 1;
                                    contentGlueElementCSS[strWH] -= 1;
                                }

                                //make sure content glue size is at least 1
                                if (contentSize[wh] > 0)
                                    contentGlueElementCSS[strWH] = MATH.max(1, contentGlueElementCSS[strWH]);
                            };
                            setContentGlueElementCSSfunction(true);
                            setContentGlueElementCSSfunction(false);

                            if (_isTextarea)
                                _textareaCoverElement.css(textareaCoverCSS);
                            _contentGlueElement.css(contentGlueElementCSS);
                        }
                        if (widthAuto)
                            contentElementCSS[_strWidth] = _strHundredPercent;
                        if (widthAuto && !_isBorderBox && !_mutationObserversConnected)
                            contentElementCSS[_strFloat] = 'none';

                        //apply and reset content style
                        _contentElement.css(contentElementCSS);
                        contentElementCSS = {};

                        //measure again, but this time all correct sizes:
                        var contentScrollSize = {
                            w: contentMeasureElement[LEXICON.sW],
                            h: contentMeasureElement[LEXICON.sH],
                        };
                        contentScrollSize.c = contentSizeChanged = checkCacheAutoForce(contentScrollSize, _contentScrollSizeCache);
                        _contentScrollSizeCache = contentScrollSize;

                        //refresh viewport size after correct measuring
                        _viewportSize = getViewportSize();

                        hostSize = getHostSize();
                        hostSizeChanged = checkCacheAutoForce(hostSize, _hostSizeCache);
                        _hostSizeCache = hostSize;

                        var hideOverflowForceTextarea = _isTextarea && (_viewportSize.w === 0 || _viewportSize.h === 0);
                        var previousOverflowAmount = _overflowAmountCache;
                        var overflowBehaviorIsVS = {};
                        var overflowBehaviorIsVH = {};
                        var overflowBehaviorIsS = {};
                        var overflowAmount = {};
                        var hasOverflow = {};
                        var hideOverflow = {};
                        var canScroll = {};
                        var viewportRect = _paddingElementNative[LEXICON.bCR]();
                        var setOverflowVariables = function (horizontal) {
                            var scrollbarVars = getScrollbarVars(horizontal);
                            var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                            var xyI = scrollbarVarsInverted._x_y;
                            var xy = scrollbarVars._x_y;
                            var wh = scrollbarVars._w_h;
                            var widthHeight = scrollbarVars._width_height;
                            var scrollMax = _strScroll + scrollbarVars._Left_Top + 'Max';
                            var fractionalOverflowAmount = viewportRect[widthHeight] ? MATH.abs(viewportRect[widthHeight] - _viewportSize[wh]) : 0;
                            var checkFractionalOverflowAmount = previousOverflowAmount && previousOverflowAmount[xy] > 0 && _viewportElementNative[scrollMax] === 0;
                            overflowBehaviorIsVS[xy] = overflowBehavior[xy] === 'v-s';
                            overflowBehaviorIsVH[xy] = overflowBehavior[xy] === 'v-h';
                            overflowBehaviorIsS[xy] = overflowBehavior[xy] === 's';
                            overflowAmount[xy] = MATH.max(0, MATH.round((contentScrollSize[wh] - _viewportSize[wh]) * 100) / 100);
                            overflowAmount[xy] *= (hideOverflowForceTextarea || (checkFractionalOverflowAmount && fractionalOverflowAmount > 0 && fractionalOverflowAmount < 1)) ? 0 : 1;
                            hasOverflow[xy] = overflowAmount[xy] > 0;

                            //hideOverflow:
                            //x || y : true === overflow is hidden by "overflow: scroll" OR "overflow: hidden"
                            //xs || ys : true === overflow is hidden by "overflow: scroll"
                            hideOverflow[xy] = overflowBehaviorIsVS[xy] || overflowBehaviorIsVH[xy] ? (hasOverflow[xyI] && !overflowBehaviorIsVS[xyI] && !overflowBehaviorIsVH[xyI]) : hasOverflow[xy];
                            hideOverflow[xy + 's'] = hideOverflow[xy] ? (overflowBehaviorIsS[xy] || overflowBehaviorIsVS[xy]) : false;

                            canScroll[xy] = hasOverflow[xy] && hideOverflow[xy + 's'];
                        };
                        setOverflowVariables(true);
                        setOverflowVariables(false);

                        overflowAmount.c = checkCacheAutoForce(overflowAmount, _overflowAmountCache);
                        _overflowAmountCache = overflowAmount;
                        hasOverflow.c = checkCacheAutoForce(hasOverflow, _hasOverflowCache);
                        _hasOverflowCache = hasOverflow;
                        hideOverflow.c = checkCacheAutoForce(hideOverflow, _hideOverflowCache);
                        _hideOverflowCache = hideOverflow;

                        //if native scrollbar is overlay at x OR y axis, prepare DOM
                        if (_nativeScrollbarIsOverlaid.x || _nativeScrollbarIsOverlaid.y) {
                            var borderDesign = 'px solid transparent';
                            var contentArrangeElementCSS = {};
                            var arrangeContent = {};
                            var arrangeChanged = force;
                            var setContentElementCSS;

                            if (hasOverflow.x || hasOverflow.y) {
                                arrangeContent.w = _nativeScrollbarIsOverlaid.y && hasOverflow.y ? contentScrollSize.w + _overlayScrollbarDummySize.y : _strEmpty;
                                arrangeContent.h = _nativeScrollbarIsOverlaid.x && hasOverflow.x ? contentScrollSize.h + _overlayScrollbarDummySize.x : _strEmpty;
                                arrangeChanged = checkCacheAutoForce(arrangeContent, _arrangeContentSizeCache);
                                _arrangeContentSizeCache = arrangeContent;
                            }

                            if (hasOverflow.c || hideOverflow.c || contentScrollSize.c || cssDirectionChanged || widthAutoChanged || heightAutoChanged || widthAuto || heightAuto || ignoreOverlayScrollbarHidingChanged) {
                                contentElementCSS[_strMarginMinus + isRTLRight] = contentElementCSS[_strBorderMinus + isRTLRight] = _strEmpty;
                                setContentElementCSS = function (horizontal) {
                                    var scrollbarVars = getScrollbarVars(horizontal);
                                    var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                                    var xy = scrollbarVars._x_y;
                                    var strDirection = horizontal ? _strBottom : isRTLLeft;
                                    var invertedAutoSize = horizontal ? heightAuto : widthAuto;

                                    if (_nativeScrollbarIsOverlaid[xy] && hasOverflow[xy] && hideOverflow[xy + 's']) {
                                        contentElementCSS[_strMarginMinus + strDirection] = invertedAutoSize ? (ignoreOverlayScrollbarHiding ? _strEmpty : _overlayScrollbarDummySize[xy]) : _strEmpty;
                                        contentElementCSS[_strBorderMinus + strDirection] = ((horizontal ? !invertedAutoSize : true) && !ignoreOverlayScrollbarHiding) ? (_overlayScrollbarDummySize[xy] + borderDesign) : _strEmpty;
                                    }
                                    else {
                                        arrangeContent[scrollbarVarsInverted._w_h] =
                                            contentElementCSS[_strMarginMinus + strDirection] =
                                            contentElementCSS[_strBorderMinus + strDirection] = _strEmpty;
                                        arrangeChanged = true;
                                    }
                                };

                                if (_nativeScrollbarStyling) {
                                    addRemoveClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible, !ignoreOverlayScrollbarHiding)
                                }
                                else {
                                    setContentElementCSS(true);
                                    setContentElementCSS(false);
                                }
                            }
                            if (ignoreOverlayScrollbarHiding) {
                                arrangeContent.w = arrangeContent.h = _strEmpty;
                                arrangeChanged = true;
                            }
                            if (arrangeChanged && !_nativeScrollbarStyling) {
                                contentArrangeElementCSS[_strWidth] = hideOverflow.y ? arrangeContent.w : _strEmpty;
                                contentArrangeElementCSS[_strHeight] = hideOverflow.x ? arrangeContent.h : _strEmpty;

                                if (!_contentArrangeElement) {
                                    _contentArrangeElement = FRAMEWORK(generateDiv(_classNameContentArrangeElement));
                                    _viewportElement.prepend(_contentArrangeElement);
                                }
                                _contentArrangeElement.css(contentArrangeElementCSS);
                            }
                            _contentElement.css(contentElementCSS);
                        }

                        var viewportElementCSS = {};
                        var paddingElementCSS = {};
                        var setViewportCSS;
                        if (hostSizeChanged || hasOverflow.c || hideOverflow.c || contentScrollSize.c || overflowBehaviorChanged || boxSizingChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged || clipAlwaysChanged || heightAutoChanged) {
                            viewportElementCSS[isRTLRight] = _strEmpty;
                            setViewportCSS = function (horizontal) {
                                var scrollbarVars = getScrollbarVars(horizontal);
                                var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                                var xy = scrollbarVars._x_y;
                                var XY = scrollbarVars._X_Y;
                                var strDirection = horizontal ? _strBottom : isRTLLeft;

                                var reset = function () {
                                    viewportElementCSS[strDirection] = _strEmpty;
                                    _contentBorderSize[scrollbarVarsInverted._w_h] = 0;
                                };
                                if (hasOverflow[xy] && hideOverflow[xy + 's']) {
                                    viewportElementCSS[strOverflow + XY] = _strScroll;
                                    if (ignoreOverlayScrollbarHiding || _nativeScrollbarStyling) {
                                        reset();
                                    }
                                    else {
                                        viewportElementCSS[strDirection] = -(_nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[xy] : _nativeScrollbarSize[xy]);
                                        _contentBorderSize[scrollbarVarsInverted._w_h] = _nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[scrollbarVarsInverted._x_y] : 0;
                                    }
                                } else {
                                    viewportElementCSS[strOverflow + XY] = _strEmpty;
                                    reset();
                                }
                            };
                            setViewportCSS(true);
                            setViewportCSS(false);

                            // if the scroll container is too small and if there is any overflow with no overlay scrollbar (and scrollbar styling isn't possible), 
                            // make viewport element greater in size (Firefox hide Scrollbars fix)
                            // because firefox starts hiding scrollbars on too small elements
                            // with this behavior the overflow calculation may be incorrect or the scrollbars would appear suddenly
                            // https://bugzilla.mozilla.org/show_bug.cgi?id=292284
                            if (!_nativeScrollbarStyling
                                && (_viewportSize.h < _nativeScrollbarMinSize.x || _viewportSize.w < _nativeScrollbarMinSize.y)
                                && ((hasOverflow.x && hideOverflow.x && !_nativeScrollbarIsOverlaid.x) || (hasOverflow.y && hideOverflow.y && !_nativeScrollbarIsOverlaid.y))) {
                                viewportElementCSS[_strPaddingMinus + _strTop] = _nativeScrollbarMinSize.x;
                                viewportElementCSS[_strMarginMinus + _strTop] = -_nativeScrollbarMinSize.x;

                                viewportElementCSS[_strPaddingMinus + isRTLRight] = _nativeScrollbarMinSize.y;
                                viewportElementCSS[_strMarginMinus + isRTLRight] = -_nativeScrollbarMinSize.y;
                            }
                            else {
                                viewportElementCSS[_strPaddingMinus + _strTop] =
                                    viewportElementCSS[_strMarginMinus + _strTop] =
                                    viewportElementCSS[_strPaddingMinus + isRTLRight] =
                                    viewportElementCSS[_strMarginMinus + isRTLRight] = _strEmpty;
                            }
                            viewportElementCSS[_strPaddingMinus + isRTLLeft] =
                                viewportElementCSS[_strMarginMinus + isRTLLeft] = _strEmpty;

                            //if there is any overflow (x OR y axis) and this overflow shall be hidden, make overflow hidden, else overflow visible
                            if ((hasOverflow.x && hideOverflow.x) || (hasOverflow.y && hideOverflow.y) || hideOverflowForceTextarea) {
                                //only hide if is Textarea
                                if (_isTextarea && hideOverflowForceTextarea) {
                                    paddingElementCSS[strOverflowX] =
                                        paddingElementCSS[strOverflowY] = strHidden;
                                }
                            }
                            else {
                                if (!clipAlways || (overflowBehaviorIsVH.x || overflowBehaviorIsVS.x || overflowBehaviorIsVH.y || overflowBehaviorIsVS.y)) {
                                    //only un-hide if Textarea
                                    if (_isTextarea) {
                                        paddingElementCSS[strOverflowX] =
                                            paddingElementCSS[strOverflowY] = _strEmpty;
                                    }
                                    viewportElementCSS[strOverflowX] =
                                        viewportElementCSS[strOverflowY] = strVisible;
                                }
                            }

                            _paddingElement.css(paddingElementCSS);
                            _viewportElement.css(viewportElementCSS);
                            viewportElementCSS = {};

                            //force soft redraw in webkit because without the scrollbars will may appear because DOM wont be redrawn under special conditions
                            if ((hasOverflow.c || boxSizingChanged || widthAutoChanged || heightAutoChanged) && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {
                                var elementStyle = _contentElementNative[LEXICON.s];
                                var dump;
                                elementStyle.webkitTransform = 'scale(1)';
                                elementStyle.display = 'run-in';
                                dump = _contentElementNative[LEXICON.oH];
                                elementStyle.display = _strEmpty; //|| dump; //use dump to prevent it from deletion if minify
                                elementStyle.webkitTransform = _strEmpty;
                            }
                            /*
                            //force hard redraw in webkit if native overlaid scrollbars shall appear
                            if (ignoreOverlayScrollbarHidingChanged && ignoreOverlayScrollbarHiding) {
                                _hostElement.hide();
                                var dump = _hostElementNative[LEXICON.oH];
                                _hostElement.show();
                            }
                            */
                        }

                        //change to direction RTL and width auto Bugfix in Webkit
                        //without this fix, the DOM still thinks the scrollbar is LTR and thus the content is shifted to the left
                        contentElementCSS = {};
                        if (cssDirectionChanged || widthAutoChanged || heightAutoChanged) {
                            if (_isRTL && widthAuto) {
                                var floatTmp = _contentElement.css(_strFloat);
                                var posLeftWithoutFloat = MATH.round(_contentElement.css(_strFloat, _strEmpty).css(_strLeft, _strEmpty).position().left);
                                _contentElement.css(_strFloat, floatTmp);
                                var posLeftWithFloat = MATH.round(_contentElement.position().left);

                                if (posLeftWithoutFloat !== posLeftWithFloat)
                                    contentElementCSS[_strLeft] = posLeftWithoutFloat;
                            }
                            else {
                                contentElementCSS[_strLeft] = _strEmpty;
                            }
                        }
                        _contentElement.css(contentElementCSS);

                        //handle scroll position
                        if (_isTextarea && contentSizeChanged) {
                            var textareaInfo = getTextareaInfo();
                            if (textareaInfo) {
                                var textareaRowsChanged = _textareaInfoCache === undefined ? true : textareaInfo._rows !== _textareaInfoCache._rows;
                                var cursorRow = textareaInfo._cursorRow;
                                var cursorCol = textareaInfo._cursorColumn;
                                var widestRow = textareaInfo._widestRow;
                                var lastRow = textareaInfo._rows;
                                var lastCol = textareaInfo._columns;
                                var cursorPos = textareaInfo._cursorPosition;
                                var cursorMax = textareaInfo._cursorMax;
                                var cursorIsLastPosition = (cursorPos >= cursorMax && _textareaHasFocus);
                                var textareaScrollAmount = {
                                    x: (!textareaAutoWrapping && (cursorCol === lastCol && cursorRow === widestRow)) ? _overflowAmountCache.x : -1,
                                    y: (textareaAutoWrapping ? cursorIsLastPosition || textareaRowsChanged && (previousOverflowAmount ? (currScroll.y === previousOverflowAmount.y) : false) : (cursorIsLastPosition || textareaRowsChanged) && cursorRow === lastRow) ? _overflowAmountCache.y : -1
                                };
                                currScroll.x = textareaScrollAmount.x > -1 ? (_isRTL && _normalizeRTLCache && _rtlScrollBehavior.i ? 0 : textareaScrollAmount.x) : currScroll.x; //if inverted, scroll to 0 -> normalized this means to max scroll offset.
                                currScroll.y = textareaScrollAmount.y > -1 ? textareaScrollAmount.y : currScroll.y;
                            }
                            _textareaInfoCache = textareaInfo;
                        }
                        if (_isRTL && _rtlScrollBehavior.i && _nativeScrollbarIsOverlaid.y && hasOverflow.x && _normalizeRTLCache)
                            currScroll.x += _contentBorderSize.w || 0;
                        if (widthAuto)
                            _hostElement[_strScrollLeft](0);
                        if (heightAuto)
                            _hostElement[_strScrollTop](0);
                        _viewportElement[_strScrollLeft](currScroll.x)[_strScrollTop](currScroll.y);

                        //scrollbars management:
                        var scrollbarsVisibilityVisible = scrollbarsVisibility === 'v';
                        var scrollbarsVisibilityHidden = scrollbarsVisibility === 'h';
                        var scrollbarsVisibilityAuto = scrollbarsVisibility === 'a';
                        var refreshScrollbarsVisibility = function (showX, showY) {
                            showY = showY === undefined ? showX : showY;
                            refreshScrollbarAppearance(true, showX, canScroll.x)
                            refreshScrollbarAppearance(false, showY, canScroll.y)
                        };

                        //manage class name which indicates scrollable overflow
                        addRemoveClass(_hostElement, _classNameHostOverflow, hideOverflow.x || hideOverflow.y);
                        addRemoveClass(_hostElement, _classNameHostOverflowX, hideOverflow.x);
                        addRemoveClass(_hostElement, _classNameHostOverflowY, hideOverflow.y);

                        //add or remove rtl class name for styling purposes except when its body, then the scrollbar stays
                        if (cssDirectionChanged && !_isBody) {
                            addRemoveClass(_hostElement, _classNameHostRTL, _isRTL);
                        }

                        //manage the resize feature (CSS3 resize "polyfill" for this plugin)
                        if (_isBody)
                            addClass(_hostElement, _classNameHostResizeDisabled);
                        if (resizeChanged) {
                            addRemoveClass(_hostElement, _classNameHostResizeDisabled, _resizeNone);
                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResize, !_resizeNone);
                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeB, _resizeBoth);
                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeH, _resizeHorizontal);
                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeV, _resizeVertical);
                        }

                        //manage the scrollbars general visibility + the scrollbar interactivity (unusable class name)
                        if (scrollbarsVisibilityChanged || overflowBehaviorChanged || hideOverflow.c || hasOverflow.c || ignoreOverlayScrollbarHidingChanged) {
                            if (ignoreOverlayScrollbarHiding) {
                                if (ignoreOverlayScrollbarHidingChanged) {
                                    removeClass(_hostElement, _classNameHostScrolling);
                                    if (ignoreOverlayScrollbarHiding) {
                                        refreshScrollbarsVisibility(false);
                                    }
                                }
                            }
                            else if (scrollbarsVisibilityAuto) {
                                refreshScrollbarsVisibility(canScroll.x, canScroll.y);
                            }
                            else if (scrollbarsVisibilityVisible) {
                                refreshScrollbarsVisibility(true);
                            }
                            else if (scrollbarsVisibilityHidden) {
                                refreshScrollbarsVisibility(false);
                            }
                        }

                        //manage the scrollbars auto hide feature (auto hide them after specific actions)
                        if (scrollbarsAutoHideChanged || ignoreOverlayScrollbarHidingChanged) {
                            setupHostMouseTouchEvents(!_scrollbarsAutoHideLeave && !_scrollbarsAutoHideMove);
                            refreshScrollbarsAutoHide(_scrollbarsAutoHideNever, !_scrollbarsAutoHideNever);
                        }

                        //manage scrollbars handle length & offset - don't remove!
                        if (hostSizeChanged || overflowAmount.c || heightAutoChanged || widthAutoChanged || resizeChanged || boxSizingChanged || paddingAbsoluteChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged) {
                            refreshScrollbarHandleLength(true);
                            refreshScrollbarHandleOffset(true);
                            refreshScrollbarHandleLength(false);
                            refreshScrollbarHandleOffset(false);
                        }

                        //manage interactivity
                        if (scrollbarsClickScrollingChanged)
                            refreshScrollbarsInteractive(true, scrollbarsClickScrolling);
                        if (scrollbarsDragScrollingChanged)
                            refreshScrollbarsInteractive(false, scrollbarsDragScrolling);

                        //callbacks:
                        dispatchCallback('onDirectionChanged', {
                            isRTL: _isRTL,
                            dir: cssDirection
                        }, cssDirectionChanged);
                        dispatchCallback('onHostSizeChanged', {
                            width: _hostSizeCache.w,
                            height: _hostSizeCache.h
                        }, hostSizeChanged);
                        dispatchCallback('onContentSizeChanged', {
                            width: _contentScrollSizeCache.w,
                            height: _contentScrollSizeCache.h
                        }, contentSizeChanged);
                        dispatchCallback('onOverflowChanged', {
                            x: hasOverflow.x,
                            y: hasOverflow.y,
                            xScrollable: hideOverflow.xs,
                            yScrollable: hideOverflow.ys,
                            clipped: hideOverflow.x || hideOverflow.y
                        }, hasOverflow.c || hideOverflow.c);
                        dispatchCallback('onOverflowAmountChanged', {
                            x: overflowAmount.x,
                            y: overflowAmount.y
                        }, overflowAmount.c);
                    }

                    //fix body min size
                    if (_isBody && _bodyMinSizeCache && (_hasOverflowCache.c || _bodyMinSizeCache.c)) {
                        //its possible that no min size was measured until now, because the content arrange element was just added now, in this case, measure now the min size.
                        if (!_bodyMinSizeCache.f)
                            bodyMinSizeChanged();
                        if (_nativeScrollbarIsOverlaid.y && _hasOverflowCache.x)
                            _contentElement.css(_strMinMinus + _strWidth, _bodyMinSizeCache.w + _overlayScrollbarDummySize.y);
                        if (_nativeScrollbarIsOverlaid.x && _hasOverflowCache.y)
                            _contentElement.css(_strMinMinus + _strHeight, _bodyMinSizeCache.h + _overlayScrollbarDummySize.x);
                        _bodyMinSizeCache.c = false;
                    }

                    if (_initialized && changedOptions.updateOnLoad) {
                        updateElementsOnLoad();
                    }

                    //freezeResizeObserver(_sizeObserverElement, false);
                    //freezeResizeObserver(_sizeAutoObserverElement, false);

                    dispatchCallback('onUpdated', { forced: force });
                }

                /**
                 * Updates the found elements of which the load event shall be handled.
                 */
                function updateElementsOnLoad() {
                    if (!_isTextarea) {
                        eachUpdateOnLoad(function (i, updateOnLoadSelector) {
                            _contentElement.find(updateOnLoadSelector).each(function (i, el) {
                                // if element doesn't have a updateOnLoadCallback applied
                                if (COMPATIBILITY.inA(el, _updateOnLoadElms) < 0) {
                                    _updateOnLoadElms.push(el);
                                    FRAMEWORK(el)
                                        .off(_updateOnLoadEventName, updateOnLoadCallback)
                                        .on(_updateOnLoadEventName, updateOnLoadCallback);
                                }
                            });
                        });
                    }
                }

                //==== Options ====//

                /**
                 * Sets new options but doesn't call the update method.
                 * @param newOptions The object which contains the new options.
                 * @returns {*} A object which contains the changed options.
                 */
                function setOptions(newOptions) {
                    var validatedOpts = _pluginsOptions._validate(newOptions, _pluginsOptions._template, true, _currentOptions)

                    _currentOptions = extendDeep({}, _currentOptions, validatedOpts._default);
                    _currentPreparedOptions = extendDeep({}, _currentPreparedOptions, validatedOpts._prepared);

                    return validatedOpts._prepared;
                }


                //==== Structure ====//

                /**
                 * Builds or destroys the wrapper and helper DOM elements.
                 * @param destroy Indicates whether the DOM shall be build or destroyed.
                 */
                /**
                 * Builds or destroys the wrapper and helper DOM elements.
                 * @param destroy Indicates whether the DOM shall be build or destroyed.
                 */
                function setupStructureDOM(destroy) {
                    var strParent = 'parent';
                    var classNameResizeObserverHost = 'os-resize-observer-host';
                    var classNameTextareaElementFull = _classNameTextareaElement + _strSpace + _classNameTextInherit;
                    var textareaClass = _isTextarea ? _strSpace + _classNameTextInherit : _strEmpty;
                    var adoptAttrs = _currentPreparedOptions.textarea.inheritedAttrs;
                    var adoptAttrsMap = {};
                    var applyAdoptedAttrs = function () {
                        var applyAdoptedAttrsElm = destroy ? _targetElement : _hostElement;
                        each(adoptAttrsMap, function (key, value) {
                            if (type(value) == TYPES.s) {
                                if (key == LEXICON.c)
                                    applyAdoptedAttrsElm.addClass(value);
                                else
                                    applyAdoptedAttrsElm.attr(key, value);
                            }
                        });
                    };
                    var hostElementClassNames = [
                        _classNameHostElement,
                        _classNameHostElementForeign,
                        _classNameHostTextareaElement,
                        _classNameHostResizeDisabled,
                        _classNameHostRTL,
                        _classNameHostScrollbarHorizontalHidden,
                        _classNameHostScrollbarVerticalHidden,
                        _classNameHostTransition,
                        _classNameHostScrolling,
                        _classNameHostOverflow,
                        _classNameHostOverflowX,
                        _classNameHostOverflowY,
                        _classNameThemeNone,
                        _classNameTextareaElement,
                        _classNameTextInherit,
                        _classNameCache].join(_strSpace);
                    var hostElementCSS = {};

                    //get host element as first element, because that's the most upper element and required for the other elements
                    _hostElement = _hostElement || (_isTextarea ? (_domExists ? _targetElement[strParent]()[strParent]()[strParent]()[strParent]() : FRAMEWORK(generateDiv(_classNameHostTextareaElement))) : _targetElement);
                    _contentElement = _contentElement || selectOrGenerateDivByClass(_classNameContentElement + textareaClass);
                    _viewportElement = _viewportElement || selectOrGenerateDivByClass(_classNameViewportElement + textareaClass);
                    _paddingElement = _paddingElement || selectOrGenerateDivByClass(_classNamePaddingElement + textareaClass);
                    _sizeObserverElement = _sizeObserverElement || selectOrGenerateDivByClass(classNameResizeObserverHost);
                    _textareaCoverElement = _textareaCoverElement || (_isTextarea ? selectOrGenerateDivByClass(_classNameTextareaCoverElement) : undefined);

                    //add this class to workaround class changing issues with UI frameworks especially Vue
                    if (_domExists)
                        addClass(_hostElement, _classNameHostElementForeign);

                    //on destroy, remove all generated class names from the host element before collecting the adopted attributes 
                    //to prevent adopting generated class names
                    if (destroy)
                        removeClass(_hostElement, hostElementClassNames);

                    //collect all adopted attributes
                    adoptAttrs = type(adoptAttrs) == TYPES.s ? adoptAttrs.split(_strSpace) : adoptAttrs;
                    if (COMPATIBILITY.isA(adoptAttrs) && _isTextarea) {
                        each(adoptAttrs, function (i, v) {
                            if (type(v) == TYPES.s) {
                                adoptAttrsMap[v] = destroy ? _hostElement.attr(v) : _targetElement.attr(v);
                            }
                        });
                    }

                    if (!destroy) {
                        if (_isTextarea) {
                            if (!_currentPreparedOptions.sizeAutoCapable) {
                                hostElementCSS[_strWidth] = _targetElement.css(_strWidth);
                                hostElementCSS[_strHeight] = _targetElement.css(_strHeight);
                            }

                            if (!_domExists)
                                _targetElement.addClass(_classNameTextInherit).wrap(_hostElement);

                            //jQuery clones elements in wrap functions, so we have to select them again
                            _hostElement = _targetElement[strParent]().css(hostElementCSS);
                        }

                        if (!_domExists) {
                            //add the correct class to the target element
                            addClass(_targetElement, _isTextarea ? classNameTextareaElementFull : _classNameHostElement);

                            //wrap the content into the generated elements to create the required DOM
                            _hostElement.wrapInner(_contentElement)
                                .wrapInner(_viewportElement)
                                .wrapInner(_paddingElement)
                                .prepend(_sizeObserverElement);

                            //jQuery clones elements in wrap functions, so we have to select them again
                            _contentElement = findFirst(_hostElement, _strDot + _classNameContentElement);
                            _viewportElement = findFirst(_hostElement, _strDot + _classNameViewportElement);
                            _paddingElement = findFirst(_hostElement, _strDot + _classNamePaddingElement);

                            if (_isTextarea) {
                                _contentElement.prepend(_textareaCoverElement);
                                applyAdoptedAttrs();
                            }
                        }

                        if (_nativeScrollbarStyling)
                            addClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible);
                        if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)
                            addClass(_viewportElement, _classNameViewportNativeScrollbarsOverlaid);
                        if (_isBody)
                            addClass(_htmlElement, _classNameHTMLElement);

                        _sizeObserverElementNative = _sizeObserverElement[0];
                        _hostElementNative = _hostElement[0];
                        _paddingElementNative = _paddingElement[0];
                        _viewportElementNative = _viewportElement[0];
                        _contentElementNative = _contentElement[0];

                        updateViewportAttrsFromTarget();
                    }
                    else {
                        if (_domExists && _initialized) {
                            //clear size observer
                            _sizeObserverElement.children().remove();

                            //remove the style property and classes from already generated elements
                            each([_paddingElement, _viewportElement, _contentElement, _textareaCoverElement], function (i, elm) {
                                if (elm) {
                                    removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                                }
                            });

                            //add classes to the host element which was removed previously to match the expected DOM
                            addClass(_hostElement, _isTextarea ? _classNameHostTextareaElement : _classNameHostElement);
                        }
                        else {
                            //remove size observer
                            remove(_sizeObserverElement);

                            //unwrap the content to restore DOM
                            _contentElement.contents()
                                .unwrap()
                                .unwrap()
                                .unwrap();

                            if (_isTextarea) {
                                _targetElement.unwrap();
                                remove(_hostElement);
                                remove(_textareaCoverElement);
                                applyAdoptedAttrs();
                            }
                        }

                        if (_isTextarea)
                            _targetElement.removeAttr(LEXICON.s);

                        if (_isBody)
                            removeClass(_htmlElement, _classNameHTMLElement);
                    }
                }

                /**
                 * Adds or removes all wrapper elements interactivity events.
                 * @param destroy Indicates whether the Events shall be added or removed.
                 */
                function setupStructureEvents() {
                    var textareaKeyDownRestrictedKeyCodes = [
                        112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 123,    //F1 to F12
                        33, 34,                                                   //page up, page down
                        37, 38, 39, 40,                                           //left, up, right, down arrows
                        16, 17, 18, 19, 20, 144                                   //Shift, Ctrl, Alt, Pause, CapsLock, NumLock
                    ];
                    var textareaKeyDownKeyCodesList = [];
                    var textareaUpdateIntervalID;
                    var scrollStopTimeoutId;
                    var scrollStopDelay = 175;
                    var strFocus = 'focus';

                    function updateTextarea(doClearInterval) {
                        textareaUpdate();
                        _base.update(_strAuto);
                        if (doClearInterval && _autoUpdateRecommended)
                            clearInterval(textareaUpdateIntervalID);
                    }
                    function textareaOnScroll(event) {
                        _targetElement[_strScrollLeft](_rtlScrollBehavior.i && _normalizeRTLCache ? 9999999 : 0);
                        _targetElement[_strScrollTop](0);
                        COMPATIBILITY.prvD(event);
                        COMPATIBILITY.stpP(event);
                        return false;
                    }
                    function textareaOnDrop(event) {
                        setTimeout(function () {
                            if (!_destroyed)
                                updateTextarea();
                        }, 50);
                    }
                    function textareaOnFocus() {
                        _textareaHasFocus = true;
                        addClass(_hostElement, strFocus);
                    }
                    function textareaOnFocusout() {
                        _textareaHasFocus = false;
                        textareaKeyDownKeyCodesList = [];
                        removeClass(_hostElement, strFocus);
                        updateTextarea(true);
                    }
                    function textareaOnKeyDown(event) {
                        var keyCode = event.keyCode;

                        if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {
                            if (!textareaKeyDownKeyCodesList[LEXICON.l]) {
                                updateTextarea();
                                textareaUpdateIntervalID = setInterval(updateTextarea, 1000 / 60);
                            }
                            if (inArray(keyCode, textareaKeyDownKeyCodesList) < 0)
                                textareaKeyDownKeyCodesList.push(keyCode);
                        }
                    }
                    function textareaOnKeyUp(event) {
                        var keyCode = event.keyCode;
                        var index = inArray(keyCode, textareaKeyDownKeyCodesList);

                        if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {
                            if (index > -1)
                                textareaKeyDownKeyCodesList.splice(index, 1);
                            if (!textareaKeyDownKeyCodesList[LEXICON.l])
                                updateTextarea(true);
                        }
                    }
                    function contentOnTransitionEnd(event) {
                        if (_autoUpdateCache === true)
                            return;
                        event = event.originalEvent || event;
                        if (isSizeAffectingCSSProperty(event.propertyName))
                            _base.update(_strAuto);
                    }
                    function viewportOnScroll(event) {
                        if (!_sleeping) {
                            if (scrollStopTimeoutId !== undefined)
                                clearTimeout(scrollStopTimeoutId);
                            else {
                                if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                                    refreshScrollbarsAutoHide(true);

                                if (!nativeOverlayScrollbarsAreActive())
                                    addClass(_hostElement, _classNameHostScrolling);

                                dispatchCallback('onScrollStart', event);
                            }

                            //if a scrollbars handle gets dragged, the mousemove event is responsible for refreshing the handle offset
                            //because if CSS scroll-snap is used, the handle offset gets only refreshed on every snap point
                            //this looks laggy & clunky, it looks much better if the offset refreshes with the mousemove
                            if (!_scrollbarsHandlesDefineScrollPos) {
                                refreshScrollbarHandleOffset(true);
                                refreshScrollbarHandleOffset(false);
                            }
                            dispatchCallback('onScroll', event);

                            scrollStopTimeoutId = setTimeout(function () {
                                if (!_destroyed) {
                                    //OnScrollStop:
                                    clearTimeout(scrollStopTimeoutId);
                                    scrollStopTimeoutId = undefined;

                                    if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                                        refreshScrollbarsAutoHide(false);

                                    if (!nativeOverlayScrollbarsAreActive())
                                        removeClass(_hostElement, _classNameHostScrolling);

                                    dispatchCallback('onScrollStop', event);
                                }
                            }, scrollStopDelay);
                        }
                    }


                    if (_isTextarea) {
                        if (_msieVersion > 9 || !_autoUpdateRecommended) {
                            addDestroyEventListener(_targetElement, 'input', updateTextarea);
                        }
                        else {
                            addDestroyEventListener(_targetElement,
                                [_strKeyDownEvent, _strKeyUpEvent],
                                [textareaOnKeyDown, textareaOnKeyUp]);
                        }

                        addDestroyEventListener(_targetElement,
                            [_strScroll, 'drop', strFocus, strFocus + 'out'],
                            [textareaOnScroll, textareaOnDrop, textareaOnFocus, textareaOnFocusout]);
                    }
                    else {
                        addDestroyEventListener(_contentElement, _strTransitionEndEvent, contentOnTransitionEnd);
                    }
                    addDestroyEventListener(_viewportElement, _strScroll, viewportOnScroll, true);
                }


                //==== Scrollbars ====//

                /**
                 * Builds or destroys all scrollbar DOM elements (scrollbar, track, handle)
                 * @param destroy Indicates whether the DOM shall be build or destroyed.
                 */
                function setupScrollbarsDOM(destroy) {
                    var selectOrGenerateScrollbarDOM = function (isHorizontal) {
                        var scrollbarClassName = isHorizontal ? _classNameScrollbarHorizontal : _classNameScrollbarVertical;
                        var scrollbar = selectOrGenerateDivByClass(_classNameScrollbar + _strSpace + scrollbarClassName, true);
                        var track = selectOrGenerateDivByClass(_classNameScrollbarTrack, scrollbar);
                        var handle = selectOrGenerateDivByClass(_classNameScrollbarHandle, scrollbar);

                        if (!_domExists && !destroy) {
                            scrollbar.append(track);
                            track.append(handle);
                        }

                        return {
                            _scrollbar: scrollbar,
                            _track: track,
                            _handle: handle
                        };
                    };
                    function resetScrollbarDOM(isHorizontal) {
                        var scrollbarVars = getScrollbarVars(isHorizontal);
                        var scrollbar = scrollbarVars._scrollbar;
                        var track = scrollbarVars._track;
                        var handle = scrollbarVars._handle;

                        if (_domExists && _initialized) {
                            each([scrollbar, track, handle], function (i, elm) {
                                removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                            });
                        }
                        else {
                            remove(scrollbar || selectOrGenerateScrollbarDOM(isHorizontal)._scrollbar);
                        }
                    }
                    var horizontalElements;
                    var verticalElements;

                    if (!destroy) {
                        horizontalElements = selectOrGenerateScrollbarDOM(true);
                        verticalElements = selectOrGenerateScrollbarDOM();

                        _scrollbarHorizontalElement = horizontalElements._scrollbar;
                        _scrollbarHorizontalTrackElement = horizontalElements._track;
                        _scrollbarHorizontalHandleElement = horizontalElements._handle;
                        _scrollbarVerticalElement = verticalElements._scrollbar;
                        _scrollbarVerticalTrackElement = verticalElements._track;
                        _scrollbarVerticalHandleElement = verticalElements._handle;

                        if (!_domExists) {
                            _paddingElement.after(_scrollbarVerticalElement);
                            _paddingElement.after(_scrollbarHorizontalElement);
                        }
                    }
                    else {
                        resetScrollbarDOM(true);
                        resetScrollbarDOM();
                    }
                }

                /**
                 * Initializes all scrollbar interactivity events. (track and handle dragging, clicking, scrolling)
                 * @param isHorizontal True if the target scrollbar is the horizontal scrollbar, false if the target scrollbar is the vertical scrollbar.
                 */
                function setupScrollbarEvents(isHorizontal) {
                    var scrollbarVars = getScrollbarVars(isHorizontal);
                    var scrollbarVarsInfo = scrollbarVars._info;
                    var insideIFrame = _windowElementNative.top !== _windowElementNative;
                    var xy = scrollbarVars._x_y;
                    var XY = scrollbarVars._X_Y;
                    var scroll = _strScroll + scrollbarVars._Left_Top;
                    var strActive = 'active';
                    var strSnapHandle = 'snapHandle';
                    var strClickEvent = 'click';
                    var scrollDurationFactor = 1;
                    var increaseDecreaseScrollAmountKeyCodes = [16, 17]; //shift, ctrl
                    var trackTimeout;
                    var mouseDownScroll;
                    var mouseDownOffset;
                    var mouseDownInvertedScale;

                    function getPointerPosition(event) {
                        return _msieVersion && insideIFrame ? event['screen' + XY] : COMPATIBILITY.page(event)[xy]; //use screen coordinates in EDGE & IE because the page values are incorrect in frames.
                    }
                    function getPreparedScrollbarsOption(name) {
                        return _currentPreparedOptions.scrollbars[name];
                    }
                    function increaseTrackScrollAmount() {
                        scrollDurationFactor = 0.5;
                    }
                    function decreaseTrackScrollAmount() {
                        scrollDurationFactor = 1;
                    }
                    function stopClickEventPropagation(event) {
                        COMPATIBILITY.stpP(event);
                    }
                    function documentKeyDown(event) {
                        if (inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1)
                            increaseTrackScrollAmount();
                    }
                    function documentKeyUp(event) {
                        if (inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1)
                            decreaseTrackScrollAmount();
                    }
                    function onMouseTouchDownContinue(event) {
                        var originalEvent = event.originalEvent || event;
                        var isTouchEvent = originalEvent.touches !== undefined;
                        return _sleeping || _destroyed || nativeOverlayScrollbarsAreActive() || !_scrollbarsDragScrollingCache || (isTouchEvent && !getPreparedScrollbarsOption('touchSupport')) ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;
                    }
                    function documentDragMove(event) {
                        if (onMouseTouchDownContinue(event)) {
                            var trackLength = scrollbarVarsInfo._trackLength;
                            var handleLength = scrollbarVarsInfo._handleLength;
                            var scrollRange = scrollbarVarsInfo._maxScroll;
                            var scrollRaw = (getPointerPosition(event) - mouseDownOffset) * mouseDownInvertedScale;
                            var scrollDeltaPercent = scrollRaw / (trackLength - handleLength);
                            var scrollDelta = (scrollRange * scrollDeltaPercent);
                            scrollDelta = isFinite(scrollDelta) ? scrollDelta : 0;
                            if (_isRTL && isHorizontal && !_rtlScrollBehavior.i)
                                scrollDelta *= -1;

                            _viewportElement[scroll](MATH.round(mouseDownScroll + scrollDelta));

                            if (_scrollbarsHandlesDefineScrollPos)
                                refreshScrollbarHandleOffset(isHorizontal, mouseDownScroll + scrollDelta);

                            if (!_supportPassiveEvents)
                                COMPATIBILITY.prvD(event);
                        }
                        else
                            documentMouseTouchUp(event);
                    }
                    function documentMouseTouchUp(event) {
                        event = event || event.originalEvent;

                        setupResponsiveEventListener(_documentElement,
                            [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent],
                            [documentDragMove, documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart],
                            true);
                        COMPATIBILITY.rAF()(function() {
                            setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, true, { _capture: true });
                        });
                        
                            
                        if (_scrollbarsHandlesDefineScrollPos)
                            refreshScrollbarHandleOffset(isHorizontal, true);

                        _scrollbarsHandlesDefineScrollPos = false;
                        removeClass(_bodyElement, _classNameDragging);
                        removeClass(scrollbarVars._handle, strActive);
                        removeClass(scrollbarVars._track, strActive);
                        removeClass(scrollbarVars._scrollbar, strActive);

                        mouseDownScroll = undefined;
                        mouseDownOffset = undefined;
                        mouseDownInvertedScale = 1;

                        decreaseTrackScrollAmount();

                        if (trackTimeout !== undefined) {
                            _base.scrollStop();
                            clearTimeout(trackTimeout);
                            trackTimeout = undefined;
                        }

                        if (event) {
                            var rect = _hostElementNative[LEXICON.bCR]();
                            var mouseInsideHost = event.clientX >= rect.left && event.clientX <= rect.right && event.clientY >= rect.top && event.clientY <= rect.bottom;

                            //if mouse is outside host element
                            if (!mouseInsideHost)
                                hostOnMouseLeave();

                            if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                                refreshScrollbarsAutoHide(false);
                        }
                    }
                    function onHandleMouseTouchDown(event) {
                        if (onMouseTouchDownContinue(event))
                            onHandleMouseTouchDownAction(event);
                    }
                    function onHandleMouseTouchDownAction(event) {
                        mouseDownScroll = _viewportElement[scroll]();
                        mouseDownScroll = isNaN(mouseDownScroll) ? 0 : mouseDownScroll;
                        if (_isRTL && isHorizontal && !_rtlScrollBehavior.n || !_isRTL)
                            mouseDownScroll = mouseDownScroll < 0 ? 0 : mouseDownScroll;

                        mouseDownInvertedScale = getHostElementInvertedScale()[xy];
                        mouseDownOffset = getPointerPosition(event);

                        _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);
                        addClass(_bodyElement, _classNameDragging);
                        addClass(scrollbarVars._handle, strActive);
                        addClass(scrollbarVars._scrollbar, strActive);

                        setupResponsiveEventListener(_documentElement,
                            [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strSelectStartEvent],
                            [documentDragMove, documentMouseTouchUp, documentOnSelectStart]);
                        COMPATIBILITY.rAF()(function() {
                            setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, false, { _capture: true });
                        });
                        

                        if (_msieVersion || !_documentMixed)
                            COMPATIBILITY.prvD(event);
                        COMPATIBILITY.stpP(event);
                    }
                    function onTrackMouseTouchDown(event) {
                        if (onMouseTouchDownContinue(event)) {
                            var handleToViewportRatio = scrollbarVars._info._handleLength / Math.round(MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]) * scrollbarVars._info._trackLength);
                            var scrollDistance = MATH.round(_viewportSize[scrollbarVars._w_h] * handleToViewportRatio);
                            var scrollBaseDuration = 270 * handleToViewportRatio;
                            var scrollFirstIterationDelay = 400 * handleToViewportRatio;
                            var trackOffset = scrollbarVars._track.offset()[scrollbarVars._left_top];
                            var ctrlKey = event.ctrlKey;
                            var instantScroll = event.shiftKey;
                            var instantScrollTransition = instantScroll && ctrlKey;
                            var isFirstIteration = true;
                            var easing = 'linear';
                            var decreaseScroll;
                            var finishedCondition;
                            var scrollActionFinsished = function (transition) {
                                if (_scrollbarsHandlesDefineScrollPos)
                                    refreshScrollbarHandleOffset(isHorizontal, transition);
                            };
                            var scrollActionInstantFinished = function () {
                                scrollActionFinsished();
                                onHandleMouseTouchDownAction(event);
                            };
                            var scrollAction = function () {
                                if (!_destroyed) {
                                    var mouseOffset = (mouseDownOffset - trackOffset) * mouseDownInvertedScale;
                                    var handleOffset = scrollbarVarsInfo._handleOffset;
                                    var trackLength = scrollbarVarsInfo._trackLength;
                                    var handleLength = scrollbarVarsInfo._handleLength;
                                    var scrollRange = scrollbarVarsInfo._maxScroll;
                                    var currScroll = scrollbarVarsInfo._currentScroll;
                                    var scrollDuration = scrollBaseDuration * scrollDurationFactor;
                                    var timeoutDelay = isFirstIteration ? MATH.max(scrollFirstIterationDelay, scrollDuration) : scrollDuration;
                                    var instantScrollPosition = scrollRange * ((mouseOffset - (handleLength / 2)) / (trackLength - handleLength)); // 100% * positionPercent
                                    var rtlIsNormal = _isRTL && isHorizontal && ((!_rtlScrollBehavior.i && !_rtlScrollBehavior.n) || _normalizeRTLCache);
                                    var decreaseScrollCondition = rtlIsNormal ? handleOffset < mouseOffset : handleOffset > mouseOffset;
                                    var scrollObj = {};
                                    var animationObj = {
                                        easing: easing,
                                        step: function (now) {
                                            if (_scrollbarsHandlesDefineScrollPos) {
                                                _viewportElement[scroll](now); //https://github.com/jquery/jquery/issues/4340
                                                refreshScrollbarHandleOffset(isHorizontal, now);
                                            }
                                        }
                                    };
                                    instantScrollPosition = isFinite(instantScrollPosition) ? instantScrollPosition : 0;
                                    instantScrollPosition = _isRTL && isHorizontal && !_rtlScrollBehavior.i ? (scrollRange - instantScrollPosition) : instantScrollPosition;

                                    //_base.scrollStop();

                                    if (instantScroll) {
                                        _viewportElement[scroll](instantScrollPosition); //scroll instantly to new position
                                        if (instantScrollTransition) {
                                            //get the scroll position after instant scroll (in case CSS Snap Points are used) to get the correct snapped scroll position
                                            //and the animation stops at the correct point
                                            instantScrollPosition = _viewportElement[scroll]();
                                            //scroll back to the position before instant scrolling so animation can be performed
                                            _viewportElement[scroll](currScroll);

                                            instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.i ? (scrollRange - instantScrollPosition) : instantScrollPosition;
                                            instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.n ? -instantScrollPosition : instantScrollPosition;

                                            scrollObj[xy] = instantScrollPosition;
                                            _base.scroll(scrollObj, extendDeep(animationObj, {
                                                duration: 130,
                                                complete: scrollActionInstantFinished
                                            }));
                                        }
                                        else
                                            scrollActionInstantFinished();
                                    }
                                    else {
                                        decreaseScroll = isFirstIteration ? decreaseScrollCondition : decreaseScroll;
                                        finishedCondition = rtlIsNormal
                                            ? (decreaseScroll ? handleOffset + handleLength >= mouseOffset : handleOffset <= mouseOffset)
                                            : (decreaseScroll ? handleOffset <= mouseOffset : handleOffset + handleLength >= mouseOffset);

                                        if (finishedCondition) {
                                            clearTimeout(trackTimeout);
                                            _base.scrollStop();
                                            trackTimeout = undefined;
                                            scrollActionFinsished(true);
                                        }
                                        else {
                                            trackTimeout = setTimeout(scrollAction, timeoutDelay);

                                            scrollObj[xy] = (decreaseScroll ? '-=' : '+=') + scrollDistance;
                                            _base.scroll(scrollObj, extendDeep(animationObj, {
                                                duration: scrollDuration
                                            }));
                                        }
                                        isFirstIteration = false;
                                    }
                                }
                            };
                            if (ctrlKey)
                                increaseTrackScrollAmount();

                            mouseDownInvertedScale = getHostElementInvertedScale()[xy];
                            mouseDownOffset = COMPATIBILITY.page(event)[xy];

                            _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);
                            addClass(_bodyElement, _classNameDragging);
                            addClass(scrollbarVars._track, strActive);
                            addClass(scrollbarVars._scrollbar, strActive);

                            setupResponsiveEventListener(_documentElement,
                                [_strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent],
                                [documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart]);

                            scrollAction();
                            COMPATIBILITY.prvD(event);
                            COMPATIBILITY.stpP(event);
                        }
                    }
                    function onTrackMouseTouchEnter(event) {
                        //make sure both scrollbars will stay visible if one scrollbar is hovered if autoHide is "scroll" or "move".
                        _scrollbarsHandleHovered = true;
                        if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                            refreshScrollbarsAutoHide(true);
                    }
                    function onTrackMouseTouchLeave(event) {
                        _scrollbarsHandleHovered = false;
                        if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                            refreshScrollbarsAutoHide(false);
                    }
                    function onScrollbarMouseTouchDown(event) {
                        COMPATIBILITY.stpP(event);
                    }

                    addDestroyEventListener(scrollbarVars._handle,
                        _strMouseTouchDownEvent,
                        onHandleMouseTouchDown);
                    addDestroyEventListener(scrollbarVars._track,
                        [_strMouseTouchDownEvent, _strMouseEnter, _strMouseLeave],
                        [onTrackMouseTouchDown, onTrackMouseTouchEnter, onTrackMouseTouchLeave]);
                    addDestroyEventListener(scrollbarVars._scrollbar,
                        _strMouseTouchDownEvent,
                        onScrollbarMouseTouchDown);

                    if (_supportTransition) {
                        addDestroyEventListener(scrollbarVars._scrollbar, _strTransitionEndEvent, function (event) {
                            if (event.target !== scrollbarVars._scrollbar[0])
                                return;
                            refreshScrollbarHandleLength(isHorizontal);
                            refreshScrollbarHandleOffset(isHorizontal);
                        });
                    }
                }

                /**
                 * Shows or hides the given scrollbar and applied a class name which indicates if the scrollbar is scrollable or not.
                 * @param isHorizontal True if the horizontal scrollbar is the target, false if the vertical scrollbar is the target.
                 * @param shallBeVisible True if the scrollbar shall be shown, false if hidden.
                 * @param canScroll True if the scrollbar is scrollable, false otherwise.
                 */
                function refreshScrollbarAppearance(isHorizontal, shallBeVisible, canScroll) {
                    var scrollbarHiddenClassName = isHorizontal ? _classNameHostScrollbarHorizontalHidden : _classNameHostScrollbarVerticalHidden;
                    var scrollbarElement = isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement;

                    addRemoveClass(_hostElement, scrollbarHiddenClassName, !shallBeVisible);
                    addRemoveClass(scrollbarElement, _classNameScrollbarUnusable, !canScroll);
                }

                /**
                 * Autoshows / autohides both scrollbars with.
                 * @param shallBeVisible True if the scrollbars shall be autoshown (only the case if they are hidden by a autohide), false if the shall be auto hidden.
                 * @param delayfree True if the scrollbars shall be hidden without a delay, false or undefined otherwise.
                 */
                function refreshScrollbarsAutoHide(shallBeVisible, delayfree) {
                    clearTimeout(_scrollbarsAutoHideTimeoutId);
                    if (shallBeVisible) {
                        //if(_hasOverflowCache.x && _hideOverflowCache.xs)
                        removeClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);
                        //if(_hasOverflowCache.y && _hideOverflowCache.ys)
                        removeClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);
                    }
                    else {
                        var anyActive;
                        var strActive = 'active';
                        var hide = function () {
                            if (!_scrollbarsHandleHovered && !_destroyed) {
                                anyActive = _scrollbarHorizontalHandleElement.hasClass(strActive) || _scrollbarVerticalHandleElement.hasClass(strActive);
                                if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))
                                    addClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);
                                if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))
                                    addClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);
                            }
                        };
                        if (_scrollbarsAutoHideDelay > 0 && delayfree !== true)
                            _scrollbarsAutoHideTimeoutId = setTimeout(hide, _scrollbarsAutoHideDelay);
                        else
                            hide();
                    }
                }

                /**
                 * Refreshes the handle length of the given scrollbar.
                 * @param isHorizontal True if the horizontal scrollbar handle shall be refreshed, false if the vertical one shall be refreshed.
                 */
                function refreshScrollbarHandleLength(isHorizontal) {
                    var handleCSS = {};
                    var scrollbarVars = getScrollbarVars(isHorizontal);
                    var scrollbarVarsInfo = scrollbarVars._info;
                    var digit = 1000000;
                    //get and apply intended handle length
                    var handleRatio = MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]);
                    handleCSS[scrollbarVars._width_height] = (MATH.floor(handleRatio * 100 * digit) / digit) + '%'; //the last * digit / digit is for flooring to the 4th digit

                    if (!nativeOverlayScrollbarsAreActive())
                        scrollbarVars._handle.css(handleCSS);

                    //measure the handle length to respect min & max length
                    scrollbarVarsInfo._handleLength = scrollbarVars._handle[0]['offset' + scrollbarVars._Width_Height];
                    scrollbarVarsInfo._handleLengthRatio = handleRatio;
                }

                /**
                 * Refreshes the handle offset of the given scrollbar.
                 * @param isHorizontal True if the horizontal scrollbar handle shall be refreshed, false if the vertical one shall be refreshed.
                 * @param scrollOrTransition The scroll position of the given scrollbar axis to which the handle shall be moved or a boolean which indicates whether a transition shall be applied. If undefined or boolean if the current scroll-offset is taken. (if isHorizontal ? scrollLeft : scrollTop)
                 */
                function refreshScrollbarHandleOffset(isHorizontal, scrollOrTransition) {
                    var transition = type(scrollOrTransition) == TYPES.b;
                    var transitionDuration = 250;
                    var isRTLisHorizontal = _isRTL && isHorizontal;
                    var scrollbarVars = getScrollbarVars(isHorizontal);
                    var scrollbarVarsInfo = scrollbarVars._info;
                    var strTranslateBrace = 'translate(';
                    var strTransform = VENDORS._cssProperty('transform');
                    var strTransition = VENDORS._cssProperty('transition');
                    var nativeScroll = isHorizontal ? _viewportElement[_strScrollLeft]() : _viewportElement[_strScrollTop]();
                    var currentScroll = scrollOrTransition === undefined || transition ? nativeScroll : scrollOrTransition;

                    //measure the handle length to respect min & max length
                    var handleLength = scrollbarVarsInfo._handleLength;
                    var trackLength = scrollbarVars._track[0]['offset' + scrollbarVars._Width_Height];
                    var handleTrackDiff = trackLength - handleLength;
                    var handleCSS = {};
                    var transformOffset;
                    var translateValue;

                    //DONT use the variable '_contentScrollSizeCache[scrollbarVars._w_h]' instead of '_viewportElement[0]['scroll' + scrollbarVars._Width_Height]'
                    // because its a bit behind during the small delay when content size updates
                    //(delay = mutationObserverContentLag, if its 0 then this var could be used)
                    var maxScroll = (_viewportElementNative[_strScroll + scrollbarVars._Width_Height] - _viewportElementNative['client' + scrollbarVars._Width_Height]) * (_rtlScrollBehavior.n && isRTLisHorizontal ? -1 : 1); //* -1 if rtl scroll max is negative
                    var getScrollRatio = function (base) {
                        return isNaN(base / maxScroll) ? 0 : MATH.max(0, MATH.min(1, base / maxScroll));
                    };
                    var getHandleOffset = function (scrollRatio) {
                        var offset = handleTrackDiff * scrollRatio;
                        offset = isNaN(offset) ? 0 : offset;
                        offset = (isRTLisHorizontal && !_rtlScrollBehavior.i) ? (trackLength - handleLength - offset) : offset;
                        offset = MATH.max(0, offset);
                        return offset;
                    };
                    var scrollRatio = getScrollRatio(nativeScroll);
                    var unsnappedScrollRatio = getScrollRatio(currentScroll);
                    var handleOffset = getHandleOffset(unsnappedScrollRatio);
                    var snappedHandleOffset = getHandleOffset(scrollRatio);

                    scrollbarVarsInfo._maxScroll = maxScroll;
                    scrollbarVarsInfo._currentScroll = nativeScroll;
                    scrollbarVarsInfo._currentScrollRatio = scrollRatio;

                    if (_supportTransform) {
                        transformOffset = isRTLisHorizontal ? -(trackLength - handleLength - handleOffset) : handleOffset; //in px
                        //transformOffset = (transformOffset / trackLength * 100) * (trackLength / handleLength); //in %
                        translateValue = isHorizontal ? strTranslateBrace + transformOffset + 'px, 0)' : strTranslateBrace + '0, ' + transformOffset + 'px)';

                        handleCSS[strTransform] = translateValue;

                        //apply or clear up transition
                        if (_supportTransition)
                            handleCSS[strTransition] = transition && MATH.abs(handleOffset - scrollbarVarsInfo._handleOffset) > 1 ? getCSSTransitionString(scrollbarVars._handle) + ', ' + (strTransform + _strSpace + transitionDuration + 'ms') : _strEmpty;
                    }
                    else
                        handleCSS[scrollbarVars._left_top] = handleOffset;


                    //only apply css if offset has changed and overflow exists.
                    if (!nativeOverlayScrollbarsAreActive()) {
                        scrollbarVars._handle.css(handleCSS);

                        //clear up transition
                        if (_supportTransform && _supportTransition && transition) {
                            scrollbarVars._handle.one(_strTransitionEndEvent, function () {
                                if (!_destroyed)
                                    scrollbarVars._handle.css(strTransition, _strEmpty);
                            });
                        }
                    }

                    scrollbarVarsInfo._handleOffset = handleOffset;
                    scrollbarVarsInfo._snappedHandleOffset = snappedHandleOffset;
                    scrollbarVarsInfo._trackLength = trackLength;
                }

                /**
                 * Refreshes the interactivity of the given scrollbar element.
                 * @param isTrack True if the track element is the target, false if the handle element is the target.
                 * @param value True for interactivity false for no interactivity.
                 */
                function refreshScrollbarsInteractive(isTrack, value) {
                    var action = value ? 'removeClass' : 'addClass';
                    var element1 = isTrack ? _scrollbarHorizontalTrackElement : _scrollbarHorizontalHandleElement;
                    var element2 = isTrack ? _scrollbarVerticalTrackElement : _scrollbarVerticalHandleElement;
                    var className = isTrack ? _classNameScrollbarTrackOff : _classNameScrollbarHandleOff;

                    element1[action](className);
                    element2[action](className);
                }

                /**
                 * Returns a object which is used for fast access for specific variables.
                 * @param isHorizontal True if the horizontal scrollbar vars shall be accessed, false if the vertical scrollbar vars shall be accessed.
                 * @returns {{wh: string, WH: string, lt: string, _wh: string, _lt: string, t: *, h: *, c: {}, s: *}}
                 */
                function getScrollbarVars(isHorizontal) {
                    return {
                        _width_height: isHorizontal ? _strWidth : _strHeight,
                        _Width_Height: isHorizontal ? 'Width' : 'Height',
                        _left_top: isHorizontal ? _strLeft : _strTop,
                        _Left_Top: isHorizontal ? 'Left' : 'Top',
                        _x_y: isHorizontal ? _strX : _strY,
                        _X_Y: isHorizontal ? 'X' : 'Y',
                        _w_h: isHorizontal ? 'w' : 'h',
                        _l_t: isHorizontal ? 'l' : 't',
                        _track: isHorizontal ? _scrollbarHorizontalTrackElement : _scrollbarVerticalTrackElement,
                        _handle: isHorizontal ? _scrollbarHorizontalHandleElement : _scrollbarVerticalHandleElement,
                        _scrollbar: isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement,
                        _info: isHorizontal ? _scrollHorizontalInfo : _scrollVerticalInfo
                    };
                }


                //==== Scrollbar Corner ====//

                /**
                 * Builds or destroys the scrollbar corner DOM element.
                 * @param destroy Indicates whether the DOM shall be build or destroyed.
                 */
                function setupScrollbarCornerDOM(destroy) {
                    _scrollbarCornerElement = _scrollbarCornerElement || selectOrGenerateDivByClass(_classNameScrollbarCorner, true);

                    if (!destroy) {
                        if (!_domExists) {
                            _hostElement.append(_scrollbarCornerElement);
                        }
                    }
                    else {
                        if (_domExists && _initialized) {
                            removeClass(_scrollbarCornerElement.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                        }
                        else {
                            remove(_scrollbarCornerElement);
                        }
                    }
                }

                /**
                 * Initializes all scrollbar corner interactivity events.
                 */
                function setupScrollbarCornerEvents() {
                    var insideIFrame = _windowElementNative.top !== _windowElementNative;
                    var mouseDownPosition = {};
                    var mouseDownSize = {};
                    var mouseDownInvertedScale = {};
                    var reconnectMutationObserver;

                    function documentDragMove(event) {
                        if (onMouseTouchDownContinue(event)) {
                            var pageOffset = getCoordinates(event);
                            var hostElementCSS = {};
                            if (_resizeHorizontal || _resizeBoth)
                                hostElementCSS[_strWidth] = (mouseDownSize.w + (pageOffset.x - mouseDownPosition.x) * mouseDownInvertedScale.x);
                            if (_resizeVertical || _resizeBoth)
                                hostElementCSS[_strHeight] = (mouseDownSize.h + (pageOffset.y - mouseDownPosition.y) * mouseDownInvertedScale.y);
                            _hostElement.css(hostElementCSS);
                            COMPATIBILITY.stpP(event);
                        }
                        else {
                            documentMouseTouchUp(event);
                        }
                    }
                    function documentMouseTouchUp(event) {
                        var eventIsTrusted = event !== undefined;

                        setupResponsiveEventListener(_documentElement,
                            [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent],
                            [documentOnSelectStart, documentDragMove, documentMouseTouchUp],
                            true);

                        removeClass(_bodyElement, _classNameDragging);
                        if (_scrollbarCornerElement.releaseCapture)
                            _scrollbarCornerElement.releaseCapture();

                        if (eventIsTrusted) {
                            if (reconnectMutationObserver)
                                connectMutationObservers();
                            _base.update(_strAuto);
                        }
                        reconnectMutationObserver = false;
                    }
                    function onMouseTouchDownContinue(event) {
                        var originalEvent = event.originalEvent || event;
                        var isTouchEvent = originalEvent.touches !== undefined;
                        return _sleeping || _destroyed ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;
                    }
                    function getCoordinates(event) {
                        return _msieVersion && insideIFrame ? { x: event.screenX, y: event.screenY } : COMPATIBILITY.page(event);
                    }

                    addDestroyEventListener(_scrollbarCornerElement, _strMouseTouchDownEvent, function (event) {
                        if (onMouseTouchDownContinue(event) && !_resizeNone) {
                            if (_mutationObserversConnected) {
                                reconnectMutationObserver = true;
                                disconnectMutationObservers();
                            }

                            mouseDownPosition = getCoordinates(event);

                            mouseDownSize.w = _hostElementNative[LEXICON.oW] - (!_isBorderBox ? _paddingX : 0);
                            mouseDownSize.h = _hostElementNative[LEXICON.oH] - (!_isBorderBox ? _paddingY : 0);
                            mouseDownInvertedScale = getHostElementInvertedScale();

                            setupResponsiveEventListener(_documentElement,
                                [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent],
                                [documentOnSelectStart, documentDragMove, documentMouseTouchUp]);

                            addClass(_bodyElement, _classNameDragging);
                            if (_scrollbarCornerElement.setCapture)
                                _scrollbarCornerElement.setCapture();

                            COMPATIBILITY.prvD(event);
                            COMPATIBILITY.stpP(event);
                        }
                    });
                }


                //==== Utils ====//

                /**
                 * Calls the callback with the given name. The Context of this callback is always _base (this).
                 * @param name The name of the target which shall be called.
                 * @param args The args with which the callback shall be called.
                 * @param dependent Boolean which decides whether the callback shall be fired, undefined is like a "true" value.
                 */
                function dispatchCallback(name, args, dependent) {
                    if (dependent === false)
                        return;
                    if (_initialized) {
                        var callback = _currentPreparedOptions.callbacks[name];
                        var extensionOnName = name;
                        var ext;

                        if (extensionOnName.substr(0, 2) === 'on')
                            extensionOnName = extensionOnName.substr(2, 1).toLowerCase() + extensionOnName.substr(3);

                        if (type(callback) == TYPES.f)
                            callback.call(_base, args);

                        each(_extensions, function () {
                            ext = this;
                            if (type(ext.on) == TYPES.f)
                                ext.on(extensionOnName, args);
                        });
                    }
                    else if (!_destroyed)
                        _callbacksInitQeueue.push({ n: name, a: args });
                }

                /**
                 * Sets the "top, right, bottom, left" properties, with a given prefix, of the given css object.
                 * @param targetCSSObject The css object to which the values shall be applied.
                 * @param prefix The prefix of the "top, right, bottom, left" css properties. (example: 'padding-' is a valid prefix)
                 * @param values A array of values which shall be applied to the "top, right, bottom, left" -properties. The array order is [top, right, bottom, left].
                 * If this argument is undefined the value '' (empty string) will be applied to all properties.
                 */
                function setTopRightBottomLeft(targetCSSObject, prefix, values) {
                    prefix = prefix || _strEmpty;
                    values = values || [_strEmpty, _strEmpty, _strEmpty, _strEmpty];

                    targetCSSObject[prefix + _strTop] = values[0];
                    targetCSSObject[prefix + _strRight] = values[1];
                    targetCSSObject[prefix + _strBottom] = values[2];
                    targetCSSObject[prefix + _strLeft] = values[3];
                }

                /**
                 * Gets the "top, right, bottom, left" CSS properties of the CSS property with the given prefix from the host element.
                 * @param prefix The prefix of the "top, right, bottom, left" css properties. (example: 'padding-' is a valid prefix)
                 * @param suffix The suffix of the "top, right, bottom, left" css properties. (example: 'border-' is a valid prefix with '-width' is a valid suffix)
                 * @param zeroX True if the x axis shall be 0.
                 * @param zeroY True if the y axis shall be 0.
                 * @returns {{}} The object which contains the numbers of the read CSS properties.
                 */
                function getTopRightBottomLeftHost(prefix, suffix, zeroX, zeroY) {
                    suffix = suffix || _strEmpty;
                    prefix = prefix || _strEmpty;
                    return {
                        t: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strTop + suffix)),
                        r: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strRight + suffix)),
                        b: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strBottom + suffix)),
                        l: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strLeft + suffix))
                    };
                }

                /**
                 * Returns the computed CSS transition string from the given element.
                 * @param element The element from which the transition string shall be returned.
                 * @returns {string} The CSS transition string from the given element.
                 */
                function getCSSTransitionString(element) {
                    var transitionStr = VENDORS._cssProperty('transition');
                    var assembledValue = element.css(transitionStr);
                    if (assembledValue)
                        return assembledValue;
                    var regExpString = '\\s*(' + '([^,(]+(\\(.+?\\))?)+' + ')[\\s,]*';
                    var regExpMain = new RegExp(regExpString);
                    var regExpValidate = new RegExp('^(' + regExpString + ')+$');
                    var properties = 'property duration timing-function delay'.split(' ');
                    var result = [];
                    var strResult;
                    var valueArray;
                    var i = 0;
                    var j;
                    var splitCssStyleByComma = function (str) {
                        strResult = [];
                        if (!str.match(regExpValidate))
                            return str;
                        while (str.match(regExpMain)) {
                            strResult.push(RegExp.$1);
                            str = str.replace(regExpMain, _strEmpty);
                        }

                        return strResult;
                    };
                    for (; i < properties[LEXICON.l]; i++) {
                        valueArray = splitCssStyleByComma(element.css(transitionStr + '-' + properties[i]));
                        for (j = 0; j < valueArray[LEXICON.l]; j++)
                            result[j] = (result[j] ? result[j] + _strSpace : _strEmpty) + valueArray[j];
                    }
                    return result.join(', ');
                }

                /**
                 * Generates a Regular Expression which matches with a string which starts with 'os-host'.
                 * @param {boolean} withCurrClassNameOption The Regular Expression also matches if the string is the current ClassName option (multiple values splitted by space possible).
                 * @param {boolean} withOldClassNameOption The Regular Expression also matches if the string is the old ClassName option (multiple values splitted by space possible).
                 */
                function createHostClassNameRegExp(withCurrClassNameOption, withOldClassNameOption) {
                    var i;
                    var split;
                    var appendix;
                    var appendClasses = function (classes, condition) {
                        appendix = '';
                        if (condition && typeof classes == TYPES.s) {
                            split = classes.split(_strSpace);
                            for (i = 0; i < split[LEXICON.l]; i++)
                                appendix += '|' + split[i] + '$';
                            // split[i].replace(/[.*+?^${}()|[\]\\]/g, '\\$&') for escaping regex characters
                        }
                        return appendix;
                    };

                    return new RegExp(
                        '(^' + _classNameHostElement + '([-_].+|)$)' +
                        appendClasses(_classNameCache, withCurrClassNameOption) +
                        appendClasses(_oldClassName, withOldClassNameOption), 'g');
                }

                /**
                 * Calculates the host-elements inverted scale. (invertedScale = 1 / scale)
                 * @returns {{x: number, y: number}} The scale of the host-element.
                 */
                function getHostElementInvertedScale() {
                    var rect = _paddingElementNative[LEXICON.bCR]();
                    return {
                        x: _supportTransform ? 1 / (MATH.round(rect.width) / _paddingElementNative[LEXICON.oW]) || 1 : 1,
                        y: _supportTransform ? 1 / (MATH.round(rect.height) / _paddingElementNative[LEXICON.oH]) || 1 : 1
                    };
                }

                /**
                 * Checks whether the given object is a HTMLElement.
                 * @param o The object which shall be checked.
                 * @returns {boolean} True the given object is a HTMLElement, false otherwise.
                 */
                function isHTMLElement(o) {
                    var strOwnerDocument = 'ownerDocument';
                    var strHTMLElement = 'HTMLElement';
                    var wnd = o && o[strOwnerDocument] ? (o[strOwnerDocument].parentWindow || window) : window;
                    return (
                        typeof wnd[strHTMLElement] == TYPES.o ? o instanceof wnd[strHTMLElement] : //DOM2
                            o && typeof o == TYPES.o && o !== null && o.nodeType === 1 && typeof o.nodeName == TYPES.s
                    );
                }

                /**
                 * Compares 2 arrays and returns the differences between them as a array.
                 * @param a1 The first array which shall be compared.
                 * @param a2 The second array which shall be compared.
                 * @returns {Array} The differences between the two arrays.
                 */
                function getArrayDifferences(a1, a2) {
                    var a = [];
                    var diff = [];
                    var i;
                    var k;
                    for (i = 0; i < a1.length; i++)
                        a[a1[i]] = true;
                    for (i = 0; i < a2.length; i++) {
                        if (a[a2[i]])
                            delete a[a2[i]];
                        else
                            a[a2[i]] = true;
                    }
                    for (k in a)
                        diff.push(k);
                    return diff;
                }

                /**
                 * Returns Zero or the number to which the value can be parsed.
                 * @param value The value which shall be parsed.
                 * @param toFloat Indicates whether the number shall be parsed to a float.
                 */
                function parseToZeroOrNumber(value, toFloat) {
                    var num = toFloat ? parseFloat(value) : parseInt(value, 10);
                    return isNaN(num) ? 0 : num;
                }

                /**
                 * Gets several information of the textarea and returns them as a object or undefined if the browser doesn't support it.
                 * @returns {{cursorRow: Number, cursorCol, rows: Number, cols: number, wRow: number, pos: number, max : number}} or undefined if not supported.
                 */
                function getTextareaInfo() {
                    //read needed values
                    var textareaCursorPosition = _targetElementNative.selectionStart;
                    if (textareaCursorPosition === undefined)
                        return;

                    var textareaValue = _targetElement.val();
                    var textareaLength = textareaValue[LEXICON.l];
                    var textareaRowSplit = textareaValue.split('\n');
                    var textareaLastRow = textareaRowSplit[LEXICON.l];
                    var textareaCurrentCursorRowSplit = textareaValue.substr(0, textareaCursorPosition).split('\n');
                    var widestRow = 0;
                    var textareaLastCol = 0;
                    var cursorRow = textareaCurrentCursorRowSplit[LEXICON.l];
                    var cursorCol = textareaCurrentCursorRowSplit[textareaCurrentCursorRowSplit[LEXICON.l] - 1][LEXICON.l];
                    var rowCols;
                    var i;

                    //get widest Row and the last column of the textarea
                    for (i = 0; i < textareaRowSplit[LEXICON.l]; i++) {
                        rowCols = textareaRowSplit[i][LEXICON.l];
                        if (rowCols > textareaLastCol) {
                            widestRow = i + 1;
                            textareaLastCol = rowCols;
                        }
                    }

                    return {
                        _cursorRow: cursorRow, //cursorRow
                        _cursorColumn: cursorCol, //cursorCol
                        _rows: textareaLastRow, //rows
                        _columns: textareaLastCol, //cols
                        _widestRow: widestRow, //wRow
                        _cursorPosition: textareaCursorPosition, //pos
                        _cursorMax: textareaLength //max
                    };
                }

                /**
                 * Determines whether native overlay scrollbars are active.
                 * @returns {boolean} True if native overlay scrollbars are active, false otherwise.
                 */
                function nativeOverlayScrollbarsAreActive() {
                    return (_ignoreOverlayScrollbarHidingCache && (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y));
                }

                /**
                 * Gets the element which is used to measure the content size.
                 * @returns {*} TextareaCover if target element is textarea else the ContentElement.
                 */
                function getContentMeasureElement() {
                    return _isTextarea ? _textareaCoverElement[0] : _contentElementNative;
                }

                /**
                 * Generates a string which represents a HTML div with the given classes or attributes.
                 * @param classesOrAttrs The class of the div as string or a object which represents the attributes of the div. (The class attribute can also be written as "className".)
                 * @param content The content of the div as string.
                 * @returns {string} The concated string which represents a HTML div and its content.
                 */
                function generateDiv(classesOrAttrs, content) {
                    return '<div ' + (classesOrAttrs ? type(classesOrAttrs) == TYPES.s ?
                        'class="' + classesOrAttrs + '"' :
                        (function () {
                            var key;
                            var attrs = _strEmpty;
                            if (FRAMEWORK.isPlainObject(classesOrAttrs)) {
                                for (key in classesOrAttrs)
                                    attrs += (key === 'c' ? 'class' : key) + '="' + classesOrAttrs[key] + '" ';
                            }
                            return attrs;
                        })() :
                        _strEmpty) +
                        '>' +
                        (content || _strEmpty) +
                        '</div>';
                }

                /**
                 * Selects or generates a div with the given class attribute.
                 * @param className The class names (divided by spaces) of the div which shall be selected or generated.
                 * @param selectParentOrOnlyChildren The parent element from which of the element shall be selected. (if undefined or boolean its hostElement)
                 * If its a boolean it decides whether only the children of the host element shall be selected.
                 * @returns {*} The generated or selected element.
                 */
                function selectOrGenerateDivByClass(className, selectParentOrOnlyChildren) {
                    var onlyChildren = type(selectParentOrOnlyChildren) == TYPES.b;
                    var selectParent = onlyChildren ? _hostElement : (selectParentOrOnlyChildren || _hostElement);

                    return (_domExists && !selectParent[LEXICON.l])
                        ? null
                        : _domExists
                            ? selectParent[onlyChildren ? 'children' : 'find'](_strDot + className.replace(/\s/g, _strDot)).eq(0)
                            : FRAMEWORK(generateDiv(className))
                }

                /**
                 * Gets the value of the given property from the given object.
                 * @param obj The object from which the property value shall be got.
                 * @param path The property of which the value shall be got.
                 * @returns {*} Returns the value of the searched property or undefined of the property wasn't found.
                 */
                function getObjectPropVal(obj, path) {
                    var splits = path.split(_strDot);
                    var i = 0;
                    var val;
                    for (; i < splits.length; i++) {
                        if (!obj[LEXICON.hOP](splits[i]))
                            return;
                        val = obj[splits[i]];
                        if (i < splits.length && type(val) == TYPES.o)
                            obj = val;
                    }
                    return val;
                }

                /**
                 * Sets the value of the given property from the given object.
                 * @param obj The object from which the property value shall be set.
                 * @param path The property of which the value shall be set.
                 * @param val The value of the property which shall be set.
                 */
                function setObjectPropVal(obj, path, val) {
                    var splits = path.split(_strDot);
                    var splitsLength = splits.length;
                    var i = 0;
                    var extendObj = {};
                    var extendObjRoot = extendObj;
                    for (; i < splitsLength; i++)
                        extendObj = extendObj[splits[i]] = i + 1 < splitsLength ? {} : val;
                    FRAMEWORK.extend(obj, extendObjRoot, true);
                }

                /**	
                 * Runs a action for each selector inside the updateOnLoad option.	
                 * @param {Function} action The action for each updateOnLoad selector, the arguments the function takes is the index and the value (the selector).	
                 */
                function eachUpdateOnLoad(action) {
                    var updateOnLoad = _currentPreparedOptions.updateOnLoad;
                    updateOnLoad = type(updateOnLoad) == TYPES.s ? updateOnLoad.split(_strSpace) : updateOnLoad;

                    if (COMPATIBILITY.isA(updateOnLoad) && !_destroyed) {
                        each(updateOnLoad, action);
                    }
                }


                //==== Utils Cache ====//

                /**
                 * Compares two values or objects and returns true if they aren't equal.
                 * @param current The first value or object which shall be compared.
                 * @param cache The second value or object which shall be compared.
                 * @param force If true the returned value is always true.
                 * @returns {boolean} True if both values or objects aren't equal or force is true, false otherwise.
                 */
                function checkCache(current, cache, force) {
                    if (force)
                        return force;
                    if (type(current) == TYPES.o && type(cache) == TYPES.o) {
                        for (var prop in current) {
                            if (prop !== 'c') {
                                if (current[LEXICON.hOP](prop) && cache[LEXICON.hOP](prop)) {
                                    if (checkCache(current[prop], cache[prop]))
                                        return true;
                                }
                                else {
                                    return true;
                                }
                            }
                        }
                    }
                    else {
                        return current !== cache;
                    }
                    return false;
                }


                //==== Shortcuts ====//

                /**
                 * jQuery extend method shortcut with a appended "true" as first argument.
                 */
                function extendDeep() {
                    return FRAMEWORK.extend.apply(this, [true].concat([].slice.call(arguments)));
                }

                /**
                 * jQuery addClass method shortcut.
                 */
                function addClass(el, classes) {
                    return _frameworkProto.addClass.call(el, classes);
                }

                /**
                 * jQuery removeClass method shortcut.
                 */
                function removeClass(el, classes) {
                    return _frameworkProto.removeClass.call(el, classes);
                }

                /**
                 * Adds or removes the given classes dependent on the boolean value. True for add, false for remove.
                 */
                function addRemoveClass(el, classes, doAdd) {
                    return doAdd ? addClass(el, classes) : removeClass(el, classes);
                }

                /**
                 * jQuery remove method shortcut.
                 */
                function remove(el) {
                    return _frameworkProto.remove.call(el);
                }

                /**
                 * Finds the first child element with the given selector of the given element.
                 * @param el The root element from which the selector shall be valid.
                 * @param selector The selector of the searched element.
                 * @returns {*} The first element which is a child of the given element and matches the givens selector.
                 */
                function findFirst(el, selector) {
                    return _frameworkProto.find.call(el, selector).eq(0);
                }


                //==== API ====//

                /**
                 * Puts the instance to sleep. It wont respond to any changes in the DOM and won't update. Scrollbar Interactivity is also disabled as well as the resize handle.
                 * This behavior can be reset by calling the update method.
                 */
                _base.sleep = function () {
                    _sleeping = true;
                };

                /**
                 * Updates the plugin and DOM to the current options.
                 * This method should only be called if a update is 100% required.
                 * @param force True if every property shall be updated and the cache shall be ignored.
                 * !INTERNAL USAGE! : force can be a string "auto", "sync" or "zoom" too
                 * if "auto" then before a real update the content size and host element attributes gets checked, and if they changed only then the update method will be called.
                 * if "sync" then the async update process (MutationObserver or UpdateLoop) gets synchronized and a corresponding update takes place if one was needed due to pending changes.
                 * if "zoom" then a update takes place where it's assumed that content and host size changed
                 * @returns {boolean|undefined} 
                 * If force is "sync" then a boolean is returned which indicates whether a update was needed due to pending changes.
                 * If force is "auto" then a boolean is returned whether a update was needed due to attribute or size changes.
                 * undefined otherwise.
                 */
                _base.update = function (force) {
                    if (_destroyed)
                        return;

                    var attrsChanged;
                    var contentSizeC;
                    var isString = type(force) == TYPES.s;
                    var doUpdateAuto;
                    var mutHost;
                    var mutContent;

                    if (isString) {
                        if (force === _strAuto) {
                            attrsChanged = meaningfulAttrsChanged();
                            contentSizeC = updateAutoContentSizeChanged();
                            doUpdateAuto = attrsChanged || contentSizeC;
                            if (doUpdateAuto) {
                                update({
                                    _contentSizeChanged: contentSizeC,
                                    _changedOptions: _initialized ? undefined : _currentPreparedOptions
                                });
                            }
                        }
                        else if (force === _strSync) {
                            if (_mutationObserversConnected) {
                                mutHost = _mutationObserverHostCallback(_mutationObserverHost.takeRecords());
                                mutContent = _mutationObserverContentCallback(_mutationObserverContent.takeRecords());
                            }
                            else {
                                mutHost = _base.update(_strAuto);
                            }
                        }
                        else if (force === 'zoom') {
                            update({
                                _hostSizeChanged: true,
                                _contentSizeChanged: true
                            });
                        }
                    }
                    else {
                        force = _sleeping || force;
                        _sleeping = false;
                        if (!_base.update(_strSync) || force)
                            update({ _force: force });
                    }

                    updateElementsOnLoad();

                    return doUpdateAuto || mutHost || mutContent;
                };

                /**
                 Gets or sets the current options. The update method will be called automatically if new options were set.
                 * @param newOptions If new options are given, then the new options will be set, if new options aren't given (undefined or a not a plain object) then the current options will be returned.
                 * @param value If new options is a property path string, then this value will be used to set the option to which the property path string leads.
                 * @returns {*}
                 */
                _base.options = function (newOptions, value) {
                    var option = {};
                    var changedOps;

                    //return current options if newOptions are undefined or empty
                    if (FRAMEWORK.isEmptyObject(newOptions) || !FRAMEWORK.isPlainObject(newOptions)) {
                        if (type(newOptions) == TYPES.s) {
                            if (arguments.length > 1) {
                                setObjectPropVal(option, newOptions, value);
                                changedOps = setOptions(option);
                            }
                            else
                                return getObjectPropVal(_currentOptions, newOptions);
                        }
                        else
                            return _currentOptions;
                    }
                    else {
                        changedOps = setOptions(newOptions);
                    }

                    if (!FRAMEWORK.isEmptyObject(changedOps)) {
                        update({ _changedOptions: changedOps });
                    }
                };

                /**
                 * Restore the DOM, disconnects all observers, remove all resize observers and put the instance to sleep.
                 */
                _base.destroy = function () {
                    if (_destroyed)
                        return;

                    //remove this instance from auto update loop
                    autoUpdateLoop.remove(_base);

                    //disconnect all mutation observers
                    disconnectMutationObservers();

                    //remove all resize observers
                    setupResizeObserver(_sizeObserverElement);
                    setupResizeObserver(_sizeAutoObserverElement);

                    //remove all extensions
                    for (var extName in _extensions)
                        _base.removeExt(extName);

                    //remove all 'destroy' events
                    while (_destroyEvents[LEXICON.l] > 0)
                        _destroyEvents.pop()();

                    //remove all events from host element
                    setupHostMouseTouchEvents(true);

                    //remove all helper / detection elements
                    if (_contentGlueElement)
                        remove(_contentGlueElement);
                    if (_contentArrangeElement)
                        remove(_contentArrangeElement);
                    if (_sizeAutoObserverAdded)
                        remove(_sizeAutoObserverElement);

                    //remove all generated DOM
                    setupScrollbarsDOM(true);
                    setupScrollbarCornerDOM(true);
                    setupStructureDOM(true);

                    //remove all generated image load events
                    for (var i = 0; i < _updateOnLoadElms[LEXICON.l]; i++)
                        FRAMEWORK(_updateOnLoadElms[i]).off(_updateOnLoadEventName, updateOnLoadCallback);
                    _updateOnLoadElms = undefined;

                    _destroyed = true;
                    _sleeping = true;

                    //remove this instance from the instances list
                    INSTANCES(pluginTargetElement, 0);
                    dispatchCallback('onDestroyed');

                    //remove all properties and methods
                    //for (var property in _base)
                    //    delete _base[property];
                    //_base = undefined;
                };

                /**
                 * Scrolls to a given position or element.
                 * @param coordinates
                 * 1. Can be "coordinates" which looks like:
                 *    { x : ?, y : ? } OR          Object with x and y properties
                 *    { left : ?, top : ? } OR     Object with left and top properties
                 *    { l : ?, t : ? } OR          Object with l and t properties
                 *    [ ?, ? ] OR                  Array where the first two element are the coordinates (first is x, second is y)
                 *    ?                            A single value which stays for both axis
                 *    A value can be a number, a string or a calculation.
                 *
                 *    Operators:
                 *    [NONE]  The current scroll will be overwritten by the value.
                 *    '+='    The value will be added to the current scroll offset
                 *    '-='    The value will be subtracted from the current scroll offset
                 *    '*='    The current scroll wil be multiplicated by the value.
                 *    '/='    The current scroll wil be divided by the value.
                 *
                 *    Units:
                 *    [NONE]  The value is the final scroll amount.                   final = (value * 1)
                 *    'px'    Same as none
                 *    '%'     The value is dependent on the current scroll value.     final = ((currentScrollValue / 100) * value)
                 *    'vw'    The value is multiplicated by the viewport width.       final = (value * viewportWidth)
                 *    'vh'    The value is multiplicated by the viewport height.      final = (value * viewportHeight)
                 *
                 *    example final values:
                 *    200, '200px', '50%', '1vw', '1vh', '+=200', '/=1vw', '*=2px', '-=5vh', '+=33%', '+= 50% - 2px', '-= 1vw - 50%'
                 *
                 * 2. Can be a HTML or jQuery element:
                 *    The final scroll offset is the offset (without margin) of the given HTML / jQuery element.
                 *
                 * 3. Can be a object with a HTML or jQuery element with additional settings:
                 *    {
                 *      el : [HTMLElement, jQuery element],             MUST be specified, else this object isn't valid.
                 *      scroll : [string, array, object],               Default value is 'always'.
                 *      block : [string, array, object],                Default value is 'begin'.
                 *      margin : [number, boolean, array, object]       Default value is false.
                 *    }
                 *
                 *    Possible scroll settings are:
                 *    'always'      Scrolls always.
                 *    'ifneeded'    Scrolls only if the element isnt fully in view.
                 *    'never'       Scrolls never.
                 *
                 *    Possible block settings are:
                 *    'begin'   Both axis shall be docked to the "begin" edge. - The element will be docked to the top and left edge of the viewport.
                 *    'end'     Both axis shall be docked to the "end" edge. - The element will be docked to the bottom and right edge of the viewport. (If direction is RTL to the bottom and left edge.)
                 *    'center'  Both axis shall be docked to "center". - The element will be centered in the viewport.
                 *    'nearest' The element will be docked to the nearest edge(s).
                 *
                 *    Possible margin settings are: -- The actual margin of the element wont be affect, this option affects only the final scroll offset.
                 *    [BOOLEAN]                                         If true the css margin of the element will be used, if false no margin will be used.
                 *    [NUMBER]                                          The margin will be used for all edges.
                 *
                 * @param duration The duration of the scroll animation, OR a jQuery animation configuration object.
                 * @param easing The animation easing.
                 * @param complete The animation complete callback.
                 * @returns {{
                 *   position: {x: number, y: number},
                 *   ratio: {x: number, y: number},
                 *   max: {x: number, y: number},
                 *   handleOffset: {x: number, y: number},
                 *   handleLength: {x: number, y: number},
                 *   handleLengthRatio: {x: number, y: number}, t
                 *   rackLength: {x: number, y: number},
                 *   isRTL: boolean,
                 *   isRTLNormalized: boolean
                 *  }}
                 */
                _base.scroll = function (coordinates, duration, easing, complete) {
                    if (arguments.length === 0 || coordinates === undefined) {
                        var infoX = _scrollHorizontalInfo;
                        var infoY = _scrollVerticalInfo;
                        var normalizeInvert = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.i;
                        var normalizeNegate = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.n;
                        var scrollX = infoX._currentScroll;
                        var scrollXRatio = infoX._currentScrollRatio;
                        var maxScrollX = infoX._maxScroll;
                        scrollXRatio = normalizeInvert ? 1 - scrollXRatio : scrollXRatio;
                        scrollX = normalizeInvert ? maxScrollX - scrollX : scrollX;
                        scrollX *= normalizeNegate ? -1 : 1;
                        maxScrollX *= normalizeNegate ? -1 : 1;

                        return {
                            position: {
                                x: scrollX,
                                y: infoY._currentScroll
                            },
                            ratio: {
                                x: scrollXRatio,
                                y: infoY._currentScrollRatio
                            },
                            max: {
                                x: maxScrollX,
                                y: infoY._maxScroll
                            },
                            handleOffset: {
                                x: infoX._handleOffset,
                                y: infoY._handleOffset
                            },
                            handleLength: {
                                x: infoX._handleLength,
                                y: infoY._handleLength
                            },
                            handleLengthRatio: {
                                x: infoX._handleLengthRatio,
                                y: infoY._handleLengthRatio
                            },
                            trackLength: {
                                x: infoX._trackLength,
                                y: infoY._trackLength
                            },
                            snappedHandleOffset: {
                                x: infoX._snappedHandleOffset,
                                y: infoY._snappedHandleOffset
                            },
                            isRTL: _isRTL,
                            isRTLNormalized: _normalizeRTLCache
                        };
                    }

                    _base.update(_strSync);

                    var normalizeRTL = _normalizeRTLCache;
                    var coordinatesXAxisProps = [_strX, _strLeft, 'l'];
                    var coordinatesYAxisProps = [_strY, _strTop, 't'];
                    var coordinatesOperators = ['+=', '-=', '*=', '/='];
                    var durationIsObject = type(duration) == TYPES.o;
                    var completeCallback = durationIsObject ? duration.complete : complete;
                    var i;
                    var finalScroll = {};
                    var specialEasing = {};
                    var doScrollLeft;
                    var doScrollTop;
                    var animationOptions;
                    var strEnd = 'end';
                    var strBegin = 'begin';
                    var strCenter = 'center';
                    var strNearest = 'nearest';
                    var strAlways = 'always';
                    var strNever = 'never';
                    var strIfNeeded = 'ifneeded';
                    var strLength = LEXICON.l;
                    var settingsAxis;
                    var settingsScroll;
                    var settingsBlock;
                    var settingsMargin;
                    var finalElement;
                    var elementObjSettingsAxisValues = [_strX, _strY, 'xy', 'yx'];
                    var elementObjSettingsBlockValues = [strBegin, strEnd, strCenter, strNearest];
                    var elementObjSettingsScrollValues = [strAlways, strNever, strIfNeeded];
                    var coordinatesIsElementObj = coordinates[LEXICON.hOP]('el');
                    var possibleElement = coordinatesIsElementObj ? coordinates.el : coordinates;
                    var possibleElementIsJQuery = possibleElement instanceof FRAMEWORK || JQUERY ? possibleElement instanceof JQUERY : false;
                    var possibleElementIsHTMLElement = possibleElementIsJQuery ? false : isHTMLElement(possibleElement);
                    var updateScrollbarInfos = function () {
                        if (doScrollLeft)
                            refreshScrollbarHandleOffset(true);
                        if (doScrollTop)
                            refreshScrollbarHandleOffset(false);
                    };
                    var proxyCompleteCallback = type(completeCallback) != TYPES.f ? undefined : function () {
                        updateScrollbarInfos();
                        completeCallback();
                    };
                    function checkSettingsStringValue(currValue, allowedValues) {
                        for (i = 0; i < allowedValues[strLength]; i++) {
                            if (currValue === allowedValues[i])
                                return true;
                        }
                        return false;
                    }
                    function getRawScroll(isX, coordinates) {
                        var coordinateProps = isX ? coordinatesXAxisProps : coordinatesYAxisProps;
                        coordinates = type(coordinates) == TYPES.s || type(coordinates) == TYPES.n ? [coordinates, coordinates] : coordinates;

                        if (COMPATIBILITY.isA(coordinates))
                            return isX ? coordinates[0] : coordinates[1];
                        else if (type(coordinates) == TYPES.o) {
                            //decides RTL normalization "hack" with .n
                            //normalizeRTL = type(coordinates.n) == TYPES.b ? coordinates.n : normalizeRTL; 
                            for (i = 0; i < coordinateProps[strLength]; i++)
                                if (coordinateProps[i] in coordinates)
                                    return coordinates[coordinateProps[i]];
                        }
                    }
                    function getFinalScroll(isX, rawScroll) {
                        var isString = type(rawScroll) == TYPES.s;
                        var operator;
                        var amount;
                        var scrollInfo = isX ? _scrollHorizontalInfo : _scrollVerticalInfo;
                        var currScroll = scrollInfo._currentScroll;
                        var maxScroll = scrollInfo._maxScroll;
                        var mult = ' * ';
                        var finalValue;
                        var isRTLisX = _isRTL && isX;
                        var normalizeShortcuts = isRTLisX && _rtlScrollBehavior.n && !normalizeRTL;
                        var strReplace = 'replace';
                        var evalFunc = eval;
                        var possibleOperator;
                        if (isString) {
                            //check operator
                            if (rawScroll[strLength] > 2) {
                                possibleOperator = rawScroll.substr(0, 2);
                                if (inArray(possibleOperator, coordinatesOperators) > -1)
                                    operator = possibleOperator;
                            }

                            //calculate units and shortcuts
                            rawScroll = operator ? rawScroll.substr(2) : rawScroll;
                            rawScroll = rawScroll
                            [strReplace](/min/g, 0) //'min' = 0%
                            [strReplace](/</g, 0)   //'<'   = 0%
                            [strReplace](/max/g, (normalizeShortcuts ? '-' : _strEmpty) + _strHundredPercent)    //'max' = 100%
                            [strReplace](/>/g, (normalizeShortcuts ? '-' : _strEmpty) + _strHundredPercent)      //'>'   = 100%
                            [strReplace](/px/g, _strEmpty)
                            [strReplace](/%/g, mult + (maxScroll * (isRTLisX && _rtlScrollBehavior.n ? -1 : 1) / 100.0))
                            [strReplace](/vw/g, mult + _viewportSize.w)
                            [strReplace](/vh/g, mult + _viewportSize.h);
                            amount = parseToZeroOrNumber(isNaN(rawScroll) ? parseToZeroOrNumber(evalFunc(rawScroll), true).toFixed() : rawScroll);
                        }
                        else {
                            amount = rawScroll;
                        }

                        if (amount !== undefined && !isNaN(amount) && type(amount) == TYPES.n) {
                            var normalizeIsRTLisX = normalizeRTL && isRTLisX;
                            var operatorCurrScroll = currScroll * (normalizeIsRTLisX && _rtlScrollBehavior.n ? -1 : 1);
                            var invert = normalizeIsRTLisX && _rtlScrollBehavior.i;
                            var negate = normalizeIsRTLisX && _rtlScrollBehavior.n;
                            operatorCurrScroll = invert ? (maxScroll - operatorCurrScroll) : operatorCurrScroll;
                            switch (operator) {
                                case '+=':
                                    finalValue = operatorCurrScroll + amount;
                                    break;
                                case '-=':
                                    finalValue = operatorCurrScroll - amount;
                                    break;
                                case '*=':
                                    finalValue = operatorCurrScroll * amount;
                                    break;
                                case '/=':
                                    finalValue = operatorCurrScroll / amount;
                                    break;
                                default:
                                    finalValue = amount;
                                    break;
                            }
                            finalValue = invert ? maxScroll - finalValue : finalValue;
                            finalValue *= negate ? -1 : 1;
                            finalValue = isRTLisX && _rtlScrollBehavior.n ? MATH.min(0, MATH.max(maxScroll, finalValue)) : MATH.max(0, MATH.min(maxScroll, finalValue));
                        }
                        return finalValue === currScroll ? undefined : finalValue;
                    }
                    function getPerAxisValue(value, valueInternalType, defaultValue, allowedValues) {
                        var resultDefault = [defaultValue, defaultValue];
                        var valueType = type(value);
                        var valueArrLength;
                        var valueArrItem;

                        //value can be [ string, or array of two strings ]
                        if (valueType == valueInternalType) {
                            value = [value, value];
                        }
                        else if (valueType == TYPES.a) {
                            valueArrLength = value[strLength];
                            if (valueArrLength > 2 || valueArrLength < 1)
                                value = resultDefault;
                            else {
                                if (valueArrLength === 1)
                                    value[1] = defaultValue;
                                for (i = 0; i < valueArrLength; i++) {
                                    valueArrItem = value[i];
                                    if (type(valueArrItem) != valueInternalType || !checkSettingsStringValue(valueArrItem, allowedValues)) {
                                        value = resultDefault;
                                        break;
                                    }
                                }
                            }
                        }
                        else if (valueType == TYPES.o)
                            value = [value[_strX] || defaultValue, value[_strY] || defaultValue];
                        else
                            value = resultDefault;
                        return { x: value[0], y: value[1] };
                    }
                    function generateMargin(marginTopRightBottomLeftArray) {
                        var result = [];
                        var currValue;
                        var currValueType;
                        var valueDirections = [_strTop, _strRight, _strBottom, _strLeft];
                        for (i = 0; i < marginTopRightBottomLeftArray[strLength]; i++) {
                            if (i === valueDirections[strLength])
                                break;
                            currValue = marginTopRightBottomLeftArray[i];
                            currValueType = type(currValue);
                            if (currValueType == TYPES.b)
                                result.push(currValue ? parseToZeroOrNumber(finalElement.css(_strMarginMinus + valueDirections[i])) : 0);
                            else
                                result.push(currValueType == TYPES.n ? currValue : 0);
                        }
                        return result;
                    }

                    if (possibleElementIsJQuery || possibleElementIsHTMLElement) {
                        //get settings
                        var margin = coordinatesIsElementObj ? coordinates.margin : 0;
                        var axis = coordinatesIsElementObj ? coordinates.axis : 0;
                        var scroll = coordinatesIsElementObj ? coordinates.scroll : 0;
                        var block = coordinatesIsElementObj ? coordinates.block : 0;
                        var marginDefault = [0, 0, 0, 0];
                        var marginType = type(margin);
                        var marginLength;
                        finalElement = possibleElementIsJQuery ? possibleElement : FRAMEWORK(possibleElement);

                        if (finalElement[strLength] > 0) {
                            //margin can be [ boolean, number, array of 2, array of 4, object ]
                            if (marginType == TYPES.n || marginType == TYPES.b)
                                margin = generateMargin([margin, margin, margin, margin]);
                            else if (marginType == TYPES.a) {
                                marginLength = margin[strLength];
                                if (marginLength === 2)
                                    margin = generateMargin([margin[0], margin[1], margin[0], margin[1]]);
                                else if (marginLength >= 4)
                                    margin = generateMargin(margin);
                                else
                                    margin = marginDefault;
                            }
                            else if (marginType == TYPES.o)
                                margin = generateMargin([margin[_strTop], margin[_strRight], margin[_strBottom], margin[_strLeft]]);
                            else
                                margin = marginDefault;

                            //block = type(block) === TYPES.b ? block ? [ strNearest, strBegin ] : [ strNearest, strEnd ] : block;
                            settingsAxis = checkSettingsStringValue(axis, elementObjSettingsAxisValues) ? axis : 'xy';
                            settingsScroll = getPerAxisValue(scroll, TYPES.s, strAlways, elementObjSettingsScrollValues);
                            settingsBlock = getPerAxisValue(block, TYPES.s, strBegin, elementObjSettingsBlockValues);
                            settingsMargin = margin;

                            var viewportScroll = {
                                l: _scrollHorizontalInfo._currentScroll,
                                t: _scrollVerticalInfo._currentScroll
                            };
                            // use padding element instead of viewport element because padding element has never padding, margin or position applied.
                            var viewportOffset = _paddingElement.offset();

                            //get coordinates
                            var elementOffset = finalElement.offset();
                            var doNotScroll = {
                                x: settingsScroll.x == strNever || settingsAxis == _strY,
                                y: settingsScroll.y == strNever || settingsAxis == _strX
                            };
                            elementOffset[_strTop] -= settingsMargin[0];
                            elementOffset[_strLeft] -= settingsMargin[3];
                            var elementScrollCoordinates = {
                                x: MATH.round(elementOffset[_strLeft] - viewportOffset[_strLeft] + viewportScroll.l),
                                y: MATH.round(elementOffset[_strTop] - viewportOffset[_strTop] + viewportScroll.t)
                            };
                            if (_isRTL) {
                                if (!_rtlScrollBehavior.n && !_rtlScrollBehavior.i)
                                    elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + viewportScroll.l);
                                if (_rtlScrollBehavior.n && normalizeRTL)
                                    elementScrollCoordinates.x *= -1;
                                if (_rtlScrollBehavior.i && normalizeRTL)
                                    elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + (_scrollHorizontalInfo._maxScroll - viewportScroll.l));
                            }

                            //measuring is required
                            if (settingsBlock.x != strBegin || settingsBlock.y != strBegin || settingsScroll.x == strIfNeeded || settingsScroll.y == strIfNeeded || _isRTL) {
                                var measuringElm = finalElement[0];
                                var rawElementSize = _supportTransform ? measuringElm[LEXICON.bCR]() : {
                                    width: measuringElm[LEXICON.oW],
                                    height: measuringElm[LEXICON.oH]
                                };
                                var elementSize = {
                                    w: rawElementSize[_strWidth] + settingsMargin[3] + settingsMargin[1],
                                    h: rawElementSize[_strHeight] + settingsMargin[0] + settingsMargin[2]
                                };
                                var finalizeBlock = function (isX) {
                                    var vars = getScrollbarVars(isX);
                                    var wh = vars._w_h;
                                    var lt = vars._left_top;
                                    var xy = vars._x_y;
                                    var blockIsEnd = settingsBlock[xy] == (isX ? _isRTL ? strBegin : strEnd : strEnd);
                                    var blockIsCenter = settingsBlock[xy] == strCenter;
                                    var blockIsNearest = settingsBlock[xy] == strNearest;
                                    var scrollNever = settingsScroll[xy] == strNever;
                                    var scrollIfNeeded = settingsScroll[xy] == strIfNeeded;
                                    var vpSize = _viewportSize[wh];
                                    var vpOffset = viewportOffset[lt];
                                    var elSize = elementSize[wh];
                                    var elOffset = elementOffset[lt];
                                    var divide = blockIsCenter ? 2 : 1;
                                    var elementCenterOffset = elOffset + (elSize / 2);
                                    var viewportCenterOffset = vpOffset + (vpSize / 2);
                                    var isInView =
                                        elSize <= vpSize
                                        && elOffset >= vpOffset
                                        && elOffset + elSize <= vpOffset + vpSize;

                                    if (scrollNever)
                                        doNotScroll[xy] = true;
                                    else if (!doNotScroll[xy]) {
                                        if (blockIsNearest || scrollIfNeeded) {
                                            doNotScroll[xy] = scrollIfNeeded ? isInView : false;
                                            blockIsEnd = elSize < vpSize ? elementCenterOffset > viewportCenterOffset : elementCenterOffset < viewportCenterOffset;
                                        }
                                        elementScrollCoordinates[xy] -= blockIsEnd || blockIsCenter ? ((vpSize / divide) - (elSize / divide)) * (isX && _isRTL && normalizeRTL ? -1 : 1) : 0;
                                    }
                                };
                                finalizeBlock(true);
                                finalizeBlock(false);
                            }

                            if (doNotScroll.y)
                                delete elementScrollCoordinates.y;
                            if (doNotScroll.x)
                                delete elementScrollCoordinates.x;

                            coordinates = elementScrollCoordinates;
                        }
                    }

                    finalScroll[_strScrollLeft] = getFinalScroll(true, getRawScroll(true, coordinates));
                    finalScroll[_strScrollTop] = getFinalScroll(false, getRawScroll(false, coordinates));
                    doScrollLeft = finalScroll[_strScrollLeft] !== undefined;
                    doScrollTop = finalScroll[_strScrollTop] !== undefined;

                    if ((doScrollLeft || doScrollTop) && (duration > 0 || durationIsObject)) {
                        if (durationIsObject) {
                            duration.complete = proxyCompleteCallback;
                            _viewportElement.animate(finalScroll, duration);
                        }
                        else {
                            animationOptions = {
                                duration: duration,
                                complete: proxyCompleteCallback
                            };
                            if (COMPATIBILITY.isA(easing) || FRAMEWORK.isPlainObject(easing)) {
                                specialEasing[_strScrollLeft] = easing[0] || easing.x;
                                specialEasing[_strScrollTop] = easing[1] || easing.y;
                                animationOptions.specialEasing = specialEasing;
                            }
                            else {
                                animationOptions.easing = easing;
                            }
                            _viewportElement.animate(finalScroll, animationOptions);
                        }
                    }
                    else {
                        if (doScrollLeft)
                            _viewportElement[_strScrollLeft](finalScroll[_strScrollLeft]);
                        if (doScrollTop)
                            _viewportElement[_strScrollTop](finalScroll[_strScrollTop]);
                        updateScrollbarInfos();
                    }
                };

                /**
                 * Stops all scroll animations.
                 * @returns {*} The current OverlayScrollbars instance (for chaining).
                 */
                _base.scrollStop = function (param1, param2, param3) {
                    _viewportElement.stop(param1, param2, param3);
                    return _base;
                };

                /**
                 * Returns all relevant elements.
                 * @param elementName The name of the element which shall be returned.
                 * @returns {{target: *, host: *, padding: *, viewport: *, content: *, scrollbarHorizontal: {scrollbar: *, track: *, handle: *}, scrollbarVertical: {scrollbar: *, track: *, handle: *}, scrollbarCorner: *} | *}
                 */
                _base.getElements = function (elementName) {
                    var obj = {
                        target: _targetElementNative,
                        host: _hostElementNative,
                        padding: _paddingElementNative,
                        viewport: _viewportElementNative,
                        content: _contentElementNative,
                        scrollbarHorizontal: {
                            scrollbar: _scrollbarHorizontalElement[0],
                            track: _scrollbarHorizontalTrackElement[0],
                            handle: _scrollbarHorizontalHandleElement[0]
                        },
                        scrollbarVertical: {
                            scrollbar: _scrollbarVerticalElement[0],
                            track: _scrollbarVerticalTrackElement[0],
                            handle: _scrollbarVerticalHandleElement[0]
                        },
                        scrollbarCorner: _scrollbarCornerElement[0]
                    };
                    return type(elementName) == TYPES.s ? getObjectPropVal(obj, elementName) : obj;
                };

                /**
                 * Returns a object which describes the current state of this instance.
                 * @param stateProperty A specific property from the state object which shall be returned.
                 * @returns {{widthAuto, heightAuto, overflowAmount, hideOverflow, hasOverflow, contentScrollSize, viewportSize, hostSize, autoUpdate} | *}
                 */
                _base.getState = function (stateProperty) {
                    function prepare(obj) {
                        if (!FRAMEWORK.isPlainObject(obj))
                            return obj;
                        var extended = extendDeep({}, obj);
                        var changePropertyName = function (from, to) {
                            if (extended[LEXICON.hOP](from)) {
                                extended[to] = extended[from];
                                delete extended[from];
                            }
                        };
                        changePropertyName('w', _strWidth); //change w to width
                        changePropertyName('h', _strHeight); //change h to height
                        delete extended.c; //delete c (the 'changed' prop)
                        return extended;
                    };
                    var obj = {
                        destroyed: !!prepare(_destroyed),
                        sleeping: !!prepare(_sleeping),
                        autoUpdate: prepare(!_mutationObserversConnected),
                        widthAuto: prepare(_widthAutoCache),
                        heightAuto: prepare(_heightAutoCache),
                        padding: prepare(_cssPaddingCache),
                        overflowAmount: prepare(_overflowAmountCache),
                        hideOverflow: prepare(_hideOverflowCache),
                        hasOverflow: prepare(_hasOverflowCache),
                        contentScrollSize: prepare(_contentScrollSizeCache),
                        viewportSize: prepare(_viewportSize),
                        hostSize: prepare(_hostSizeCache),
                        documentMixed: prepare(_documentMixed)
                    };
                    return type(stateProperty) == TYPES.s ? getObjectPropVal(obj, stateProperty) : obj;
                };

                /**
                 * Gets all or specific extension instance.
                 * @param extName The name of the extension from which the instance shall be got.
                 * @returns {{}} The instance of the extension with the given name or undefined if the instance couldn't be found.
                 */
                _base.ext = function (extName) {
                    var result;
                    var privateMethods = _extensionsPrivateMethods.split(' ');
                    var i = 0;
                    if (type(extName) == TYPES.s) {
                        if (_extensions[LEXICON.hOP](extName)) {
                            result = extendDeep({}, _extensions[extName]);
                            for (; i < privateMethods.length; i++)
                                delete result[privateMethods[i]];
                        }
                    }
                    else {
                        result = {};
                        for (i in _extensions)
                            result[i] = extendDeep({}, _base.ext(i));
                    }
                    return result;
                };

                /**
                 * Adds a extension to this instance.
                 * @param extName The name of the extension which shall be added.
                 * @param extensionOptions The extension options which shall be used.
                 * @returns {{}} The instance of the added extension or undefined if the extension couldn't be added properly.
                 */
                _base.addExt = function (extName, extensionOptions) {
                    var registeredExtensionObj = _plugin.extension(extName);
                    var instance;
                    var instanceAdded;
                    var instanceContract;
                    var contractResult;
                    var contractFulfilled = true;
                    if (registeredExtensionObj) {
                        if (!_extensions[LEXICON.hOP](extName)) {
                            instance = registeredExtensionObj.extensionFactory.call(_base,
                                extendDeep({}, registeredExtensionObj.defaultOptions),
                                FRAMEWORK,
                                COMPATIBILITY);

                            if (instance) {
                                instanceContract = instance.contract;
                                if (type(instanceContract) == TYPES.f) {
                                    contractResult = instanceContract(window);
                                    contractFulfilled = type(contractResult) == TYPES.b ? contractResult : contractFulfilled;
                                }
                                if (contractFulfilled) {
                                    _extensions[extName] = instance;
                                    instanceAdded = instance.added;
                                    if (type(instanceAdded) == TYPES.f)
                                        instanceAdded(extensionOptions);

                                    return _base.ext(extName);
                                }
                            }
                        }
                        else
                            return _base.ext(extName);
                    }
                    else
                        console.warn("A extension with the name \"" + extName + "\" isn't registered.");
                };

                /**
                 * Removes a extension from this instance.
                 * @param extName The name of the extension which shall be removed.
                 * @returns {boolean} True if the extension was removed, false otherwise e.g. if the extension wasn't added before.
                 */
                _base.removeExt = function (extName) {
                    var instance = _extensions[extName];
                    var instanceRemoved;
                    if (instance) {
                        delete _extensions[extName];

                        instanceRemoved = instance.removed;
                        if (type(instanceRemoved) == TYPES.f)
                            instanceRemoved();

                        return true;
                    }
                    return false;
                };

                /**
                 * Constructs the plugin.
                 * @param targetElement The element to which the plugin shall be applied.
                 * @param options The initial options of the plugin.
                 * @param extensions The extension(s) which shall be added right after the initialization.
                 * @returns {boolean} True if the plugin was successfully initialized, false otherwise.
                 */
                function construct(targetElement, options, extensions) {
                    _defaultOptions = globals.defaultOptions;
                    _nativeScrollbarStyling = globals.nativeScrollbarStyling;
                    _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);
                    _nativeScrollbarIsOverlaid = extendDeep({}, globals.nativeScrollbarIsOverlaid);
                    _overlayScrollbarDummySize = extendDeep({}, globals.overlayScrollbarDummySize);
                    _rtlScrollBehavior = extendDeep({}, globals.rtlScrollBehavior);

                    //parse & set options but don't update
                    setOptions(extendDeep({}, _defaultOptions, options));

                    _cssCalc = globals.cssCalc;
                    _msieVersion = globals.msie;
                    _autoUpdateRecommended = globals.autoUpdateRecommended;
                    _supportTransition = globals.supportTransition;
                    _supportTransform = globals.supportTransform;
                    _supportPassiveEvents = globals.supportPassiveEvents;
                    _supportResizeObserver = globals.supportResizeObserver;
                    _supportMutationObserver = globals.supportMutationObserver;
                    _restrictedMeasuring = globals.restrictedMeasuring;
                    _documentElement = FRAMEWORK(targetElement.ownerDocument);
                    _documentElementNative = _documentElement[0];
                    _windowElement = FRAMEWORK(_documentElementNative.defaultView || _documentElementNative.parentWindow);
                    _windowElementNative = _windowElement[0];
                    _htmlElement = findFirst(_documentElement, 'html');
                    _bodyElement = findFirst(_htmlElement, 'body');
                    _targetElement = FRAMEWORK(targetElement);
                    _targetElementNative = _targetElement[0];
                    _isTextarea = _targetElement.is('textarea');
                    _isBody = _targetElement.is('body');
                    _documentMixed = _documentElementNative !== document;

                    /* On a div Element The if checks only whether:
                     * - the targetElement has the class "os-host"
                     * - the targetElement has a a child with the class "os-padding"
                     * 
                     * If that's the case, its assumed the DOM has already the following structure:
                     * (The ".os-host" element is the targetElement)
                     *
                     *  <div class="os-host">
                     *      <div class="os-resize-observer-host"></div>
                     *      <div class="os-padding">
                     *          <div class="os-viewport">
                     *              <div class="os-content"></div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar os-scrollbar-horizontal ">
                     *          <div class="os-scrollbar-track">
                     *              <div class="os-scrollbar-handle"></div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar os-scrollbar-vertical">
                     *          <div class="os-scrollbar-track">
                     *              <div class="os-scrollbar-handle"></div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar-corner"></div>
                     *  </div>
                     *
                     * =====================================================================================
                     * 
                     * On a Textarea Element The if checks only whether:
                     * - the targetElement has the class "os-textarea" 
                     * - the targetElement is inside a element with the class "os-content" 
                     * 
                     * If that's the case, its assumed the DOM has already the following structure:
                     * (The ".os-textarea" (textarea) element is the targetElement)
                     *
                     *  <div class="os-host-textarea">
                     *      <div class="os-resize-observer-host"></div>
                     *      <div class="os-padding os-text-inherit">
                     *          <div class="os-viewport os-text-inherit">
                     *              <div class="os-content os-text-inherit">
                     *                  <div class="os-textarea-cover"></div>
                     *                  <textarea class="os-textarea os-text-inherit"></textarea>
                     *              </div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar os-scrollbar-horizontal ">
                     *          <div class="os-scrollbar-track">
                     *              <div class="os-scrollbar-handle"></div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar os-scrollbar-vertical">
                     *          <div class="os-scrollbar-track">
                     *              <div class="os-scrollbar-handle"></div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar-corner"></div>
                     *  </div>
                     */
                    _domExists = _isTextarea
                        ? _targetElement.hasClass(_classNameTextareaElement) && _targetElement.parent().hasClass(_classNameContentElement)
                        : _targetElement.hasClass(_classNameHostElement) && _targetElement.children(_strDot + _classNamePaddingElement)[LEXICON.l];

                    var initBodyScroll;
                    var bodyMouseTouchDownListener;

                    //check if the plugin hasn't to be initialized
                    if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y && !_currentPreparedOptions.nativeScrollbarsOverlaid.initialize) {
                        dispatchCallback('onInitializationWithdrawn');
                        if (_domExists) {
                            setupStructureDOM(true);
                            setupScrollbarsDOM(true);
                            setupScrollbarCornerDOM(true);
                        }

                        _destroyed = true;
                        _sleeping = true;

                        return _base;
                    }

                    if (_isBody) {
                        initBodyScroll = {};
                        initBodyScroll.l = MATH.max(_targetElement[_strScrollLeft](), _htmlElement[_strScrollLeft](), _windowElement[_strScrollLeft]());
                        initBodyScroll.t = MATH.max(_targetElement[_strScrollTop](), _htmlElement[_strScrollTop](), _windowElement[_strScrollTop]());

                        bodyMouseTouchDownListener = function () {
                            _viewportElement.removeAttr(LEXICON.ti);
                            setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, true, true);
                        }
                    }

                    //build OverlayScrollbars DOM
                    setupStructureDOM();
                    setupScrollbarsDOM();
                    setupScrollbarCornerDOM();

                    //create OverlayScrollbars events
                    setupStructureEvents();
                    setupScrollbarEvents(true);
                    setupScrollbarEvents(false);
                    setupScrollbarCornerEvents();

                    //create mutation observers
                    createMutationObservers();

                    //build resize observer for the host element
                    setupResizeObserver(_sizeObserverElement, hostOnResized);

                    if (_isBody) {
                        //apply the body scroll to handle it right in the update method
                        _viewportElement[_strScrollLeft](initBodyScroll.l)[_strScrollTop](initBodyScroll.t);

                        //set the focus on the viewport element so you dont have to click on the page to use keyboard keys (up / down / space) for scrolling
                        if (document.activeElement == targetElement && _viewportElementNative.focus) {
                            //set a tabindex to make the viewportElement focusable
                            _viewportElement.attr(LEXICON.ti, '-1');
                            _viewportElementNative.focus();

                            /* the tabindex has to be removed due to;
                             * If you set the tabindex attribute on an <div>, then its child content cannot be scrolled with the arrow keys unless you set tabindex on the content, too
                             * https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
                             */
                            setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, false, true);
                        }
                    }

                    //update for the first time & initialize cache
                    _base.update(_strAuto);

                    //the plugin is initialized now!
                    _initialized = true;
                    dispatchCallback('onInitialized');

                    //call all callbacks which would fire before the initialized was complete
                    each(_callbacksInitQeueue, function (index, value) { dispatchCallback(value.n, value.a); });
                    _callbacksInitQeueue = [];

                    //add extensions
                    if (type(extensions) == TYPES.s)
                        extensions = [extensions];
                    if (COMPATIBILITY.isA(extensions))
                        each(extensions, function (index, value) { _base.addExt(value); });
                    else if (FRAMEWORK.isPlainObject(extensions))
                        each(extensions, function (key, value) { _base.addExt(key, value); });

                    //add the transition class for transitions AFTER the first update & AFTER the applied extensions (for preventing unwanted transitions)
                    setTimeout(function () {
                        if (_supportTransition && !_destroyed)
                            addClass(_hostElement, _classNameHostTransition);
                    }, 333);

                    return _base;
                }

                if (_plugin.valid(construct(pluginTargetElement, options, extensions))) {
                    INSTANCES(pluginTargetElement, _base);
                }

                return _base;
            }

            /**
             * Initializes a new OverlayScrollbarsInstance object or changes options if already initialized or returns the current instance.
             * @param pluginTargetElements The elements to which the Plugin shall be initialized.
             * @param options The custom options with which the plugin shall be initialized.
             * @param extensions The extension(s) which shall be added right after initialization.
             * @returns {*}
             */
            _plugin = window[PLUGINNAME] = function (pluginTargetElements, options, extensions) {
                if (arguments[LEXICON.l] === 0)
                    return this;

                var arr = [];
                var optsIsPlainObj = FRAMEWORK.isPlainObject(options);
                var inst;
                var result;

                //pluginTargetElements is null or undefined
                if (!pluginTargetElements)
                    return optsIsPlainObj || !options ? result : arr;

                /*
                   pluginTargetElements will be converted to:
                   1. A jQueryElement Array
                   2. A HTMLElement Array
                   3. A Array with a single HTML Element
                   so pluginTargetElements is always a array.
                */
                pluginTargetElements = pluginTargetElements[LEXICON.l] != undefined ? pluginTargetElements : [pluginTargetElements[0] || pluginTargetElements];
                initOverlayScrollbarsStatics();

                if (pluginTargetElements[LEXICON.l] > 0) {
                    if (optsIsPlainObj) {
                        FRAMEWORK.each(pluginTargetElements, function (i, v) {
                            inst = v;
                            if (inst !== undefined)
                                arr.push(OverlayScrollbarsInstance(inst, options, extensions, _pluginsGlobals, _pluginsAutoUpdateLoop));
                        });
                    }
                    else {
                        FRAMEWORK.each(pluginTargetElements, function (i, v) {
                            inst = INSTANCES(v);
                            if ((options === '!' && _plugin.valid(inst)) || (COMPATIBILITY.type(options) == TYPES.f && options(v, inst)))
                                arr.push(inst);
                            else if (options === undefined)
                                arr.push(inst);
                        });
                    }
                    result = arr[LEXICON.l] === 1 ? arr[0] : arr;
                }
                return result;
            };

            /**
             * Returns a object which contains global information about the plugin and each instance of it.
             * The returned object is just a copy, that means that changes to the returned object won't have any effect to the original object.
             */
            _plugin.globals = function () {
                initOverlayScrollbarsStatics();
                var globals = FRAMEWORK.extend(true, {}, _pluginsGlobals);
                delete globals['msie'];
                return globals;
            };

            /**
             * Gets or Sets the default options for each new plugin initialization.
             * @param newDefaultOptions The object with which the default options shall be extended.
             */
            _plugin.defaultOptions = function (newDefaultOptions) {
                initOverlayScrollbarsStatics();
                var currDefaultOptions = _pluginsGlobals.defaultOptions;
                if (newDefaultOptions === undefined)
                    return FRAMEWORK.extend(true, {}, currDefaultOptions);

                //set the new default options
                _pluginsGlobals.defaultOptions = FRAMEWORK.extend(true, {}, currDefaultOptions, _pluginsOptions._validate(newDefaultOptions, _pluginsOptions._template, true, currDefaultOptions)._default);
            };

            /**
             * Checks whether the passed instance is a non-destroyed OverlayScrollbars instance.
             * @param osInstance The potential OverlayScrollbars instance which shall be checked.
             * @returns {boolean} True if the passed value is a non-destroyed OverlayScrollbars instance, false otherwise.
             */
            _plugin.valid = function (osInstance) {
                return osInstance instanceof _plugin && !osInstance.getState().destroyed;
            };

            /**
             * Registers, Unregisters or returns a extension.
             * Register: Pass the name and the extension. (defaultOptions is optional)
             * Unregister: Pass the name and anything except a function as extension parameter.
             * Get extension: Pass the name of the extension which shall be got.
             * Get all extensions: Pass no arguments.
             * @param extensionName The name of the extension which shall be registered, unregistered or returned.
             * @param extension A function which generates the instance of the extension or anything other to remove a already registered extension.
             * @param defaultOptions The default options which shall be used for the registered extension.
             */
            _plugin.extension = function (extensionName, extension, defaultOptions) {
                var extNameTypeString = COMPATIBILITY.type(extensionName) == TYPES.s;
                var argLen = arguments[LEXICON.l];
                var i = 0;
                if (argLen < 1 || !extNameTypeString) {
                    //return a copy of all extension objects
                    return FRAMEWORK.extend(true, { length: _pluginsExtensions[LEXICON.l] }, _pluginsExtensions);
                }
                else if (extNameTypeString) {
                    if (COMPATIBILITY.type(extension) == TYPES.f) {
                        //register extension
                        _pluginsExtensions.push({
                            name: extensionName,
                            extensionFactory: extension,
                            defaultOptions: defaultOptions
                        });
                    }
                    else {
                        for (; i < _pluginsExtensions[LEXICON.l]; i++) {
                            if (_pluginsExtensions[i].name === extensionName) {
                                if (argLen > 1)
                                    _pluginsExtensions.splice(i, 1); //remove extension
                                else
                                    return FRAMEWORK.extend(true, {}, _pluginsExtensions[i]); //return extension with the given name
                            }
                        }
                    }
                }
            };

            return _plugin;
        })();

        if (JQUERY && JQUERY.fn) {
            /**
             * The jQuery initialization interface.
             * @param options The initial options for the construction of the plugin. To initialize the plugin, this option has to be a object! If it isn't a object, the instance(s) are returned and the plugin wont be initialized.
             * @param extensions The extension(s) which shall be added right after initialization.
             * @returns {*} After initialization it returns the jQuery element array, else it returns the instance(s) of the elements which are selected.
             */
            JQUERY.fn.overlayScrollbars = function (options, extensions) {
                var _elements = this;
                if (JQUERY.isPlainObject(options)) {
                    JQUERY.each(_elements, function () { PLUGIN(this, options, extensions); });
                    return _elements;
                }
                else
                    return PLUGIN(_elements, options);
            };
        }
        return PLUGIN;
    }
));

/***/ }),

/***/ "dca8":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var FREEZING = __webpack_require__("bb2f");
var fails = __webpack_require__("d039");
var isObject = __webpack_require__("861d");
var onFreeze = __webpack_require__("f183").onFreeze;

var nativeFreeze = Object.freeze;
var FAILS_ON_PRIMITIVES = fails(function () { nativeFreeze(1); });

// `Object.freeze` method
// https://tc39.github.io/ecma262/#sec-object.freeze
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
  freeze: function freeze(it) {
    return nativeFreeze && isObject(it) ? nativeFreeze(onFreeze(it)) : it;
  }
});


/***/ }),

/***/ "ddb0":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var DOMIterables = __webpack_require__("fdbc");
var ArrayIteratorMethods = __webpack_require__("e260");
var createNonEnumerableProperty = __webpack_require__("9112");
var wellKnownSymbol = __webpack_require__("b622");

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
}


/***/ }),

/***/ "df75":
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__("ca84");
var enumBugKeys = __webpack_require__("7839");

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ "df7c":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("4362")))

/***/ }),

/***/ "e01a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// `Symbol.prototype.description` getter
// https://tc39.github.io/ecma262/#sec-symbol.prototype.description

var $ = __webpack_require__("23e7");
var DESCRIPTORS = __webpack_require__("83ab");
var global = __webpack_require__("da84");
var has = __webpack_require__("5135");
var isObject = __webpack_require__("861d");
var defineProperty = __webpack_require__("9bf2").f;
var copyConstructorProperties = __webpack_require__("e893");

var NativeSymbol = global.Symbol;

if (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
  // Safari 12 bug
  NativeSymbol().description !== undefined
)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
    var result = this instanceof SymbolWrapper
      ? new NativeSymbol(description)
      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
      : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };
  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
  symbolPrototype.constructor = SymbolWrapper;

  var symbolToString = symbolPrototype.toString;
  var native = String(NativeSymbol('test')) == 'Symbol(test)';
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  defineProperty(symbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = isObject(this) ? this.valueOf() : this;
      var string = symbolToString.call(symbol);
      if (has(EmptyStringDescriptionStore, symbol)) return '';
      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  $({ global: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}


/***/ }),

/***/ "e163":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("5135");
var toObject = __webpack_require__("7b0b");
var sharedKey = __webpack_require__("f772");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__("e177");

var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectPrototype : null;
};


/***/ }),

/***/ "e177":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ "e21d":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var fails = __webpack_require__("d039");
var isObject = __webpack_require__("861d");

var nativeIsFrozen = Object.isFrozen;
var FAILS_ON_PRIMITIVES = fails(function () { nativeIsFrozen(1); });

// `Object.isFrozen` method
// https://tc39.github.io/ecma262/#sec-object.isfrozen
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  isFrozen: function isFrozen(it) {
    return isObject(it) ? nativeIsFrozen ? nativeIsFrozen(it) : false : true;
  }
});


/***/ }),

/***/ "e260":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__("fc6a");
var addToUnscopables = __webpack_require__("44d2");
var Iterators = __webpack_require__("3f8c");
var InternalStateModule = __webpack_require__("69f3");
var defineIterator = __webpack_require__("7dd0");

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.github.io/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.github.io/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
Iterators.Arguments = Iterators.Array;

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "e2cc":
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__("6eeb");

module.exports = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ "e439":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var fails = __webpack_require__("d039");
var toIndexedObject = __webpack_require__("fc6a");
var nativeGetOwnPropertyDescriptor = __webpack_require__("06cf").f;
var DESCRIPTORS = __webpack_require__("83ab");

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetOwnPropertyDescriptor(1); });
var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
$({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
  }
});


/***/ }),

/***/ "e490":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return hasWindowSupport; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return hasDocumentSupport; });
/* unused harmony export hasNavigatorSupport */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return hasPromiseSupport; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return hasMutationObserverSupport; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return isBrowser; });
/* unused harmony export userAgent */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return isJSDOM; });
/* unused harmony export isIE */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return hasPassiveEventSupport; });
/* unused harmony export hasTouchSupport */
/* unused harmony export hasPointerEventSupport */
/* unused harmony export hasIntersectionObserverSupport */
/* unused harmony export getEnv */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getNoWarn; });
/* harmony import */ var core_js_modules_es_array_index_of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("c975");
/* harmony import */ var core_js_modules_es_array_index_of__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_index_of__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("d3b7");
/* harmony import */ var core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("e6cf");
/* harmony import */ var core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_2__);



var hasWindowSupport = typeof window !== "undefined";
var hasDocumentSupport = typeof document !== "undefined";
var hasNavigatorSupport = typeof navigator !== "undefined";
var hasPromiseSupport = typeof Promise !== "undefined";
var hasMutationObserverSupport = typeof MutationObserver !== "undefined" || typeof WebKitMutationObserver !== "undefined" || typeof MozMutationObserver !== "undefined";
var isBrowser = hasWindowSupport && hasDocumentSupport && hasNavigatorSupport;
var userAgent = isBrowser ? window.navigator.userAgent.toLowerCase() : "";
var isJSDOM = userAgent.indexOf("jsdom") > 0;
var isIE = /msie|trident/.test(userAgent);
var hasPassiveEventSupport = function () {
  var passiveEventSupported = false;

  if (isBrowser) {
    try {
      var options = {
        // eslint-disable-next-line getter-return
        get passive() {
          passiveEventSupported = true;
        }

      };
      window.addEventListener("test", options, options);
      window.removeEventListener("test", options, options);
    } catch (err) {
      passiveEventSupported = false;
    }
  }

  return passiveEventSupported;
}();
var hasTouchSupport = isBrowser && ("ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0);
var hasPointerEventSupport = isBrowser && Boolean(window.PointerEvent || window.MSPointerEvent);
var hasIntersectionObserverSupport = isBrowser && "IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype;
var getEnv = function getEnv(key) {
  var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var env = typeof process !== "undefined" && process ? Object({"NODE_ENV":"production","BASE_URL":"/"}) || false : {};

  if (!key) {
    return env;
  }

  return env[key] || fallback;
};
var getNoWarn = function getNoWarn() {
  return getEnv("NLYADMINLTE_VUE_NO_WARN");
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("4362")))

/***/ }),

/***/ "e538":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

exports.f = wellKnownSymbol;


/***/ }),

/***/ "e667":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};


/***/ }),

/***/ "e6cf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var IS_PURE = __webpack_require__("c430");
var global = __webpack_require__("da84");
var getBuiltIn = __webpack_require__("d066");
var NativePromise = __webpack_require__("fea9");
var redefine = __webpack_require__("6eeb");
var redefineAll = __webpack_require__("e2cc");
var setToStringTag = __webpack_require__("d44e");
var setSpecies = __webpack_require__("2626");
var isObject = __webpack_require__("861d");
var aFunction = __webpack_require__("1c0b");
var anInstance = __webpack_require__("19aa");
var classof = __webpack_require__("c6b6");
var inspectSource = __webpack_require__("8925");
var iterate = __webpack_require__("2266");
var checkCorrectnessOfIteration = __webpack_require__("1c7e");
var speciesConstructor = __webpack_require__("4840");
var task = __webpack_require__("2cf4").set;
var microtask = __webpack_require__("b575");
var promiseResolve = __webpack_require__("cdf9");
var hostReportErrors = __webpack_require__("44de");
var newPromiseCapabilityModule = __webpack_require__("f069");
var perform = __webpack_require__("e667");
var InternalStateModule = __webpack_require__("69f3");
var isForced = __webpack_require__("94ca");
var wellKnownSymbol = __webpack_require__("b622");
var V8_VERSION = __webpack_require__("2d00");

var SPECIES = wellKnownSymbol('species');
var PROMISE = 'Promise';
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var PromiseConstructor = NativePromise;
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var $fetch = getBuiltIn('fetch');
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;
var IS_NODE = classof(process) == 'process';
var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

var FORCED = isForced(PROMISE, function () {
  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
  if (!GLOBAL_CORE_JS_PROMISE) {
    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // We can't detect it synchronously, so just check versions
    if (V8_VERSION === 66) return true;
    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    if (!IS_NODE && typeof PromiseRejectionEvent != 'function') return true;
  }
  // We need Promise#finally in the pure version for preventing prototype pollution
  if (IS_PURE && !PromiseConstructor.prototype['finally']) return true;
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor)) return false;
  // Detect correctness of subclassing with @@species support
  var promise = PromiseConstructor.resolve(1);
  var FakePromise = function (exec) {
    exec(function () { /* empty */ }, function () { /* empty */ });
  };
  var constructor = promise.constructor = {};
  constructor[SPECIES] = FakePromise;
  return !(promise.then(function () { /* empty */ }) instanceof FakePromise);
});

var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
});

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function (promise, state, isReject) {
  if (state.notified) return;
  state.notified = true;
  var chain = state.reactions;
  microtask(function () {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var index = 0;
    // variable length - can't use forEach
    while (chain.length > index) {
      var reaction = chain[index++];
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
            state.rejection = HANDLED;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // can throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    }
    state.reactions = [];
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(promise, state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (handler = global['on' + name]) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (promise, state) {
  task.call(global, function () {
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (promise, state) {
  task.call(global, function () {
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, promise, state, unwrap) {
  return function (value) {
    fn(promise, state, value, unwrap);
  };
};

var internalReject = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(promise, state, true);
};

var internalResolve = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          then.call(value,
            bind(internalResolve, promise, wrapper, state),
            bind(internalReject, promise, wrapper, state)
          );
        } catch (error) {
          internalReject(promise, wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(promise, state, false);
    }
  } catch (error) {
    internalReject(promise, { done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromiseConstructor, PROMISE);
    aFunction(executor);
    Internal.call(this);
    var state = getInternalState(this);
    try {
      executor(bind(internalResolve, this, state), bind(internalReject, this, state));
    } catch (error) {
      internalReject(this, state, error);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: [],
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };
  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
    // `Promise.prototype.then` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.then
    then: function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = IS_NODE ? process.domain : undefined;
      state.parent = true;
      state.reactions.push(reaction);
      if (state.state != PENDING) notify(this, state, false);
      return reaction.promise;
    },
    // `Promise.prototype.catch` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalState(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, promise, state);
    this.reject = bind(internalReject, promise, state);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  if (!IS_PURE && typeof NativePromise == 'function') {
    nativeThen = NativePromise.prototype.then;

    // wrap native Promise#then for native async functions
    redefine(NativePromise.prototype, 'then', function then(onFulfilled, onRejected) {
      var that = this;
      return new PromiseConstructor(function (resolve, reject) {
        nativeThen.call(that, resolve, reject);
      }).then(onFulfilled, onRejected);
    // https://github.com/zloirock/core-js/issues/640
    }, { unsafe: true });

    // wrap fetch result
    if (typeof $fetch == 'function') $({ global: true, enumerable: true, forced: true }, {
      // eslint-disable-next-line no-unused-vars
      fetch: function fetch(input /* , init */) {
        return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));
      }
    });
  }
}

$({ global: true, wrap: true, forced: FORCED }, {
  Promise: PromiseConstructor
});

setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);

PromiseWrapper = getBuiltIn(PROMISE);

// statics
$({ target: PROMISE, stat: true, forced: FORCED }, {
  // `Promise.reject` method
  // https://tc39.github.io/ecma262/#sec-promise.reject
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    capability.reject.call(undefined, r);
    return capability.promise;
  }
});

$({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
  // `Promise.resolve` method
  // https://tc39.github.io/ecma262/#sec-promise.resolve
  resolve: function resolve(x) {
    return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
  }
});

$({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
  // `Promise.all` method
  // https://tc39.github.io/ecma262/#sec-promise.all
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        $promiseResolve.call(C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  },
  // `Promise.race` method
  // https://tc39.github.io/ecma262/#sec-promise.race
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      iterate(iterable, function (promise) {
        $promiseResolve.call(C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ "e893":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("5135");
var ownKeys = __webpack_require__("56ef");
var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
var definePropertyModule = __webpack_require__("9bf2");

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};


/***/ }),

/***/ "e8b5":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("c6b6");

// `IsArray` abstract operation
// https://tc39.github.io/ecma262/#sec-isarray
module.exports = Array.isArray || function isArray(arg) {
  return classof(arg) == 'Array';
};


/***/ }),

/***/ "e95a":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");
var Iterators = __webpack_require__("3f8c");

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ "f069":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__("1c0b");

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
};

// 25.4.1.5 NewPromiseCapability(C)
module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "f0bd":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

var timeoutDuration = function () {
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      return 1;
    }
  }
  return 0;
}();

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */
function getReferenceNode(reference) {
  return reference && reference.referenceNode ? reference.referenceNode : reference;
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null;

  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent || null;
  // Skip hidden elements which don't have an offsetParent
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }

  // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.width;
  var height = sizes.height || element.clientHeight || result.height;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth);

  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop);
    var marginLeft = parseFloat(styles.marginLeft);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  var parentNode = getParentNode(element);
  if (!parentNode) {
    return false;
  }
  return isFixed(parentNode);
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }
  return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // NOTE: 1 DOM access here

  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  data.positionFixed = this.options.positionFixed;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicitly asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */
function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var round = Math.round,
      floor = Math.floor;

  var noRound = function noRound(v) {
    return v;
  };

  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);

  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;

  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

    // flips variation if reference element overflows boundaries
    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    // flips variation if popper content overflows boundaries
    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);

    var flippedVariation = flippedVariationByRef || flippedVariationByContent;

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself
  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification
  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];

  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

  // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;

  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport',
    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,
    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

/* harmony default export */ __webpack_exports__["a"] = (Popper);
//# sourceMappingURL=popper.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")))

/***/ }),

/***/ "f183":
/***/ (function(module, exports, __webpack_require__) {

var hiddenKeys = __webpack_require__("d012");
var isObject = __webpack_require__("861d");
var has = __webpack_require__("5135");
var defineProperty = __webpack_require__("9bf2").f;
var uid = __webpack_require__("90e3");
var FREEZING = __webpack_require__("bb2f");

var METADATA = uid('meta');
var id = 0;

var isExtensible = Object.isExtensible || function () {
  return true;
};

var setMetadata = function (it) {
  defineProperty(it, METADATA, { value: {
    objectID: 'O' + ++id, // object ID
    weakData: {}          // weak collections IDs
  } });
};

var fastKey = function (it, create) {
  // return a primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
  // return object ID
  } return it[METADATA].objectID;
};

var getWeakData = function (it, create) {
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
  // return the store of weak collections IDs
  } return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZING && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
  return it;
};

var meta = module.exports = {
  REQUIRED: false,
  fastKey: fastKey,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};

hiddenKeys[METADATA] = true;


/***/ }),

/***/ "f5df":
/***/ (function(module, exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
var classofRaw = __webpack_require__("c6b6");
var wellKnownSymbol = __webpack_require__("b622");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};


/***/ }),

/***/ "f772":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("5692");
var uid = __webpack_require__("90e3");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ "fb15":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "install", function() { return /* reexport */ src_install; });
__webpack_require__.d(__webpack_exports__, "NAME", function() { return /* reexport */ src_NAME; });
__webpack_require__.d(__webpack_exports__, "NlyAdminlteVue", function() { return /* reexport */ NlyAdminlteVue; });
__webpack_require__.d(__webpack_exports__, "BadgePlugin", function() { return /* reexport */ BadgePlugin; });
__webpack_require__.d(__webpack_exports__, "NlyBadge", function() { return /* reexport */ NlyBadge; });
__webpack_require__.d(__webpack_exports__, "BreadcrumbPlugin", function() { return /* reexport */ BreadcrumbPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyBreadcrumbItem", function() { return /* reexport */ NlyBreadcrumbItem; });
__webpack_require__.d(__webpack_exports__, "NlyBreadcrumb", function() { return /* reexport */ NlyBreadcrumb; });
__webpack_require__.d(__webpack_exports__, "BootstrapPaginationPlugin", function() { return /* reexport */ BootstrapPaginationPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyBootstrapPagination", function() { return /* reexport */ NlyBootstrapPagination; });
__webpack_require__.d(__webpack_exports__, "ButtonPlugin", function() { return /* reexport */ ButtonPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyButton", function() { return /* reexport */ NlyButton; });
__webpack_require__.d(__webpack_exports__, "NlyButtonClose", function() { return /* reexport */ NlyButtonClose; });
__webpack_require__.d(__webpack_exports__, "ButtonGroupPlugin", function() { return /* reexport */ ButtonGroupPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyButtonGroup", function() { return /* reexport */ NlyButtonGroup; });
__webpack_require__.d(__webpack_exports__, "CardPlugin", function() { return /* reexport */ CardPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyCardGroup", function() { return /* reexport */ NlyCardGroup; });
__webpack_require__.d(__webpack_exports__, "NlyCard", function() { return /* reexport */ NlyCard; });
__webpack_require__.d(__webpack_exports__, "NlyCardHeader", function() { return /* reexport */ NlyCardHeader; });
__webpack_require__.d(__webpack_exports__, "NlyCardBody", function() { return /* reexport */ NlyCardBody; });
__webpack_require__.d(__webpack_exports__, "NlyCardTitle", function() { return /* reexport */ NlyCardTitle; });
__webpack_require__.d(__webpack_exports__, "NlyCardFooter", function() { return /* reexport */ NlyCardFooter; });
__webpack_require__.d(__webpack_exports__, "NlyCardSubtitle", function() { return /* reexport */ NlyCardSubtitle; });
__webpack_require__.d(__webpack_exports__, "NlyCardImg", function() { return /* reexport */ NlyCardImg; });
__webpack_require__.d(__webpack_exports__, "NlyCardTool", function() { return /* reexport */ NlyCardTool; });
__webpack_require__.d(__webpack_exports__, "NlyCardText", function() { return /* reexport */ NlyCardText; });
__webpack_require__.d(__webpack_exports__, "CollapsePlugin", function() { return /* reexport */ CollapsePlugin; });
__webpack_require__.d(__webpack_exports__, "NlyCollapse", function() { return /* reexport */ NlyCollapse; });
__webpack_require__.d(__webpack_exports__, "NlyCollapseTransition", function() { return /* reexport */ NlyCollapseTransition; });
__webpack_require__.d(__webpack_exports__, "NlyCollapseNoclass", function() { return /* reexport */ NlyCollapseNoclass; });
__webpack_require__.d(__webpack_exports__, "ContainerPlugin", function() { return /* reexport */ ContainerPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyContainer", function() { return /* reexport */ NlyContainer; });
__webpack_require__.d(__webpack_exports__, "ContentPlugin", function() { return /* reexport */ ContentPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyContent", function() { return /* reexport */ NlyContent; });
__webpack_require__.d(__webpack_exports__, "NlyContentHeader", function() { return /* reexport */ NlyContentHeader; });
__webpack_require__.d(__webpack_exports__, "NlyContentWrapper", function() { return /* reexport */ NlyContentWrapper; });
__webpack_require__.d(__webpack_exports__, "ControlSidebarPlugin", function() { return /* reexport */ ControlSidebarPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyControlSidebarContainer", function() { return /* reexport */ NlyControlSidebarContainer; });
__webpack_require__.d(__webpack_exports__, "NlyControlSidebar", function() { return /* reexport */ NlyControlSidebar; });
__webpack_require__.d(__webpack_exports__, "NlyControlSidebarButton", function() { return /* reexport */ NlyControlSidebarButton; });
__webpack_require__.d(__webpack_exports__, "DropdownPlugin", function() { return /* reexport */ DropdownPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyDropdown", function() { return /* reexport */ NlyDropdown; });
__webpack_require__.d(__webpack_exports__, "NlyDropdownDivider", function() { return /* reexport */ NlyDropdownDivider; });
__webpack_require__.d(__webpack_exports__, "NlyDropdownForm", function() { return /* reexport */ NlyDropdownForm; });
__webpack_require__.d(__webpack_exports__, "NlyDropdownGroup", function() { return /* reexport */ NlyDropdownGroup; });
__webpack_require__.d(__webpack_exports__, "NlyDropdownHeader", function() { return /* reexport */ NlyDropdownHeader; });
__webpack_require__.d(__webpack_exports__, "NlyDropdownItem", function() { return /* reexport */ NlyDropdownItem; });
__webpack_require__.d(__webpack_exports__, "NlyDropdownItemButton", function() { return /* reexport */ NlyDropdownItemButton; });
__webpack_require__.d(__webpack_exports__, "NlyDropdownText", function() { return /* reexport */ NlyDropdownText; });
__webpack_require__.d(__webpack_exports__, "NlyDropdownFooter", function() { return /* reexport */ NlyDropdownFooter; });
__webpack_require__.d(__webpack_exports__, "FormDaterangepickerPlugin", function() { return /* reexport */ FormDaterangepickerPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyFormDaterangepicker", function() { return /* reexport */ NlyFormDaterangepicker; });
__webpack_require__.d(__webpack_exports__, "VNlyAppendToBody", function() { return /* reexport */ VNlyAppendToBody; });
__webpack_require__.d(__webpack_exports__, "NlyCalendar", function() { return /* reexport */ NlyCalendar; });
__webpack_require__.d(__webpack_exports__, "NlyCalendarRangs", function() { return /* reexport */ NlyCalendarRangs; });
__webpack_require__.d(__webpack_exports__, "NlyCalendarTime", function() { return /* reexport */ NlyCalendarTime; });
__webpack_require__.d(__webpack_exports__, "NlyDaterangePickerTransition", function() { return /* reexport */ NlyDaterangePickerTransition; });
__webpack_require__.d(__webpack_exports__, "FormCheckboxPlugin", function() { return /* reexport */ FormCheckboxPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyFormCheckbox", function() { return /* reexport */ NlyFormCheckbox; });
__webpack_require__.d(__webpack_exports__, "NlyFormCheckboxGroup", function() { return /* reexport */ NlyFormCheckboxGroup; });
__webpack_require__.d(__webpack_exports__, "FormPlugin", function() { return /* reexport */ FormPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyForm", function() { return /* reexport */ NlyForm; });
__webpack_require__.d(__webpack_exports__, "NlyFormFeedback", function() { return /* reexport */ NlyFormFeedback; });
__webpack_require__.d(__webpack_exports__, "NlyFormDatalist", function() { return /* reexport */ NlyFormDatalist; });
__webpack_require__.d(__webpack_exports__, "NlyFormText", function() { return /* reexport */ NlyFormText; });
__webpack_require__.d(__webpack_exports__, "FormRadioPlugin", function() { return /* reexport */ FormRadioPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyFormRadio", function() { return /* reexport */ NlyFormRadio; });
__webpack_require__.d(__webpack_exports__, "NlyFormRadioGroup", function() { return /* reexport */ NlyFormRadioGroup; });
__webpack_require__.d(__webpack_exports__, "FormGroupPlugin", function() { return /* reexport */ FormGroupPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyFormGroup", function() { return /* reexport */ NlyFormGroup; });
__webpack_require__.d(__webpack_exports__, "FormInputPlugin", function() { return /* reexport */ FormInputPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyFormInput", function() { return /* reexport */ NlyFormInput; });
__webpack_require__.d(__webpack_exports__, "FormSelectPlugin", function() { return /* reexport */ FormSelectPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyFormSelect", function() { return /* reexport */ NlyFormSelect; });
__webpack_require__.d(__webpack_exports__, "NlyFormSelectOption", function() { return /* reexport */ NlyFormSelectOption; });
__webpack_require__.d(__webpack_exports__, "NlyFormSelectOptionGroup", function() { return /* reexport */ NlyFormSelectOptionGroup; });
__webpack_require__.d(__webpack_exports__, "GridPlugin", function() { return /* reexport */ GridPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyRow", function() { return /* reexport */ NlyRow; });
__webpack_require__.d(__webpack_exports__, "NlyCol", function() { return /* reexport */ NlyCol; });
__webpack_require__.d(__webpack_exports__, "InfoboxPlugin", function() { return /* reexport */ InfoboxPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyInfobox", function() { return /* reexport */ NlyInfobox; });
__webpack_require__.d(__webpack_exports__, "NlyInfoboxIcon", function() { return /* reexport */ NlyInfoboxIcon; });
__webpack_require__.d(__webpack_exports__, "NlyInfoboxBody", function() { return /* reexport */ NlyInfoboxBody; });
__webpack_require__.d(__webpack_exports__, "NlyInfoboxText", function() { return /* reexport */ NlyInfoboxText; });
__webpack_require__.d(__webpack_exports__, "NlyInfoboxNumber", function() { return /* reexport */ NlyInfoboxNumber; });
__webpack_require__.d(__webpack_exports__, "InputGroupoPlugin", function() { return /* reexport */ InputGroupoPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyInputGroupText", function() { return /* reexport */ NlyInputGroupText; });
__webpack_require__.d(__webpack_exports__, "NlyInputGroup", function() { return /* reexport */ NlyInputGroup; });
__webpack_require__.d(__webpack_exports__, "NlyInputGroupPrepend", function() { return /* reexport */ NlyInputGroupPrepend; });
__webpack_require__.d(__webpack_exports__, "NlyInputGroupAppend", function() { return /* reexport */ NlyInputGroupAppend; });
__webpack_require__.d(__webpack_exports__, "NlyInputGroupAdd", function() { return /* reexport */ NlyInputGroupAdd; });
__webpack_require__.d(__webpack_exports__, "LinkPlugin", function() { return /* reexport */ LinkPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyLink", function() { return /* reexport */ NlyLink; });
__webpack_require__.d(__webpack_exports__, "ListGroupPlugin", function() { return /* reexport */ ListGroupPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyListGroup", function() { return /* reexport */ NlyListGroup; });
__webpack_require__.d(__webpack_exports__, "NlyListGroupItem", function() { return /* reexport */ NlyListGroupItem; });
__webpack_require__.d(__webpack_exports__, "LogPlugin", function() { return /* reexport */ LogPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyLog", function() { return /* reexport */ NlyLog; });
__webpack_require__.d(__webpack_exports__, "NlyLogHeader", function() { return /* reexport */ NlyLogHeader; });
__webpack_require__.d(__webpack_exports__, "NlyLogBody", function() { return /* reexport */ NlyLogBody; });
__webpack_require__.d(__webpack_exports__, "NlyLogLine", function() { return /* reexport */ NlyLogLine; });
__webpack_require__.d(__webpack_exports__, "NlyLogLineTree", function() { return /* reexport */ NlyLogLineTree; });
__webpack_require__.d(__webpack_exports__, "NlyLogTools", function() { return /* reexport */ NlyLogTools; });
__webpack_require__.d(__webpack_exports__, "ModalPlugin", function() { return /* reexport */ ModalPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyModal", function() { return /* reexport */ NlyModal; });
__webpack_require__.d(__webpack_exports__, "NavPlugin", function() { return /* reexport */ NavPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyNav", function() { return /* reexport */ NlyNav; });
__webpack_require__.d(__webpack_exports__, "NlyNavItem", function() { return /* reexport */ NlyNavItem; });
__webpack_require__.d(__webpack_exports__, "NlyNavDropdown", function() { return /* reexport */ NlyNavDropdown; });
__webpack_require__.d(__webpack_exports__, "NlyNavForm", function() { return /* reexport */ NlyNavForm; });
__webpack_require__.d(__webpack_exports__, "NlyNavText", function() { return /* reexport */ NlyNavText; });
__webpack_require__.d(__webpack_exports__, "NavbarPlugin", function() { return /* reexport */ NavbarPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyNavbar", function() { return /* reexport */ NlyNavbar; });
__webpack_require__.d(__webpack_exports__, "NlyNavbarNav", function() { return /* reexport */ NlyNavbarNav; });
__webpack_require__.d(__webpack_exports__, "NlyNavbarBrand", function() { return /* reexport */ NlyNavbarBrand; });
__webpack_require__.d(__webpack_exports__, "NlyNavbarBrandtext", function() { return /* reexport */ NlyNavbarBrandtext; });
__webpack_require__.d(__webpack_exports__, "NlyNavbarToggle", function() { return /* reexport */ NlyNavbarToggle; });
__webpack_require__.d(__webpack_exports__, "OverlayPlugin", function() { return /* reexport */ OverlayPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyOverlay", function() { return /* reexport */ NlyOverlay; });
__webpack_require__.d(__webpack_exports__, "PaginationPlugin", function() { return /* reexport */ PaginationPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyPagination", function() { return /* reexport */ NlyPagination; });
__webpack_require__.d(__webpack_exports__, "PopoverPlugin", function() { return /* reexport */ PopoverPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyPopover", function() { return /* reexport */ NlyPopover; });
__webpack_require__.d(__webpack_exports__, "ProgressPlugin", function() { return /* reexport */ ProgressPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyProgress", function() { return /* reexport */ NlyProgress; });
__webpack_require__.d(__webpack_exports__, "NlyProgressBar", function() { return /* reexport */ NlyProgressBar; });
__webpack_require__.d(__webpack_exports__, "NlyProgressDescription", function() { return /* reexport */ NlyProgressDescription; });
__webpack_require__.d(__webpack_exports__, "RenderFunctionPlugin", function() { return /* reexport */ RenderFunctionPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyRenderFunction", function() { return /* reexport */ NlyRenderFunction; });
__webpack_require__.d(__webpack_exports__, "SidebarPlugin", function() { return /* reexport */ SidebarPlugin; });
__webpack_require__.d(__webpack_exports__, "NlySidebarContainer", function() { return /* reexport */ NlySidebarContainer; });
__webpack_require__.d(__webpack_exports__, "NlySidebarBrand", function() { return /* reexport */ NlySidebarBrand; });
__webpack_require__.d(__webpack_exports__, "NlySidebarBrandimg", function() { return /* reexport */ NlySidebarBrandimg; });
__webpack_require__.d(__webpack_exports__, "NlySidebarBrandtext", function() { return /* reexport */ NlySidebarBrandtext; });
__webpack_require__.d(__webpack_exports__, "NlySidebar", function() { return /* reexport */ NlySidebar; });
__webpack_require__.d(__webpack_exports__, "NlySidebarUserpanel", function() { return /* reexport */ NlySidebarUserpanel; });
__webpack_require__.d(__webpack_exports__, "NlySidebarUserpanelImg", function() { return /* reexport */ NlySidebarUserpanelImg; });
__webpack_require__.d(__webpack_exports__, "NlySidebarUserpanelInfo", function() { return /* reexport */ NlySidebarUserpanelInfo; });
__webpack_require__.d(__webpack_exports__, "NlySidebarNav", function() { return /* reexport */ NlySidebarNav; });
__webpack_require__.d(__webpack_exports__, "NlySidebarNavItem", function() { return /* reexport */ NlySidebarNavItem; });
__webpack_require__.d(__webpack_exports__, "NlySidebarNavTree", function() { return /* reexport */ NlySidebarNavTree; });
__webpack_require__.d(__webpack_exports__, "NlySidebarNavHeader", function() { return /* reexport */ NlySidebarNavHeader; });
__webpack_require__.d(__webpack_exports__, "SpinnerPlugin", function() { return /* reexport */ SpinnerPlugin; });
__webpack_require__.d(__webpack_exports__, "NlySpinner", function() { return /* reexport */ NlySpinner; });
__webpack_require__.d(__webpack_exports__, "switchPlugin", function() { return /* reexport */ switchPlugin; });
__webpack_require__.d(__webpack_exports__, "NlySwitch", function() { return /* reexport */ NlySwitch; });
__webpack_require__.d(__webpack_exports__, "NlyBootstrapSwitch", function() { return /* reexport */ NlyBootstrapSwitch; });
__webpack_require__.d(__webpack_exports__, "TablePlugin", function() { return /* reexport */ TablePlugin; });
__webpack_require__.d(__webpack_exports__, "TableSimplePlugin", function() { return /* reexport */ TableSimplePlugin; });
__webpack_require__.d(__webpack_exports__, "TableLitePlugin", function() { return /* reexport */ TableLitePlugin; });
__webpack_require__.d(__webpack_exports__, "NlyTable", function() { return /* reexport */ NlyTable; });
__webpack_require__.d(__webpack_exports__, "NlyTableLite", function() { return /* reexport */ NlyTableLite; });
__webpack_require__.d(__webpack_exports__, "NlyTableSimple", function() { return /* reexport */ NlyTableSimple; });
__webpack_require__.d(__webpack_exports__, "NlyTbody", function() { return /* reexport */ NlyTbody; });
__webpack_require__.d(__webpack_exports__, "NlyTd", function() { return /* reexport */ NlyTd; });
__webpack_require__.d(__webpack_exports__, "NlyTfoot", function() { return /* reexport */ NlyTfoot; });
__webpack_require__.d(__webpack_exports__, "NlyTh", function() { return /* reexport */ NlyTh; });
__webpack_require__.d(__webpack_exports__, "NlyThead", function() { return /* reexport */ NlyThead; });
__webpack_require__.d(__webpack_exports__, "NlyTr", function() { return /* reexport */ NlyTr; });
__webpack_require__.d(__webpack_exports__, "toastPlugin", function() { return /* reexport */ toastPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyToast", function() { return /* reexport */ NlyToast; });
__webpack_require__.d(__webpack_exports__, "NlyToaster", function() { return /* reexport */ NlyToaster; });
__webpack_require__.d(__webpack_exports__, "NLYAToastPlugin", function() { return /* reexport */ NLYAToastPlugin; });
__webpack_require__.d(__webpack_exports__, "timelinePlugin", function() { return /* reexport */ timelinePlugin; });
__webpack_require__.d(__webpack_exports__, "NlyTimeline", function() { return /* reexport */ NlyTimeline; });
__webpack_require__.d(__webpack_exports__, "NlyTimelineLabel", function() { return /* reexport */ NlyTimelineLabel; });
__webpack_require__.d(__webpack_exports__, "NlyTimelineContent", function() { return /* reexport */ NlyTimelineContent; });
__webpack_require__.d(__webpack_exports__, "NlyTimelineItem", function() { return /* reexport */ NlyTimelineItem; });
__webpack_require__.d(__webpack_exports__, "NlyTimelineHeader", function() { return /* reexport */ NlyTimelineHeader; });
__webpack_require__.d(__webpack_exports__, "NlyTimelineBody", function() { return /* reexport */ NlyTimelineBody; });
__webpack_require__.d(__webpack_exports__, "NlyTimelineFooter", function() { return /* reexport */ NlyTimelineFooter; });
__webpack_require__.d(__webpack_exports__, "TooltipPlugin", function() { return /* reexport */ TooltipPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyTooltip", function() { return /* reexport */ NlyTooltip; });
__webpack_require__.d(__webpack_exports__, "WrapperPlugin", function() { return /* reexport */ WrapperPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyWrapper", function() { return /* reexport */ NlyWrapper; });
__webpack_require__.d(__webpack_exports__, "NlyWrapperFooter", function() { return /* reexport */ NlyWrapperFooter; });
__webpack_require__.d(__webpack_exports__, "NlyWrapperHeader", function() { return /* reexport */ NlyWrapperHeader; });
__webpack_require__.d(__webpack_exports__, "NlyWrapperSidebar", function() { return /* reexport */ NlyWrapperSidebar; });
__webpack_require__.d(__webpack_exports__, "NlyWrapperControlSidebar", function() { return /* reexport */ NlyWrapperControlSidebar; });
__webpack_require__.d(__webpack_exports__, "NlyWrapperContent", function() { return /* reexport */ NlyWrapperContent; });
__webpack_require__.d(__webpack_exports__, "VNlyPopoverPlugin", function() { return /* reexport */ VNlyPopoverPlugin; });
__webpack_require__.d(__webpack_exports__, "VNlyPopover", function() { return /* reexport */ VNlyPopover; });
__webpack_require__.d(__webpack_exports__, "VNlyTooltipPlugin", function() { return /* reexport */ VNlyTooltipPlugin; });
__webpack_require__.d(__webpack_exports__, "VNlyTooltip", function() { return /* reexport */ VNlyTooltip; });
__webpack_require__.d(__webpack_exports__, "VNlyCardPlugin", function() { return /* reexport */ VNlyCardPlugin; });
__webpack_require__.d(__webpack_exports__, "VNlyCardMaximized", function() { return /* reexport */ VNlyCardMaximized; });
__webpack_require__.d(__webpack_exports__, "VNlyTogglePlugin", function() { return /* reexport */ VNlyTogglePlugin; });
__webpack_require__.d(__webpack_exports__, "VNlyToggle", function() { return /* reexport */ VNlyToggle; });
__webpack_require__.d(__webpack_exports__, "VNlyCollapseSidebarPlugin", function() { return /* reexport */ VNlyCollapseSidebarPlugin; });
__webpack_require__.d(__webpack_exports__, "VNlySidebarCollapse", function() { return /* reexport */ VNlySidebarCollapse; });
__webpack_require__.d(__webpack_exports__, "VNlyControlSidebarCollapse", function() { return /* reexport */ VNlyControlSidebarCollapse; });
__webpack_require__.d(__webpack_exports__, "VNlyModalPlugin", function() { return /* reexport */ VNlyModalPlugin; });
__webpack_require__.d(__webpack_exports__, "VNlyModal", function() { return /* reexport */ VNlyModal; });
__webpack_require__.d(__webpack_exports__, "VNlyScrollspyPlugin", function() { return /* reexport */ VNlyScrollspyPlugin; });
__webpack_require__.d(__webpack_exports__, "VNlyScrollspy", function() { return /* reexport */ VNlyScrollspy; });
__webpack_require__.d(__webpack_exports__, "TabsPlugin", function() { return /* reexport */ TabsPlugin; });
__webpack_require__.d(__webpack_exports__, "NlyTab", function() { return /* reexport */ NlyTab; });
__webpack_require__.d(__webpack_exports__, "NlyTabs", function() { return /* reexport */ NlyTabs; });
__webpack_require__.d(__webpack_exports__, "NlyAdminlteVueIcons", function() { return /* reexport */ NlyAdminlteVueIcons; });

// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (true) {
    var getCurrentScript = __webpack_require__("8875")
    currentScript = getCurrentScript()

    // for backward compatibility, because previously we directly included the polyfill
    if (!('currentScript' in document)) {
      Object.defineProperty(document, 'currentScript', { get: getCurrentScript })
    }
  }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __webpack_require__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.join.js
var es_array_join = __webpack_require__("a15b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js
var es_regexp_exec = __webpack_require__("ac1f");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.replace.js
var es_string_replace = __webpack_require__("5319");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js
var objectSpread2 = __webpack_require__("5530");

// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
var external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);

// CONCATENATED MODULE: ./src/utils/vue.js

/* harmony default export */ var utils_vue = (external_commonjs_vue_commonjs2_vue_root_Vue_default.a);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js
var es_array_concat = __webpack_require__("99af");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.for-each.js
var es_array_for_each = __webpack_require__("4160");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.some.js
var es_array_some = __webpack_require__("45fc");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.for-each.js
var web_dom_collections_for_each = __webpack_require__("159b");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.reduce.js
var es_array_reduce = __webpack_require__("13d5");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__("ade3");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.js
var es_symbol = __webpack_require__("a4d3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.description.js
var es_symbol_description = __webpack_require__("e01a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.iterator.js
var es_symbol_iterator = __webpack_require__("d28b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.from.js
var es_array_from = __webpack_require__("a630");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.iterator.js
var es_array_iterator = __webpack_require__("e260");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__("d3b7");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.iterator.js
var es_string_iterator = __webpack_require__("3ca3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.iterator.js
var web_dom_collections_iterator = __webpack_require__("ddb0");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js








function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.slice.js
var es_array_slice = __webpack_require__("fb6a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.function.name.js
var es_function_name = __webpack_require__("b0c0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.to-string.js
var es_regexp_to_string = __webpack_require__("25f0");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js







function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__("53ca");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.index-of.js
var es_array_index_of = __webpack_require__("c975");

// CONCATENATED MODULE: ./src/utils/array.js




var from = function from() {
  return Array.from.apply(Array, arguments);
};
var isArray = function isArray(val) {
  return Array.isArray(val);
};
var arrayIncludes = function arrayIncludes(array, value) {
  return array.indexOf(value) !== -1;
};
var concat = function concat() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return Array.prototype.concat.apply([], args);
};
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.filter.js
var es_array_filter = __webpack_require__("4de4");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.assign.js
var es_object_assign = __webpack_require__("cca6");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.freeze.js
var es_object_freeze = __webpack_require__("dca8");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.get-own-property-descriptor.js
var es_object_get_own_property_descriptor = __webpack_require__("e439");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.get-own-property-names.js
var es_object_get_own_property_names = __webpack_require__("7039");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.get-prototype-of.js
var es_object_get_prototype_of = __webpack_require__("3410");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.is.js
var es_object_is = __webpack_require__("2b19");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.is-frozen.js
var es_object_is_frozen = __webpack_require__("e21d");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.keys.js
var es_object_keys = __webpack_require__("b64b");

// CONCATENATED MODULE: ./src/utils/object.js




















var object_assign = function assign() {
  return Object.assign.apply(Object, arguments);
};
var create = function create(proto, optionalProps) {
  return Object.create(proto, optionalProps);
};
var defineProperties = function defineProperties(obj, props) {
  return Object.defineProperties(obj, props);
};
var object_defineProperty = function defineProperty(obj, prop, descr) {
  return Object.defineProperty(obj, prop, descr);
};
var freeze = function freeze(obj) {
  return Object.freeze(obj);
};
var getOwnPropertyNames = function getOwnPropertyNames(obj) {
  return Object.getOwnPropertyNames(obj);
};
var getOwnPropertyDescriptor = function getOwnPropertyDescriptor(obj, prop) {
  return Object.getOwnPropertyDescriptor(obj, prop);
};
var getOwnPropertySymbols = function getOwnPropertySymbols(obj) {
  return Object.getOwnPropertySymbols(obj);
};
var getPrototypeOf = function getPrototypeOf(obj) {
  return Object.getPrototypeOf(obj);
};
var is = function is(value1, value2) {
  return Object.is(value1, value2);
};
var isFrozen = function isFrozen(obj) {
  return Object.isFrozen(obj);
};
var keys = function keys(obj) {
  return Object.keys(obj);
};
var object_hasOwnProperty = function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};
var object_toString = function toString(obj) {
  return Object.prototype.toString.call(obj);
};
var object_isObject = function isObject(obj) {
  return obj !== null && Object(esm_typeof["a" /* default */])(obj) === "object";
};
var isPlainObject = function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
};
var object_clone = function clone(obj) {
  return Object(objectSpread2["a" /* default */])({}, obj);
};
var object_pick = function pick(obj, props) {
  return keys(obj).filter(function (key) {
    return props.indexOf(key) !== -1;
  }).reduce(function (result, key) {
    return Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, result), {}, Object(defineProperty["a" /* default */])({}, key, obj[key]));
  }, {});
};
var object_omit = function omit(obj, props) {
  return keys(obj).filter(function (key) {
    return props.indexOf(key) === -1;
  }).reduce(function (result, key) {
    return Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, result), {}, Object(defineProperty["a" /* default */])({}, key, obj[key]));
  }, {});
};
var readonlyDescriptor = function readonlyDescriptor() {
  return {
    enumerable: true,
    configurable: false,
    writable: false
  };
};
var object_deepFreeze = function deepFreeze(obj) {
  var props = keys(obj);
  props.forEach(function (prop) {
    var value = obj[prop];
    obj[prop] = value && (isPlainObject(value) || isArray(value)) ? deepFreeze(value) : value;
  });
  return freeze(obj);
};
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.set-prototype-of.js
var es_object_set_prototype_of = __webpack_require__("131a");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.reflect.construct.js
var es_reflect_construct = __webpack_require__("4ae1");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js


function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js



function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js


function _possibleConstructorReturn(self, call) {
  if (call && (Object(esm_typeof["a" /* default */])(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createSuper.js




function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.map.js
var es_map = __webpack_require__("4ec9");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js



function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/construct.js



function construct_construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    construct_construct = Reflect.construct;
  } else {
    construct_construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return construct_construct.apply(null, arguments);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js









function wrapNativeSuper_wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  wrapNativeSuper_wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct_construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return wrapNativeSuper_wrapNativeSuper(Class);
}
// EXTERNAL MODULE: ./src/utils/env.js
var env = __webpack_require__("e490");

// CONCATENATED MODULE: ./src/utils/safe-types.js





var w = env["f" /* hasWindowSupport */] ? window : {};
var safe_types_Element = env["f" /* hasWindowSupport */] ? w.Element : /*#__PURE__*/function (_Object) {
  _inherits(Element, _Object);

  var _super = _createSuper(Element);

  function Element() {
    _classCallCheck(this, Element);

    return _super.apply(this, arguments);
  }

  return Element;
}( /*#__PURE__*/wrapNativeSuper_wrapNativeSuper(Object));
var safe_types_HTMLElement = env["f" /* hasWindowSupport */] ? w.HTMLElement : /*#__PURE__*/function (_Element) {
  _inherits(HTMLElement, _Element);

  var _super2 = _createSuper(HTMLElement);

  function HTMLElement() {
    _classCallCheck(this, HTMLElement);

    return _super2.apply(this, arguments);
  }

  return HTMLElement;
}(safe_types_Element);
var safe_types_SVGElement = env["f" /* hasWindowSupport */] ? w.SVGElement : /*#__PURE__*/function (_Element2) {
  _inherits(SVGElement, _Element2);

  var _super3 = _createSuper(SVGElement);

  function SVGElement() {
    _classCallCheck(this, SVGElement);

    return _super3.apply(this, arguments);
  }

  return SVGElement;
}(safe_types_Element);
var safe_types_File = env["f" /* hasWindowSupport */] ? w.File : /*#__PURE__*/function (_Object2) {
  _inherits(File, _Object2);

  var _super4 = _createSuper(File);

  function File() {
    _classCallCheck(this, File);

    return _super4.apply(this, arguments);
  }

  return File;
}( /*#__PURE__*/wrapNativeSuper_wrapNativeSuper(Object));
// CONCATENATED MODULE: ./src/utils/inspect.js







var inspect_toType = function toType(val) {
  return Object(esm_typeof["a" /* default */])(val);
};
var toRawType = function toRawType(val) {
  return Object.prototype.toString.call(val).slice(8, -1);
};
var toRawTypeLC = function toRawTypeLC(val) {
  return toRawType(val).toLowerCase();
};
var isUndefined = function isUndefined(val) {
  return val === undefined;
};
var isNull = function isNull(val) {
  return val === null;
};
var isEmptyString = function isEmptyString(val) {
  return val === "";
};
var isUndefinedOrNull = function isUndefinedOrNull(val) {
  return isUndefined(val) || isNull(val);
};
var isUndefinedOrNullOrEmpty = function isUndefinedOrNullOrEmpty(val) {
  return isUndefinedOrNull(val) || isEmptyString(val);
};
var isFunction = function isFunction(val) {
  return inspect_toType(val) === "function";
};
var isBoolean = function isBoolean(val) {
  return inspect_toType(val) === "boolean";
};
var isString = function isString(val) {
  return inspect_toType(val) === "string";
};
var isNumber = function isNumber(val) {
  return inspect_toType(val) === "number";
};
var isPrimitive = function isPrimitive(val) {
  return isBoolean(val) || isString(val) || isNumber(val);
};
var isDate = function isDate(val) {
  return val instanceof Date;
};
var isEvent = function isEvent(val) {
  return val instanceof Event;
};
var inspect_isFile = function isFile(val) {
  return val instanceof safe_types_File;
};
var isRegExp = function isRegExp(val) {
  return toRawType(val) === "RegExp";
};
var isPromise = function isPromise(val) {
  return !isUndefinedOrNull(val) && isFunction(val.then) && isFunction(val.catch);
};

// CONCATENATED MODULE: ./src/utils/clone-deep.js







var clone_deep_cloneDeep = function cloneDeep(obj) {
  var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : obj;

  if (isArray(obj)) {
    return obj.reduce(function (result, val) {
      return [].concat(_toConsumableArray(result), [cloneDeep(val, val)]);
    }, []);
  }

  if (isPlainObject(obj)) {
    return keys(obj).reduce(function (result, key) {
      return Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, result), {}, Object(defineProperty["a" /* default */])({}, key, cloneDeep(obj[key], obj[key])));
    }, {});
  }

  return defaultValue;
};
/* harmony default export */ var clone_deep = (clone_deep_cloneDeep);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.every.js
var es_array_every = __webpack_require__("a623");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.split.js
var es_string_split = __webpack_require__("1276");

// CONCATENATED MODULE: ./src/utils/identity.js
var identity = function identity(x) {
  return x;
};

/* harmony default export */ var utils_identity = (identity);
// CONCATENATED MODULE: ./src/utils/get.js








var RX_ARRAY_NOTATION = /\[(\d+)]/g;

var get_get = function get(obj, path) {
  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  // Handle array of path values
  path = isArray(path) ? path.join(".") : path; // If no path or no object passed

  if (!path || !object_isObject(obj)) {
    return defaultValue;
  }

  if (path in obj) {
    return obj[path];
  } // Handle string array notation (numeric indices only)


  path = String(path).replace(RX_ARRAY_NOTATION, ".$1");
  var steps = path.split(".").filter(utils_identity); // Handle case where someone passes a string of only dots

  if (steps.length === 0) {
    return defaultValue;
  }

  return steps.every(function (step) {
    return object_isObject(obj) && step in obj && (obj = obj[step]) != null;
  }) ? obj : defaultValue;
};

/* harmony default export */ var utils_get = (get_get);
// CONCATENATED MODULE: ./src/utils/warn.js


/**
 * Log a warning message to the console with NlyAdminlteVue formatting
 * @param {string} message
 */

var warn_warn = function warn(message)
/* istanbul ignore next */
{
  var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (!Object(env["a" /* getNoWarn */])()) {
    console.warn("[NlyAdminlteVue warn]: ".concat(source ? "".concat(source, " - ") : "").concat(message));
  }
};
/**
 * Warn when no Promise support is given
 * @param {string} source
 * @returns {boolean} warned
 */

var warn_warnNotClient = function warnNotClient(source) {
  /* istanbul ignore else */
  if (env["g" /* isBrowser */]) {
    return false;
  } else {
    warn_warn("".concat(source, ": Can not be called during SSR."));
    return true;
  }
};
/**
 * Warn when no Promise support is given
 * @param {string} source
 * @returns {boolean} warned
 */

var warn_warnNoPromiseSupport = function warnNoPromiseSupport(source) {
  /* istanbul ignore else */
  if (env["e" /* hasPromiseSupport */]) {
    return false;
  } else {
    warn_warn("".concat(source, ": Requires Promise support."));
    return true;
  }
};
/**
 * Warn when no MutationObserver support is given
 * @param {string} source
 * @returns {boolean} warned
 */

var warn_warnNoMutationObserverSupport = function warnNoMutationObserverSupport(source) {
  /* istanbul ignore else */
  if (env["c" /* hasMutationObserverSupport */]) {
    return false;
  } else {
    warn_warn("".concat(source, ": Requires MutationObserver support."));
    return true;
  }
};
// CONCATENATED MODULE: ./src/utils/config-defaults.js

/* harmony default export */ var config_defaults = (object_deepFreeze({
  NlyButtonClose: {
    content: "&times;",
    textVariant: null,
    ariaLabel: "Close"
  },
  NlyListGroupItem: {
    variant: undefined
  },
  NlyProgress: {
    variant: null
  },
  NlyProgressBar: {
    variant: null
  },
  NlyToast: {
    toaster: "nly-toaster-top-right",
    autoHideDelay: 5000,
    variant: null,
    toastClass: null,
    headerClass: null,
    bodyClass: null
  },
  NlyToaster: {
    ariaLive: null,
    ariaAtomic: null,
    role: null
  },
  NlyTable: {
    selectedVariant: "active",
    headVariant: null,
    footVariant: null
  },
  NlyModal: {
    titleTag: "h5",
    size: "md",
    headerBgVariant: undefined,
    headerBorderVariant: undefined,
    headerTextVariant: undefined,
    headerCloseVariant: undefined,
    bodyBgVariant: undefined,
    bodyTextVariant: undefined,
    footerBgVariant: undefined,
    footerBorderVariant: undefined,
    footerTextVariant: undefined,
    cancelTitle: "Cancel",
    cancelVariant: "secondary",
    okTitle: "OK",
    okVariant: "primary",
    headerCloseContent: "&times;",
    headerCloseLabel: "Close"
  },
  NlyTime: {
    labelNoTimeSelected: "No time selected",
    labelSelected: "Selected time",
    labelHours: "Hours",
    labelMinutes: "Minutes",
    labelSeconds: "Seconds",
    labelAmpm: "AM/PM",
    // It would be nice to be able to get these from Intl.DateTimeFormat somehow
    labelAm: "AM",
    labelPm: "PM",
    // The following inherit from BFormSpinbutton if not provided
    labelIncrement: null,
    labelDecrement: null
  },
  NlyTooltip: {
    boundary: "scrollParent",
    boundaryPadding: 5,
    customClass: null,
    delay: 50,
    variant: null
  },
  NlyFormText: {
    textVariant: "muted"
  },
  NlyDropdown: {
    toggleText: "Nly Toggle Dropdown",
    size: undefined,
    variant: "secondary",
    splitVariant: undefined
  },
  NlyPopover: {
    boundary: "scrollParent",
    boundaryPadding: 5,
    customClass: undefined,
    delay: 50,
    variant: undefined
  },
  NlyBootstrapPagination: {
    size: undefined
  }
}));
// CONCATENATED MODULE: ./src/utils/config-set.js












 // --- Constants ---

var config_set_NAME = "NlyaConfig";
var PROP_NAME = "$nlyaConfig"; // Config manager class

var config_set_NlyaConfig = /*#__PURE__*/function () {
  function NlyaConfig() {
    _classCallCheck(this, NlyaConfig);

    // TODO: pre-populate with default config values (needs updated tests)
    // this.$_config = cloneDeep(DEFAULTS)
    this.$_config = {};
    this.$_cachedBreakpoints = null;
  }

  _createClass(NlyaConfig, [{
    key: "getDefaults",
    // Returns the defaults
    value: function getDefaults()
    /* istanbul ignore next */
    {
      return this.defaults;
    } // Method to merge in user config parameters

  }, {
    key: "setConfig",
    value: function setConfig() {
      var _this = this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!isPlainObject(config)) {
        /* istanbul ignore next */
        return;
      }

      var configKeys = getOwnPropertyNames(config);
      configKeys.forEach(function (cmpName) {
        /* istanbul ignore next */
        if (!object_hasOwnProperty(config_defaults, cmpName)) {
          warn_warn("Unknown config property \"".concat(cmpName, "\""), config_set_NAME);
          return;
        }

        var cmpConfig = config[cmpName];

        if (cmpName === "breakpoints") {
          // Special case for breakpoints
          var breakpoints = config.breakpoints;
          /* istanbul ignore if */

          if (!isArray(breakpoints) || breakpoints.length < 2 || breakpoints.some(function (b) {
            return !isString(b) || b.length === 0;
          })) {
            warn_warn('"breakpoints" must be an array of at least 2 breakpoint names', config_set_NAME);
          } else {
            _this.$_config.breakpoints = clone_deep(breakpoints);
          }
        } else if (isPlainObject(cmpConfig)) {
          // Component prop defaults
          var props = getOwnPropertyNames(cmpConfig);
          props.forEach(function (prop) {
            /* istanbul ignore if */
            if (!object_hasOwnProperty(config_defaults[cmpName], prop)) {
              warn_warn("Unknown config property \"".concat(cmpName, ".").concat(prop, "\""), config_set_NAME);
            } else {
              // TODO: If we pre-populate the config with defaults, we can skip this line
              _this.$_config[cmpName] = _this.$_config[cmpName] || {};

              if (!isUndefined(cmpConfig[prop])) {
                _this.$_config[cmpName][prop] = clone_deep(cmpConfig[prop]);
              }
            }
          });
        }
      });
    } // Clear the config. For testing purposes only

  }, {
    key: "resetConfig",
    value: function resetConfig() {
      this.$_config = {};
    } // Returns a deep copy of the user config

  }, {
    key: "getConfig",
    value: function getConfig() {
      return clone_deep(this.$_config);
    }
  }, {
    key: "getConfigValue",
    value: function getConfigValue(key) {
      // First we try the user config, and if key not found we fall back to default value
      // NOTE: If we deep clone DEFAULTS into config, then we can skip the fallback for get
      return clone_deep(utils_get(this.$_config, key, utils_get(config_defaults, key)));
    }
  }, {
    key: "defaults",
    get: function get()
    /* istanbul ignore next */
    {
      return config_defaults;
    }
  }], [{
    key: "Defaults",
    get: function get()
    /* istanbul ignore next */
    {
      return config_defaults;
    }
  }]);

  return NlyaConfig;
}(); // Method for applying a global config


var config_set_setConfig = function setConfig() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var Vue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : utils_vue;
  // Ensure we have a $nlyaConfig Object on the Vue prototype.
  // We set on Vue and OurVue just in case consumer has not set an alias of `vue`.
  Vue.prototype[PROP_NAME] = utils_vue.prototype[PROP_NAME] = Vue.prototype[PROP_NAME] || utils_vue.prototype[PROP_NAME] || new config_set_NlyaConfig(); // Apply the config values

  Vue.prototype[PROP_NAME].setConfig(config);
}; // Method for resetting the user config. Exported for testing purposes only.

var config_set_resetConfig = function resetConfig() {
  if (utils_vue.prototype[PROP_NAME] && utils_vue.prototype[PROP_NAME].resetConfig) {
    utils_vue.prototype[PROP_NAME].resetConfig();
  }
};
// CONCATENATED MODULE: ./src/utils/plugins.js








/**
 * 检测是否存在多个vue实列
 * @param {object} Vue
 */

var checkMultipleVue = function () {
  var checkMultipleVueWarned = false;
  var MULTIPLE_VUE_WARNING = [].join("\n");
  return function (Vue) {
    /* istanbul ignore next */
    if (!checkMultipleVueWarned && utils_vue !== Vue && !env["h" /* isJSDOM */]) {
      warn_warn(MULTIPLE_VUE_WARNING);
    }

    checkMultipleVueWarned = true;
  };
}();
/**
 * 注册组件，插件，指令 installFactory//nlyInstallFactory
 * @param {object} { components, directives }
 * @returns {function} plugin install function
 */

var plugins_nlyInstallFactory = function nlyInstallFactory() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      components = _ref.components,
      directives = _ref.directives,
      plugins = _ref.plugins;

  var install = function install(Vue) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (install.installed) {
      return;
    }

    install.installed = true;
    checkMultipleVue(Vue);
    config_set_setConfig(config, Vue);
    nlyRegisterComponents(Vue, components);
    nlyRegisterDirectives(Vue, directives);
    nlyRegisterPlugins(Vue, plugins);
  };

  install.installed = false;
  return install;
};
/**
 * 无配置选项插件组件，插件，指令注册.icon installFactoryNoConfig//nlyInstallFactoryNoConfig
 * @param {object} { components, directives }
 * @returns {function} plugin install function
 */

var nlyInstallFactoryNoConfig = function nlyInstallFactoryNoConfig() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      components = _ref2.components,
      directives = _ref2.directives,
      plugins = _ref2.plugins;

  // eslint-disable-next-line no-unused-vars
  var install = function install(Vue) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (install.installed) {
      /* istanbul ignore next */
      return;
    }

    install.installed = true;
    checkMultipleVue(Vue);
    nlyRegisterComponents(Vue, components);
    nlyRegisterDirectives(Vue, directives);
    nlyRegisterPlugins(Vue, plugins);
  };

  install.installed = false;
  return install;
};
/**
 * 插件注册工厂 pluginFactory//nlyPluginFactory
 * @param {object} { components, directives, plugins }
 * @returns {object} plugin install object
 */

var plugins_nlyPluginFactory = function nlyPluginFactory() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var extend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, extend), {}, {
    install: plugins_nlyInstallFactory(opts)
  });
};
/**
 * Plugin object factory function (no config option). pluginFactoryNoConfig//nlyPluginFactoryNoConfig
 * @param {object} { components, directives, plugins }
 * @returns {object} plugin install object
 */

var plugins_nlyPluginFactoryNoConfig = function nlyPluginFactoryNoConfig() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var extend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, extend), {}, {
    install: nlyInstallFactoryNoConfig(opts)
  });
};
/**
 * 注册插件  registerPlugins// nlyRegisterPlugins
 * @param {object} Vue
 * @param {object} Plugin definitions
 */

var nlyRegisterPlugins = function nlyRegisterPlugins(Vue) {
  var plugins = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  for (var plugin in plugins) {
    if (plugin && plugins[plugin]) {
      Vue.use(plugins[plugin]);
    }
  }
};
/**
 * 注册单个组件 registerComponent//nlyRegisterComponent
 * @param {object} Vue
 * @param {string} Component name
 * @param {object} 编写的插件
 */

var nlyRegisterComponent = function nlyRegisterComponent(Vue, name, def) {
  if (Vue && name && def) {
    Vue.component(name, def);
  }
};
/**
 * 注册多个组件
 * @param {object} Vue registerComponents // nlyRegisterComponents
 * @param {object} Object of component definitions
 */

var nlyRegisterComponents = function nlyRegisterComponents(Vue) {
  var components = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  for (var component in components) {
    nlyRegisterComponent(Vue, component, components[component]);
  }
};
/**
 * 注册指令
 * @param {object} Vue registerDirective//nlyRegisterDirective
 * @param {string} Directive name
 * @param {object} Directive definition
 */

var nlyRegisterDirective = function nlyRegisterDirective(Vue, name, def) {
  if (Vue && name && def) {
    // Ensure that any leading V is removed from the
    // name, as Vue adds it automatically
    Vue.directive(name.replace(/^VNly/, "Nly"), def);
  }
};
/**
 * 注册多个指令
 * @param {object} Vue registerDirectives//nlyRegisterDirectives
 * @param {object} Object of directive definitions
 */

var nlyRegisterDirectives = function nlyRegisterDirectives(Vue) {
  var directives = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  for (var directive in directives) {
    nlyRegisterDirective(Vue, directive, directives[directive]);
  }
};
/**
 * Install plugin if window.Vue available
 * @param {object} Plugin definition
 */

var plugins_vueUse = function vueUse(VuePlugin) {
  /* istanbul ignore next */
  if (env["f" /* hasWindowSupport */] && window.Vue) {
    window.Vue.use(VuePlugin);
  }
  /* istanbul ignore next */


  if (env["f" /* hasWindowSupport */] && VuePlugin.NAME) {
    window[VuePlugin.NAME] = VuePlugin;
  }
};
// CONCATENATED MODULE: ./src/utils/nly-config.js
var textSizeOptions = {
  xs: "text-xs",
  sm: "text-sm",
  md: "text-md",
  lg: "text-lg",
  xl: "text-xl"
};
var textVariantOptions = {
  primary: "text-primary",
  secondary: "text-secondary",
  success: "text-success",
  info: "text-info",
  warning: "text-warning",
  danger: "text-danger",
  light: "text-light",
  dark: "text-dark",
  lightblue: "text-lightblue",
  navy: "text-navy",
  olive: "text-olive",
  lime: "text-lime",
  fuchsia: "text-fuchsia",
  maroon: "text-maroon",
  blue: "text-blue",
  indigo: "text-indigo",
  purple: "text-purple",
  pink: "text-pink",
  red: "text-red",
  orange: "text-orange",
  yellow: "text-yellow",
  green: "text-green",
  teal: "text-teal",
  cyan: "text-cyan",
  white: "text-white",
  gray: "text-gray",
  graydark: "text-gray-dark"
};
var btnVariantOptinos = {
  dark: "btn-dark",
  light: "btn-light",
  default: "btn-default",
  primary: "btn-primary",
  secondary: "btn-secondary",
  success: "btn-success",
  info: "btn-info",
  danger: "btn-danger",
  warning: "btn-warning",
  outlineDark: "btn-outline-dark",
  outlineLight: "btn-outline-light",
  outlinePrimary: "btn-outline-primary",
  outlineSecondary: "btn-outline-secondary",
  outlineSuccess: "btn-outline-success",
  outlineInfo: "btn-outline-info",
  outlineDanger: "btn-outline-danger",
  outlineWarning: "btn-outline-warning"
};
var btnSizeOptions = {
  lg: "btn-lg",
  sm: "btn-sm",
  xs: "btn-xs"
};
var btnTypeOptions = {
  button: "button",
  submit: "submit"
};
var btnShapeOptions = {
  roundedFlat: "btn-flat",
  roundedPill: "rounded-pill",
  roundedCircle: "rounded-circle",
  roundedLg: "rounded-lg",
  roundedSm: "rounded-sm"
};
var btnGroupSizeOptions = {
  sm: "btn-group-sm",
  lg: "btn-group-lg"
};
var dropdownPlacementOptions = ["auto", "auto-start", "auto-end", "top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "right", "right-start", "right-end", "left", "left-start", "left-end"];
var navDropdownDirectionOptions = {
  down: "dropdown",
  left: "dropleft",
  right: "dropright",
  up: "dropup",
  none: ""
};
var navDropdownSizeOptions = {
  md: "dropdown-menu-md",
  lg: "dropdown-menu-lg",
  xl: "dropdown-menu-xl"
};
var navDropdownMenuDirectionOptions = {
  right: "dropdown-menu-right",
  left: "dropdown-menu-left"
};
var navDropdownShadowOptions = {
  shadow: "shadow",
  sm: "shadow-sm",
  lg: "shadow-lg",
  none: "shadow-none"
};
var navbarVariantOpitons = {
  primary: "navbar-primary",
  secondary: "navbar-secondary",
  success: "navbar-success",
  info: "navbar-info",
  warning: "navbar-warning",
  danger: "navbar-danger",
  lightblue: "navbar-lightblue",
  navy: "navbar-navy",
  olive: "navbar-olive",
  lime: "navbar-lime",
  fuchsia: "navbar-fuchsia",
  maroon: "navbar-maroon",
  blue: "navbar-blue",
  indigo: "navbar-indigo",
  purple: "navbar-purple",
  pink: "navbar-pink",
  red: "navbar-red",
  orange: "navbar-orange",
  yellow: "navbar-yellow",
  green: "navbar-green",
  teal: "navbar-teal",
  cyan: "navbar-cyan",
  white: "navbar-white",
  gray: "navbar-gray",
  graydark: "navbar-gray-dark",
  dark: "navbar-dark"
};
var sidebarBrandVariantOptions = {
  primary: "navbar-primary",
  secondary: "navbar-secondary",
  success: "navbar-success",
  info: "navbar-info",
  warning: "navbar-warning",
  danger: "navbar-danger",
  lightblue: "navbar-lightblue",
  light: "navbar-light",
  dark: "navbar-dark",
  navy: "navbar-navy",
  olive: "navbar-olive",
  lime: "navbar-lime",
  fuchsia: "navbar-fuchsia",
  maroon: "navbar-maroon",
  blue: "navbar-blue",
  indigo: "navbar-indigo",
  purple: "navbar-purple",
  pink: "navbar-pink",
  red: "navbar-red",
  orange: "navbar-orange",
  yellow: "navbar-yellow",
  green: "navbar-green",
  teal: "navbar-teal",
  cyan: "navbar-cyan",
  white: "navbar-white",
  gray: "navbar-gray",
  graydark: "navbar-gray-dark"
};
var sidebarElevationOptions = {
  sm: "elevation-1",
  md: "elevation-2",
  lg: "elevation-3",
  xl: "elevation-4"
};
var sidebarContainerVariantOpitons = {
  darkPrimary: "sidebar-dark-primary",
  darkWarning: "sidebar-dark-warning",
  darkInfo: "sidebar-dark-info",
  darkDanger: "sidebar-dark-danger",
  darkSuccess: "sidebar-dark-success",
  darkIndigo: "sidebar-dark-indigo",
  darkLightblue: "sidebar-dark-lightblue",
  darkNavy: "sidebar-dark-navy",
  darkPurple: "sidebar-dark-purple",
  darkFuchsia: "sidebar-dark-fuchsia",
  darkPink: "sidebar-dark-pink",
  darkMaroon: "sidebar-dark-maroon",
  darkOrange: "sidebar-dark-orange",
  darkLime: "sidebar-dark-lime",
  darkTeal: "sidebar-dark-teal",
  darkOlive: "sidebar-dark-olive",
  lightPrimary: "sidebar-light-primary",
  lightWarning: "sidebar-light-warning",
  lightInfo: "sidebar-light-info",
  lightDanger: "sidebar-light-danger",
  lightSuccess: "sidebar-light-success",
  lightIndigo: "sidebar-light-indigo",
  lightLightblue: "sidebar-light-lightblue",
  lightNavy: "sidebar-light-navy",
  lightPurple: "sidebar-light-purple",
  lightFuchsia: "sidebar-light-fuchsia",
  lightPink: "sidebar-light-pink",
  lightMaroon: "sidebar-light-maroon",
  lightOrange: "sidebar-light-orange",
  lightLime: "sidebar-light-lime",
  lightTeal: "sidebar-light-teal",
  lightOlive: "sidebar-light-olive"
};
var sidebarNavShapeOptions = {
  pill: "nav-pills",
  flat: "nav-flat",
  legacy: "nav-legacy",
  compact: "nav-compact"
};
var switchVariantOptions = {
  off: {
    primary: "custom-switch-off-primary",
    secondary: "custom-switch-off-secondary",
    success: "custom-switch-off-success",
    info: "custom-switch-off-info",
    warning: "custom-switch-off-warning",
    danger: "custom-switch-off-danger",
    light: "custom-switch-off-light",
    dark: "custom-switch-off-dark",
    lightblue: "custom-switch-off-lightblue",
    navy: "custom-switch-off-navy",
    olive: "custom-switch-off-olive",
    lime: "custom-switch-off-lime",
    fuchsia: "custom-switch-off-fuchsia",
    maroon: "custom-switch-off-maroon",
    blue: "custom-switch-off-blue",
    indigo: "custom-switch-off-indigo",
    purple: "custom-switch-off-purple",
    pink: "custom-switch-off-pink",
    red: "custom-switch-off-red",
    orange: "custom-switch-off-orange",
    yellow: "custom-switch-off-yellow",
    green: "custom-switch-off-green",
    teal: "custom-switch-off-teal",
    cyan: "custom-switch-off-cyan",
    white: "custom-switch-off-white",
    gray: "custom-switch-off-gray",
    graydark: "custom-switch-off-gray-dark"
  },
  on: {
    primary: "custom-switch-on-primary",
    secondary: "custom-switch-on-secondary",
    success: "custom-switch-on-success",
    info: "custom-switch-on-info",
    warning: "custom-switch-on-warning",
    danger: "custom-switch-on-danger",
    light: "custom-switch-on-light",
    dark: "custom-switch-on-dark",
    lightblue: "custom-switch-on-lightblue",
    navy: "custom-switch-on-navy",
    olive: "custom-switch-on-olive",
    lime: "custom-switch-on-lime",
    fuchsia: "custom-switch-on-fuchsia",
    maroon: "custom-switch-on-maroon",
    blue: "custom-switch-on-blue",
    indigo: "custom-switch-on-indigo",
    purple: "custom-switch-on-purple",
    pink: "custom-switch-on-pink",
    red: "custom-switch-on-red",
    orange: "custom-switch-on-orange",
    yellow: "custom-switch-on-yellow",
    green: "custom-switch-on-green",
    teal: "custom-switch-on-teal",
    cyan: "custom-switch-on-cyan",
    white: "custom-switch-on-white",
    gray: "custom-switch-on-gray",
    graydark: "custom-switch-on-gray-dark"
  }
};
var switchSizeOptions = {
  sm: "nly-custom-control-sm",
  lg: "nly-custom-control-lg"
};
var bgVariantOptions = {
  primary: "bg-primary",
  secondary: "bg-secondary",
  success: "bg-success",
  info: "bg-info",
  warning: "bg-warning",
  danger: "bg-danger",
  light: "bg-light",
  dark: "bg-dark",
  lightblue: "bg-lightblue",
  navy: "bg-navy",
  olive: "bg-olive",
  lime: "bg-lime",
  fuchsia: "bg-fuchsia",
  maroon: "bg-maroon",
  blue: "bg-blue",
  indigo: "bg-indigo",
  purple: "bg-purple",
  pink: "bg-pink",
  red: "bg-red",
  orange: "bg-orange",
  yellow: "bg-yellow",
  green: "bg-green",
  teal: "bg-teal",
  cyan: "bg-cyan",
  white: "bg-white",
  gray: "bg-gray",
  graydark: "bg-gray-dark"
};
var bgGradientOptions = {
  primary: "bg-gradient-primary",
  secondary: "bg-gradient-secondary",
  success: "bg-gradient-success",
  info: "bg-gradient-info",
  danger: "bg-gradient-danger",
  warning: "bg-gradient-warning",
  light: "bg-gradient-light",
  dark: "bg-gradient-dark",
  lightblue: "bg-gradient-lightblue",
  navy: "bg-gradient-navy",
  olive: "bg-gradient-olive",
  lime: "bg-gradient-lime",
  fuchsia: "bg-gradient-fuchsia",
  maroon: "bg-gradient-maroon",
  blue: "bg-gradient-blue",
  indigo: "bg-gradient-indigo",
  purple: "bg-gradient-purple",
  pink: "bg-gradient-pink",
  red: "bg-gradient-red",
  orange: "bg-gradient-orange",
  yellow: "bg-gradient-yellow",
  green: "bg-gradient-green",
  teal: "bg-gradient-teal",
  cyan: "bg-gradient-cyan",
  white: "bg-gradient-white",
  gray: "bg-gradient-gray",
  graydark: "bg-gradient-gray-dark"
};
var cardGroupTypeOption = {
  default: "card-group",
  deck: "card-deck",
  columns: "card-columns",
  accordion: "accordion"
};
var cardVariantOptions = {
  primary: "card-primary",
  secondary: "card-secondary",
  succes: "card-succes",
  info: "card-info",
  warning: "card-warning",
  danger: "card-danger",
  light: "card-light",
  dark: "card-dark",
  lightblue: "card-lightblue",
  navy: "card-navy",
  olive: "card-olive",
  lime: "card-lime",
  fuchsia: "card-fuchsia",
  maroon: "card-maroon",
  blue: "card-blue",
  indigo: "card-indigo",
  purple: "card-purple",
  pink: "card-pink",
  red: "card-red",
  orange: "card-orange",
  yellow: "card-yellow",
  green: "card-green",
  teal: "card-teal",
  cyan: "card-cyan",
  white: "card-white",
  gray: "card-gray",
  graydark: "card-gray-dark"
};
var badgeVariantOptions = {
  primary: "badge-primary",
  secondary: "badge-secondary",
  success: "badge-success",
  info: "badge-info",
  warning: "badge-warning",
  danger: "badge-danger",
  light: "badge-light",
  dark: "badge-dark"
};
var inputTypeOptions = ["text", "password", "email", "number", "url", "tel", "search", "range", "color", "date", "time", "datetime", "datetime-local", "month", "week"];
var inputMaxMinStepOptions = ["number", "range", "date", "datetime", "datetime-local", "month", "time", "week"];
var formValidOptions = ["valid", "invalid", "warning", "loading", "novalid"];
var formFeedBackValidOptions = {
  valid: "valid-feedback",
  invalid: "invalid-feedback",
  warning: "warning-feedback"
};
var formFeedBackTooltipOptions = {
  valid: "valid-tooltip",
  invalid: "invalid-tooltip",
  warning: "warning-tooltip"
};
var breakPointValidOptions = ["xs", "sm", "md", "lg", "lx"];
var breakPointOptions = {
  xs: 0,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200
};
var rowAlignHOptions = ["start", "center", "end", "around", "between"];
var rowAlignVOptions = ["start", "baseline", "end", "stretch", "center"];
var colAlignSelfOptions = ["start", "center", "end", "baseline", "stretch"];
var formGroupSize = ["sm", "lg"];
// CONCATENATED MODULE: ./src/utils/get-options.js

var nlyGetOptionsByValueInclusion = function nlyGetOptionsByValueInclusion(propOptions, prop) {
  for (var propOption in propOptions) {
    if (propOptions[propOption].indexOf(prop) != -1) {
      return propOptions[propOption];
    }
  }
};
var nlyGetOptionsByKeyEqual = function nlyGetOptionsByKeyEqual(propOptions, prop) {
  for (var propOption in propOptions) {
    if (propOption == prop) {
      return propOptions[propOption];
    }
  }
};
var nlyGetOptionsByItem = function nlyGetOptionsByItem(propOptions, prop) {
  if (propOptions.indexOf(prop) != -1) {
    return prop;
  }
};
var nlyGetOptionInclusion = function nlyGetOptionInclusion(options, value) {
  return options.indexOf(value) !== -1;
};
// CONCATENATED MODULE: ./node_modules/vue-functional-data-merge/dist/lib.esm.js
var lib_esm_e=function(){return(lib_esm_e=Object.assign||function(e){for(var t,r=1,s=arguments.length;r<s;r++)for(var a in t=arguments[r])Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a]);return e}).apply(this,arguments)},lib_esm_t={kebab:/-(\w)/g,styleProp:/:(.*)/,styleList:/;(?![^(]*\))/g};function r(e,t){return t?t.toUpperCase():""}function s(e){for(var s,a={},c=0,o=e.split(lib_esm_t.styleList);c<o.length;c++){var n=o[c].split(lib_esm_t.styleProp),i=n[0],l=n[1];(i=i.trim())&&("string"==typeof l&&(l=l.trim()),a[(s=i,s.replace(lib_esm_t.kebab,r))]=l)}return a}function lib_esm_a(){for(var t,r,a={},c=arguments.length;c--;)for(var o=0,n=Object.keys(arguments[c]);o<n.length;o++)switch(t=n[o]){case"class":case"style":case"directives":if(Array.isArray(a[t])||(a[t]=[]),"style"===t){var i=void 0;i=Array.isArray(arguments[c].style)?arguments[c].style:[arguments[c].style];for(var l=0;l<i.length;l++){var y=i[l];"string"==typeof y&&(i[l]=s(y))}arguments[c].style=i}a[t]=a[t].concat(arguments[c][t]);break;case"staticClass":if(!arguments[c][t])break;void 0===a[t]&&(a[t]=""),a[t]&&(a[t]+=" "),a[t]+=arguments[c][t].trim();break;case"on":case"nativeOn":a[t]||(a[t]={});for(var p=0,f=Object.keys(arguments[c][t]||{});p<f.length;p++)r=f[p],a[t][r]?a[t][r]=[].concat(a[t][r],arguments[c][t][r]):a[t][r]=arguments[c][t][r];break;case"attrs":case"props":case"domProps":case"scopedSlots":case"staticStyle":case"hook":case"transition":a[t]||(a[t]={}),a[t]=lib_esm_e({},arguments[c][t],a[t]);break;case"slot":case"key":case"ref":case"tag":case"show":case"keepAlive":default:a[t]||(a[t]=arguments[c][t])}return a}
//# sourceMappingURL=lib.esm.js.map

// CONCATENATED MODULE: ./src/components/badge/badge.js




var badge_name = "NlyBadge";
var badge_props = {
  size: {
    type: String
  },
  variant: {
    type: String
  },
  bgVariant: {
    type: String
  },
  bgGradientVariant: {
    type: String
  },
  badgeClass: {
    type: String
  },
  tag: {
    type: String,
    default: "span"
  },
  pill: {
    type: Boolean,
    default: false
  }
};

var badge_customClass = function customClass(props) {
  var bgVariant = function bgVariant() {
    return nlyGetOptionsByKeyEqual(bgVariantOptions, props.bgVariant);
  };

  var size = function size() {
    return nlyGetOptionsByKeyEqual(textSizeOptions, props.size);
  };

  var pill = props.pill ? "badge-pill" : "";

  var variant = function variant() {
    return nlyGetOptionsByKeyEqual(badgeVariantOptions, props.variant);
  };

  var bgGradientVariant = function bgGradientVariant() {
    return nlyGetOptionsByKeyEqual(bgGradientOptions, props.bgGradientVariant);
  };

  var badgeClass = props.badgeClass;
  return [bgVariant(), size(), badgeClass, pill, variant(), bgGradientVariant()];
};

var NlyBadge = utils_vue.extend({
  name: badge_name,
  functional: true,
  props: badge_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "badge",
      class: badge_customClass(props)
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/badge/index.js


var BadgePlugin = plugins_nlyPluginFactory({
  components: {
    NlyBadge: NlyBadge
  }
});

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.constructor.js
var es_number_constructor = __webpack_require__("a9e3");

// CONCATENATED MODULE: ./src/utils/nly-event.class.js






var nly_event_class_NlyEvent = /*#__PURE__*/function () {
  function NlyEvent(type) {
    var eventInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, NlyEvent);

    if (!type) {
      throw new TypeError("Failed to construct '".concat(this.constructor.name, "'. 1 argument required, ").concat(arguments.length, " given."));
    }

    object_assign(this, NlyEvent.Defaults, this.constructor.Defaults, eventInit, {
      type: type
    });
    defineProperties(this, {
      type: readonlyDescriptor(),
      cancelable: readonlyDescriptor(),
      nativeEvent: readonlyDescriptor(),
      target: readonlyDescriptor(),
      relatedTarget: readonlyDescriptor(),
      vueTarget: readonlyDescriptor(),
      componentId: readonlyDescriptor()
    });
    var defaultPrevented = false;

    this.preventDefault = function preventDefault() {
      if (this.cancelable) {
        defaultPrevented = true;
      }
    };

    object_defineProperty(this, "defaultPrevented", {
      enumerable: true,
      get: function get() {
        return defaultPrevented;
      }
    });
  }

  _createClass(NlyEvent, null, [{
    key: "Defaults",
    get: function get() {
      return {
        type: "",
        cancelable: true,
        nativeEvent: null,
        target: null,
        relatedTarget: null,
        vueTarget: null,
        componentId: null
      };
    }
  }]);

  return NlyEvent;
}();


// CONCATENATED MODULE: ./src/utils/memoize.js


var memoize_memoize = function memoize(fn) {
  var cache = create(null);
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var argsKey = JSON.stringify(args);
    return cache[argsKey] = cache[argsKey] || fn.apply(null, args);
  };
};

/* harmony default export */ var utils_memoize = (memoize_memoize);
// CONCATENATED MODULE: ./src/utils/config.js






var config_PROP_NAME = "$nlyConfig";
var VueProto = utils_vue.prototype;
var config_getConfig = function getConfig() {
  return VueProto[config_PROP_NAME] ? VueProto[config_PROP_NAME].getConfig() : {};
};
var config_getConfigValue = function getConfigValue(key) {
  return VueProto[config_PROP_NAME] ? VueProto[config_PROP_NAME].getConfigValue(key) : clone_deep(utils_get(config_defaults, key));
};
var getComponentConfig = function getComponentConfig(cmpName) {
  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return key ? config_getConfigValue("".concat(cmpName, ".").concat(key)) : config_getConfigValue(cmpName) || {};
};
var getBreakpoints = function getBreakpoints() {
  return config_getConfigValue("breakpoints");
};

var _getBreakpointsCached = utils_memoize(function () {
  return getBreakpoints();
});

var config_getBreakpointsCached = function getBreakpointsCached() {
  return clone_deep(_getBreakpointsCached());
};
var getBreakpointsUp = function getBreakpointsUp() {
  var breakpoints = getBreakpoints();
  breakpoints[0] = "";
  return breakpoints;
};
var getBreakpointsUpCached = utils_memoize(function () {
  var breakpoints = config_getBreakpointsCached();
  breakpoints[0] = "";
  return breakpoints;
});
var getBreakpointsDown = function getBreakpointsDown() {
  var breakpoints = getBreakpoints();
  breakpoints[breakpoints.length - 1] = "";
  return breakpoints;
};
var getBreakpointsDownCached = function getBreakpointsDownCached() {
  var breakpoints = config_getBreakpointsCached();
  breakpoints[breakpoints.length - 1] = "";
  return breakpoints;
};
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.map.js
var es_array_map = __webpack_require__("d81d");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.to-fixed.js
var es_number_to_fixed = __webpack_require__("b680");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.trim.js
var es_string_trim = __webpack_require__("498a");

// CONCATENATED MODULE: ./src/utils/string.js






// String utilities
 // --- Constants ---

var RX_TRIM_LEFT = /^\s+/;
var RX_TRIM_RIGHT = /\s+$/;
var RX_REGEXP_REPLACE = /[-/\\^$*+?.()|[\]{}]/g;
var RX_UN_KEBAB = /-(\w)/g;
var RX_HYPHENATE = /\B([A-Z])/g; // --- Utilities ---
// Converts PascalCase or camelCase to kebab-case

var kebabCase = function kebabCase(str) {
  return str.replace(RX_HYPHENATE, "-$1").toLowerCase();
}; // Converts a kebab-case or camelCase string to PascalCase

var pascalCase = function pascalCase(str) {
  str = kebabCase(str).replace(RX_UN_KEBAB, function (_, c) {
    return c ? c.toUpperCase() : "";
  });
  return str.charAt(0).toUpperCase() + str.slice(1);
}; // Lowercases the first letter of a string and returns a new string

var string_lowerFirst = function lowerFirst(str) {
  str = isString(str) ? str.trim() : String(str);
  return str.charAt(0).toLowerCase() + str.slice(1);
}; // Uppercases the first letter of a string and returns a new string

var string_upperFirst = function upperFirst(str) {
  str = isString(str) ? str.trim() : String(str);
  return str.charAt(0).toUpperCase() + str.slice(1);
}; // Escape characters to be used in building a regular expression

var escapeRegExp = function escapeRegExp(str) {
  return str.replace(RX_REGEXP_REPLACE, "\\$&");
};
var string_toString = function toString(val) {
  var spaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  return isUndefinedOrNull(val) ? "" : isArray(val) || isPlainObject(val) && val.toString === Object.prototype.toString ? JSON.stringify(val, null, spaces) : String(val);
};
var trimLeft = function trimLeft(str) {
  return string_toString(str).replace(RX_TRIM_LEFT, "");
};
var trimRight = function trimRight(str) {
  return string_toString(str).replace(RX_TRIM_RIGHT, "");
};
var trim = function trim(str) {
  return string_toString(str).trim();
};
var lowerCase = function lowerCase(str) {
  return string_toString(str).toLowerCase();
};
var upperCase = function upperCase(str) {
  return string_toString(str).toUpperCase();
};
// CONCATENATED MODULE: ./src/utils/number.js



 // 换成十进制数字

var toInteger = function toInteger(val) {
  return parseInt(val, 10);
}; // 换成浮点数

var toFloat = function toFloat(val) {
  return parseFloat(val);
}; // 保留小数点

var toFixed = function toFixed(val, precision) {
  return toFloat(val).toFixed(toInteger(precision) || 0);
};
var number_toCurrency = function toCurrency(val) {
  var getVal = string_toString(val);
  return getVal.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
};
// CONCATENATED MODULE: ./src/utils/dom.js










var TABABLE_SELECTOR = ["button", "[href]:not(.disabled)", "input", "select", "textarea", "[tabindex]", "[contenteditable]"].map(function (s) {
  return "".concat(s, ":not(:disabled):not([disabled])");
}).join(", ");
var dom_w = env["f" /* hasWindowSupport */] ? window : {};
var d = env["b" /* hasDocumentSupport */] ? document : {};
var elProto = typeof Element !== "undefined" ? Element.prototype : {};
var matchesEl = elProto.matches || elProto.msMatchesSelector || elProto.webkitMatchesSelector;
var closestEl = elProto.closest || function (sel) {
  var el = this;

  do {
    if (matches(el, sel)) {
      return el;
    }

    el = el.parentElement || el.parentNode;
  } while (!isNull(el) && el.nodeType === Node.ELEMENT_NODE);

  return null;
};
var requestAF = dom_w.requestAnimationFrame || dom_w.webkitRequestAnimationFrame || dom_w.mozRequestAnimationFrame || dom_w.msRequestAnimationFrame || dom_w.oRequestAnimationFrame || function (cb) {
  return setTimeout(cb, 16);
};
var MutationObs = dom_w.MutationObserver || dom_w.WebKitMutationObserver || dom_w.MozMutationObserver || null;
var removeNode = function removeNode(el) {
  return el && el.parentNode && el.parentNode.removeChild(el);
};
var isElement = function isElement(el) {
  return !!(el && el.nodeType === Node.ELEMENT_NODE);
};
var dom_getActiveElement = function getActiveElement() {
  var excludes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var activeElement = d.activeElement;
  return activeElement && !excludes.some(function (el) {
    return el === activeElement;
  }) ? activeElement : null;
};
var dom_isTag = function isTag(tag, name) {
  return string_toString(tag).toLowerCase() === string_toString(name).toLowerCase();
};
var isActiveElement = function isActiveElement(el) {
  return isElement(el) && el === dom_getActiveElement();
};
var isVisible = function isVisible(el) {
  if (!isElement(el) || !el.parentNode || !dom_contains(d.body, el)) {
    return false;
  }

  if (el.style.display === "none") {
    return false;
  }

  var bcr = getBCR(el);
  return !!(bcr && bcr.height > 0 && bcr.width > 0);
};
var dom_isDisabled = function isDisabled(el) {
  return !isElement(el) || el.disabled || hasAttr(el, "disabled") || hasClass(el, "disabled");
};
var reflow = function reflow(el) {
  return isElement(el) && el.offsetHeight;
};
var dom_selectAll = function selectAll(selector, root) {
  return from((isElement(root) ? root : d).querySelectorAll(selector));
};
var dom_select = function select(selector, root) {
  return (isElement(root) ? root : d).querySelector(selector) || null;
};
var matches = function matches(el, selector) {
  return isElement(el) ? matchesEl.call(el, selector) : false;
};
var closest = function closest(selector, root) {
  var includeRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (!isElement(root)) {
    return null;
  }

  var el = closestEl.call(root, selector);
  return includeRoot ? el : el === root ? null : el;
};
var dom_contains = function contains(parent, child) {
  return parent && isFunction(parent.contains) ? parent.contains(child) : false;
};
var getById = function getById(id) {
  return d.getElementById(/^#/.test(id) ? id.slice(1) : id) || null;
};
var addClass = function addClass(el, className) {
  if (className && isElement(el) && el.classList) {
    el.classList.add(className);
  }
};
var removeClass = function removeClass(el, className) {
  if (className && isElement(el) && el.classList) {
    el.classList.remove(className);
  }
};
var hasClass = function hasClass(el, className) {
  if (className && isElement(el) && el.classList) {
    return el.classList.contains(className);
  }

  return false;
};
var setAttr = function setAttr(el, attr, val) {
  if (attr && isElement(el)) {
    el.setAttribute(attr, val);
  }
};
var removeAttr = function removeAttr(el, attr) {
  if (attr && isElement(el)) {
    el.removeAttribute(attr);
  }
};
var getAttr = function getAttr(el, attr) {
  return attr && isElement(el) ? el.getAttribute(attr) : null;
};
var hasAttr = function hasAttr(el, attr) {
  return attr && isElement(el) ? el.hasAttribute(attr) : null;
};
var getBCR = function getBCR(el) {
  return isElement(el) ? el.getBoundingClientRect() : null;
};
var dom_getCS = function getCS(el) {
  return env["f" /* hasWindowSupport */] && isElement(el) ? dom_w.getComputedStyle(el) : {};
};
var dom_getSel = function getSel() {
  return env["f" /* hasWindowSupport */] && dom_w.getSelection ? dom_w.getSelection() : null;
};
var offset = function offset(el) {
  var _offset = {
    top: 0,
    left: 0
  };

  if (!isElement(el) || el.getClientRects().length === 0) {
    return _offset;
  }

  var bcr = getBCR(el);

  if (bcr) {
    var win = el.ownerDocument.defaultView;
    _offset.top = bcr.top + win.pageYOffset;
    _offset.left = bcr.left + win.pageXOffset;
  }

  return _offset;
};
var dom_position = function position(el) {
  var _offset = {
    top: 0,
    left: 0
  };

  if (!isElement(el)) {
    return _offset;
  }

  var parentOffset = {
    top: 0,
    left: 0
  };
  var elStyles = dom_getCS(el);

  if (elStyles.position === "fixed") {
    _offset = getBCR(el) || _offset;
  } else {
    _offset = offset(el);
    var doc = el.ownerDocument;
    var offsetParent = el.offsetParent || doc.documentElement;

    while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && dom_getCS(offsetParent).position === "static") {
      offsetParent = offsetParent.parentNode;
    }

    if (offsetParent && offsetParent !== el && offsetParent.nodeType === Node.ELEMENT_NODE) {
      parentOffset = offset(offsetParent);
      var offsetParentStyles = dom_getCS(offsetParent);
      parentOffset.top += toFloat(offsetParentStyles.borderTopWidth, 0);
      parentOffset.left += toFloat(offsetParentStyles.borderLeftWidth, 0);
    }
  }

  return {
    top: _offset.top - parentOffset.top - toFloat(elStyles.marginTop, 0),
    left: _offset.left - parentOffset.left - toFloat(elStyles.marginLeft, 0)
  };
};
var dom_getTabables = function getTabables() {
  var rootEl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
  return dom_selectAll(TABABLE_SELECTOR, rootEl).filter(isVisible).filter(function (el) {
    return el.tabIndex > -1 && !el.disabled;
  });
};
var dom_attemptFocus = function attemptFocus(el) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  try {
    el.focus(options); // eslint-disable-next-line no-empty
  } catch (_unused) {}

  return isActiveElement(el);
};
var attemptBlur = function attemptBlur(el) {
  try {
    el.blur(); // eslint-disable-next-line no-empty
  } catch (_unused2) {}

  return !isActiveElement(el);
};
// CONCATENATED MODULE: ./src/utils/math.js
// Math utilty functions
var mathMin = Math.min;
var mathMax = Math.max;
var mathAbs = Math.abs;
var mathCeil = Math.ceil;
var mathFloor = Math.floor;
var mathPow = Math.pow;
var mathRound = Math.round;
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.find.js
var es_array_find = __webpack_require__("7db0");

// CONCATENATED MODULE: ./src/utils/key-codes.js
/*
 * Key Codes (events)
 */

var KEY_CODES = freeze({
  SPACE: 32,
  ENTER: 13,
  ESC: 27,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  PAGEUP: 33,
  PAGEDOWN: 34,
  HOME: 36,
  END: 35,
  TAB: 9,
  SHIFT: 16,
  CTRL: 17,
  BACKSPACE: 8,
  ALT: 18,
  PAUSE: 19,
  BREAK: 19,
  INSERT: 45,
  INS: 45,
  DELETE: 46
});
/* harmony default export */ var key_codes = (KEY_CODES);
// CONCATENATED MODULE: ./src/utils/range.js
/**
 * @param {number} length
 * @return {Array}
 */
var range = function range(length) {
  return Array.apply(null, {
    length: length
  });
};

/* harmony default export */ var utils_range = (range);
// CONCATENATED MODULE: ./src/utils/events.js


var EVENT_OPTIONS_PASSIVE = {
  passive: true
};
var EVENT_OPTIONS_NO_CAPTURE = {
  passive: true,
  capture: false
};
var events_parseEventOptions = function parseEventOptions(options) {
  if (env["d" /* hasPassiveEventSupport */]) {
    return object_isObject(options) ? options : {
      capture: !!options || false
    };
  } else {
    return !!(object_isObject(options) ? options.capture : options);
  }
};
var eventOn = function eventOn(el, evtName, handler, options) {
  if (el && el.addEventListener) {
    el.addEventListener(evtName, handler, events_parseEventOptions(options));
  }
};
var eventOff = function eventOff(el, evtName, handler, options) {
  if (el && el.removeEventListener) {
    el.removeEventListener(evtName, handler, events_parseEventOptions(options));
  }
};
var eventOnOff = function eventOnOff(on) {
  var method = on ? eventOn : eventOff;

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  method.apply(void 0, args);
};
var stopEvent = function stopEvent(evt) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$preventDefault = _ref.preventDefault,
      preventDefault = _ref$preventDefault === void 0 ? true : _ref$preventDefault,
      _ref$propagation = _ref.propagation,
      propagation = _ref$propagation === void 0 ? true : _ref$propagation,
      _ref$immediatePropaga = _ref.immediatePropagation,
      immediatePropagation = _ref$immediatePropaga === void 0 ? false : _ref$immediatePropaga;

  if (preventDefault) {
    evt.preventDefault();
  }

  if (propagation) {
    evt.stopPropagation();
  }

  if (immediatePropagation) {
    evt.stopImmediatePropagation();
  }
};
// CONCATENATED MODULE: ./src/utils/normalize-slot.js






var normalize_slot_hasNormalizedSlot = function hasNormalizedSlot(names) {
  var $scopedSlots = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var $slots = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  names = concat(names).filter(utils_identity);
  return names.some(function (name) {
    return $scopedSlots[name] || $slots[name];
  });
};

var normalize_slot_normalizeSlot = function normalizeSlot(names) {
  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var $scopedSlots = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var $slots = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  names = concat(names).filter(utils_identity);
  var slot;

  for (var i = 0; i < names.length && !slot; i++) {
    var name = names[i];
    slot = $scopedSlots[name] || $slots[name];
  }

  return isFunction(slot) ? slot(scope) : slot;
};


/* harmony default export */ var normalize_slot = (normalize_slot_normalizeSlot);
// CONCATENATED MODULE: ./src/mixins/normalize-slot.js


/* harmony default export */ var mixins_normalize_slot = ({
  methods: {
    hasNormalizedSlot: function hasNormalizedSlot(names) {
      return normalize_slot_hasNormalizedSlot(names, this.$scopedSlots, this.$slots);
    },
    normalizeSlot: function normalizeSlot(names) {
      var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var vNodes = normalize_slot_normalizeSlot(names, scope, this.$scopedSlots, this.$slots);

      return vNodes ? concat(vNodes) : vNodes;
    }
  }
});
// CONCATENATED MODULE: ./src/utils/router.js

















var ANCHOR_TAG = "a"; // Precompile RegExp

var commaRE = /%2C/g;
var encodeReserveRE = /[!'()*]/g;
var plusRE = /\+/g;
var queryStartRE = /^(\?|#|&)/; // Method to replace reserved chars

var encodeReserveReplacer = function encodeReserveReplacer(c) {
  return "%" + c.charCodeAt(0).toString(16);
}; // Fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!'()*]
// - preserve commas


var router_encode = function encode(str) {
  return encodeURIComponent(string_toString(str)).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ",");
};

var decode = decodeURIComponent; // Stringifies an object of query parameters
// See: https://github.com/vuejs/vue-router/blob/dev/src/util/query.js

var router_stringifyQueryObj = function stringifyQueryObj(obj) {
  if (!isPlainObject(obj)) {
    return "";
  }

  var query = keys(obj).map(function (key) {
    var val = obj[key];

    if (isUndefined(val)) {
      return "";
    } else if (isNull(val)) {
      return router_encode(key);
    } else if (isArray(val)) {
      return val.reduce(function (results, val2) {
        if (isNull(val2)) {
          results.push(router_encode(key));
        } else if (!isUndefined(val2)) {
          // Faster than string interpolation
          results.push(router_encode(key) + "=" + router_encode(val2));
        }

        return results;
      }, []).join("&");
    } // Faster than string interpolation


    return router_encode(key) + "=" + router_encode(val);
  })
  /* must check for length, as we only want to filter empty strings, not things that look falsey! */
  .filter(function (x) {
    return x.length > 0;
  }).join("&");
  return query ? "?".concat(query) : "";
};
var router_parseQuery = function parseQuery(query) {
  var parsed = {};
  query = string_toString(query).trim().replace(queryStartRE, "");

  if (!query) {
    return parsed;
  }

  query.split("&").forEach(function (param) {
    var parts = param.replace(plusRE, " ").split("=");
    var key = decode(parts.shift());
    var val = parts.length > 0 ? decode(parts.join("=")) : null;

    if (isUndefined(parsed[key])) {
      parsed[key] = val;
    } else if (isArray(parsed[key])) {
      parsed[key].push(val);
    } else {
      parsed[key] = [parsed[key], val];
    }
  });
  return parsed;
};
var isLink = function isLink(props) {
  return !!(props.href || props.to);
};
var router_isRouterLink = function isRouterLink(tag) {
  return !dom_isTag(tag, ANCHOR_TAG);
};
var computeTag = function computeTag() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      to = _ref.to,
      disabled = _ref.disabled,
      routerComponentName = _ref.routerComponentName;

  var thisOrParent = arguments.length > 1 ? arguments[1] : undefined;
  var hasRouter = thisOrParent.$router;

  if (!hasRouter || hasRouter && disabled || hasRouter && !to) {
    return ANCHOR_TAG;
  } // TODO:
  //   Check registered components for existence of user supplied router link component name
  //   We would need to check PascalCase, kebab-case, and camelCase versions of name:
  //   const name = routerComponentName
  //   const names = [name, PascalCase(name), KebabCase(name), CamelCase(name)]
  //   exists = names.some(name => !!thisOrParent.$options.components[name])
  //   And may want to cache the result for performance or we just let the render fail
  //   if the component is not registered


  return routerComponentName || (thisOrParent.$nuxt ? "nuxt-link" : "router-link");
};
var router_computeRel = function computeRel() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      target = _ref2.target,
      rel = _ref2.rel;

  if (target === "_blank" && isNull(rel)) {
    return "noopener";
  }

  return rel || null;
};
var router_computeHref = function computeHref() {
  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      href = _ref3.href,
      to = _ref3.to;

  var tag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ANCHOR_TAG;
  var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "#";
  var toFallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "/";

  // We've already checked the $router in computeTag(), so isRouterLink() indicates a live router.
  // When deferring to Vue Router's router-link, don't use the href attribute at all.
  // We return null, and then remove href from the attributes passed to router-link
  if (router_isRouterLink(tag)) {
    return null;
  } // Return `href` when explicitly provided


  if (href) {
    return href;
  } // Reconstruct `href` when `to` used, but no router


  if (to) {
    // Fallback to `to` prop (if `to` is a string)
    if (isString(to)) {
      return to || toFallback;
    } // Fallback to `to.path + to.query + to.hash` prop (if `to` is an object)


    if (isPlainObject(to) && (to.path || to.query || to.hash)) {
      var path = string_toString(to.path);
      var query = router_stringifyQueryObj(to.query);
      var hash = string_toString(to.hash);
      hash = !hash || hash.charAt(0) === "#" ? hash : "#".concat(hash);
      return "".concat(path).concat(query).concat(hash) || toFallback;
    }
  } // If nothing is provided return the fallback


  return fallback;
};
// CONCATENATED MODULE: ./src/components/link/link.js










var propsFactory = function propsFactory() {
  return {
    href: {
      type: String,
      default: null
    },
    rel: {
      type: String,
      default: null
    },
    target: {
      type: String,
      default: "_self"
    },
    active: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    to: {
      type: [String, Object],
      default: null
    },
    append: {
      type: Boolean,
      default: false
    },
    replace: {
      type: Boolean,
      default: false
    },
    event: {
      type: [String, Array],
      default: "click"
    },
    activeClass: {
      type: String
    },
    exact: {
      type: Boolean,
      default: false
    },
    exactActiveClass: {
      type: String
    },
    routerTag: {
      type: String,
      default: "a"
    },
    noPrefetch: {
      type: Boolean,
      default: false
    }
  };
};
var link_props = propsFactory();
var link_name = "NlyLink";
var NlyLink = utils_vue.extend({
  name: link_name,
  mixins: [mixins_normalize_slot],
  inheritAttrs: false,
  props: propsFactory(),
  computed: {
    computedTag: function computedTag() {
      // We don't pass `this` as the first arg as we need reactivity of the props
      return computeTag({
        to: this.to,
        disabled: this.disabled
      }, this);
    },
    isRouterLink: function isRouterLink() {
      return router_isRouterLink(this.computedTag);
    },
    computedRel: function computedRel() {
      // We don't pass `this` as the first arg as we need reactivity of the props
      return router_computeRel({
        target: this.target,
        rel: this.rel
      });
    },
    computedHref: function computedHref() {
      // We don't pass `this` as the first arg as we need reactivity of the props
      return router_computeHref({
        to: this.to,
        href: this.href
      }, this.computedTag);
    },
    computedProps: function computedProps() {
      return this.isRouterLink ? Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.$props), {}, {
        tag: this.routerTag
      }) : {};
    }
  },
  methods: {
    onClick: function onClick(evt) {
      var _arguments = arguments;
      var evtIsEvent = isEvent(evt);
      var isRouterLink = this.isRouterLink;
      var suppliedHandler = this.$listeners.click;

      if (evtIsEvent && this.disabled) {
        // Stop event from bubbling up
        evt.stopPropagation(); // Kill the event loop attached to this specific `EventTarget`
        // Needed to prevent `vue-router` for doing its thing

        evt.stopImmediatePropagation();
      } else {
        /* istanbul ignore next: difficult to test, but we know it works */
        if (isRouterLink && evt.currentTarget.__vue__) {
          // Router links do not emit instance `click` events, so we
          // add in an `$emit('click', evt)` on its Vue instance
          evt.currentTarget.__vue__.$emit("click", evt);
        } // Call the suppliedHandler(s), if any provided


        concat(suppliedHandler).filter(function (h) {
          return isFunction(h);
        }).forEach(function (handler) {
          handler.apply(void 0, _toConsumableArray(_arguments));
        }); // Emit the global `$root` click event

        this.$root.$emit("clicked::link", evt);
      } // Stop scroll-to-top behavior or navigation on
      // regular links when href is just '#'


      if (evtIsEvent && (this.disabled || !isRouterLink && this.computedHref === "#")) {
        evt.preventDefault();
      }
    },
    focus: function focus() {
      if (this.$el && this.$el.focus) {
        this.$el.focus();
      }
    },
    blur: function blur() {
      if (this.$el && this.$el.blur) {
        this.$el.blur();
      }
    }
  },
  render: function render(h) {
    var tag = this.computedTag;
    var rel = this.computedRel;
    var href = this.computedHref;
    var isRouterLink = this.isRouterLink;
    var componentData = {
      class: {
        active: this.active,
        disabled: this.disabled
      },
      attrs: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.$attrs), {}, {
        rel: rel,
        target: this.target,
        tabindex: this.disabled ? "-1" : isUndefined(this.$attrs.tabindex) ? null : this.$attrs.tabindex,
        "aria-disabled": this.disabled ? "true" : null
      }),
      props: this.computedProps
    }; // Add the event handlers. We must use `navtiveOn` for
    // `<router-link>`/`<nuxt-link>` instead of `on`

    componentData[isRouterLink ? "nativeOn" : "on"] = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.$listeners), {}, {
      // We want to overwrite any click handler since our callback
      // will invoke the user supplied handler(s) if `!this.disabled`
      click: this.onClick
    }); // If href attribute exists on <router-link> (even undefined or null) it fails working on
    // SSR, so we explicitly add it here if needed (i.e. if computedHref() is truthy)

    if (href) {
      componentData.attrs.href = href;
    } else {
      // Ensure the prop HREF does not exist for router links
      delete componentData.props.href;
    }

    return h(tag, componentData, this.normalizeSlot("default"));
  }
});
// CONCATENATED MODULE: ./src/mixins/pagination.js



















var ELLIPSIS_THRESHOLD = 3;
var DEFAULT_LIMIT = 5;

var pagination_makePageArray = function makePageArray(startNumber, numberOfPages) {
  return utils_range(numberOfPages).map(function (val, i) {
    return {
      number: startNumber + i,
      classes: null
    };
  });
};

var pagination_sanitizeLimit = function sanitizeLimit(val) {
  var limit = toInteger(val) || 1;
  return limit < 1 ? DEFAULT_LIMIT : limit;
};

var pagination_sanitizeCurrentPage = function sanitizeCurrentPage(val, numberOfPages) {
  var page = toInteger(val) || 1;
  return page > numberOfPages ? numberOfPages : page < 1 ? 1 : page;
};

var pagination_onSpaceKey = function onSpaceKey(evt) {
  if (evt.keyCode === key_codes.SPACE) {
    stopEvent(evt, {
      immediatePropagation: true
    });
    evt.currentTarget.click();
    return false;
  }
};

var pagination_name = "NlyBootstrapPagination";
var pagination_props = {
  disabled: {
    type: Boolean,
    default: false
  },
  value: {
    type: [Number, String],
    default: null,
    validator: function validator(value) {
      if (!isNull(value) && toInteger(value, 0) < 1) {
        warn_warn('"v-model" value must be a number greater than "0"', pagination_name);
        return false;
      }

      return true;
    }
  },
  limit: {
    type: [Number, String],
    default: DEFAULT_LIMIT,
    validator: function validator(value) {
      if (toInteger(value, 0) < 1) {
        warn_warn('Prop "limit" must be a number greater than "0"', pagination_name);
        return false;
      }

      return true;
    }
  },
  align: {
    type: String,
    default: "left"
  },
  pills: {
    type: Boolean,
    default: false
  },
  hideGotoEndButtons: {
    type: Boolean,
    default: false
  },
  ariaLabel: {
    type: String,
    default: "Pagination"
  },
  labelFirstPage: {
    type: String,
    default: "Go to first page"
  },
  firstText: {
    type: String,
    default: "\xAB" // '«'

  },
  firstNumber: {
    type: Boolean,
    default: false
  },
  firstClass: {
    type: [String, Array, Object],
    default: null
  },
  labelPrevPage: {
    type: String,
    default: "Go to previous page"
  },
  prevText: {
    type: String,
    default: "\u2039" // '‹'

  },
  prevClass: {
    type: [String, Array, Object],
    default: null
  },
  labelNextPage: {
    type: String,
    default: "Go to next page"
  },
  nextText: {
    type: String,
    default: "\u203A" // '›'

  },
  nextClass: {
    type: [String, Array, Object]
  },
  labelLastPage: {
    type: String,
    default: "Go to last page"
  },
  lastText: {
    type: String,
    default: "\xBB" // '»'

  },
  lastNumber: {
    type: Boolean,
    default: false
  },
  lastClass: {
    type: [String, Array, Object]
  },
  labelPage: {
    type: [String, Function],
    default: "Go to page"
  },
  pageClass: {
    type: [String, Array, Object]
  },
  hideEllipsis: {
    type: Boolean,
    default: false
  },
  ellipsisText: {
    type: String,
    default: "\u2026" // '…'

  },
  ellipsisClass: {
    type: [String, Array, Object]
  }
};
/* harmony default export */ var pagination = ({
  mixins: [mixins_normalize_slot],
  model: {
    prop: "value",
    event: "input"
  },
  props: pagination_props,
  data: function data() {
    var currentPage = toInteger(this.value, 0);
    currentPage = currentPage > 0 ? currentPage : -1;
    return {
      currentPage: currentPage,
      localNumberOfPages: 1,
      localLimit: DEFAULT_LIMIT
    };
  },
  computed: {
    btnSize: function btnSize() {
      return this.size ? "pagination-".concat(this.size) : "";
    },
    alignment: function alignment() {
      var align = this.align;

      if (align === "center") {
        return "justify-content-center";
      } else if (align === "end" || align === "right") {
        return "justify-content-end";
      } else if (align === "fill") {
        return "text-center";
      }

      return "";
    },
    styleClass: function styleClass() {
      return this.pills ? "nly-pagination-pills" : "";
    },
    computedCurrentPage: function computedCurrentPage() {
      return pagination_sanitizeCurrentPage(this.currentPage, this.localNumberOfPages);
    },
    paginationParams: function paginationParams() {
      var limit = this.localLimit,
          numberOfPages = this.localNumberOfPages,
          currentPage = this.computedCurrentPage,
          hideEllipsis = this.hideEllipsis,
          firstNumber = this.firstNumber,
          lastNumber = this.lastNumber;
      var showFirstDots = false;
      var showLastDots = false;
      var numberOfLinks = limit;
      var startNumber = 1;

      if (numberOfPages <= limit) {
        numberOfLinks = numberOfPages;
      } else if (currentPage < limit - 1 && limit > ELLIPSIS_THRESHOLD) {
        if (!hideEllipsis || lastNumber) {
          showLastDots = true;
          numberOfLinks = limit - (firstNumber ? 0 : 1);
        }

        numberOfLinks = mathMin(numberOfLinks, limit);
      } else if (numberOfPages - currentPage + 2 < limit && limit > ELLIPSIS_THRESHOLD) {
        if (!hideEllipsis || firstNumber) {
          showFirstDots = true;
          numberOfLinks = limit - (lastNumber ? 0 : 1);
        }

        startNumber = numberOfPages - numberOfLinks + 1;
      } else {
        if (limit > ELLIPSIS_THRESHOLD) {
          numberOfLinks = limit - (hideEllipsis ? 0 : 2);
          showFirstDots = !!(!hideEllipsis || firstNumber);
          showLastDots = !!(!hideEllipsis || lastNumber);
        }

        startNumber = currentPage - mathFloor(numberOfLinks / 2);
      }

      if (startNumber < 1) {
        startNumber = 1;
        showFirstDots = false;
      } else if (startNumber > numberOfPages - numberOfLinks) {
        startNumber = numberOfPages - numberOfLinks + 1;
        showLastDots = false;
      }

      if (showFirstDots && firstNumber && startNumber < 4) {
        numberOfLinks = numberOfLinks + 2;
        startNumber = 1;
        showFirstDots = false;
      }

      var lastPageNumber = startNumber + numberOfLinks - 1;

      if (showLastDots && lastNumber && lastPageNumber > numberOfPages - 3) {
        numberOfLinks = numberOfLinks + (lastPageNumber === numberOfPages - 2 ? 2 : 3);
        showLastDots = false;
      }

      if (limit <= ELLIPSIS_THRESHOLD) {
        if (firstNumber && startNumber === 1) {
          numberOfLinks = mathMin(numberOfLinks + 1, numberOfPages, limit + 1);
        } else if (lastNumber && numberOfPages === startNumber + numberOfLinks - 1) {
          startNumber = mathMax(startNumber - 1, 1);
          numberOfLinks = mathMin(numberOfPages - startNumber + 1, numberOfPages, limit + 1);
        }
      }

      numberOfLinks = mathMin(numberOfLinks, numberOfPages - startNumber + 1);
      return {
        showFirstDots: showFirstDots,
        showLastDots: showLastDots,
        numberOfLinks: numberOfLinks,
        startNumber: startNumber
      };
    },
    pageList: function pageList() {
      var _this$paginationParam = this.paginationParams,
          numberOfLinks = _this$paginationParam.numberOfLinks,
          startNumber = _this$paginationParam.startNumber;
      var currentPage = this.computedCurrentPage;
      var pages = pagination_makePageArray(startNumber, numberOfLinks);

      if (pages.length > 3) {
        var idx = currentPage - startNumber;
        var classes = "bv-d-xs-down-none";

        if (idx === 0) {
          for (var i = 3; i < pages.length; i++) {
            pages[i].classes = classes;
          }
        } else if (idx === pages.length - 1) {
          for (var _i = 0; _i < pages.length - 3; _i++) {
            pages[_i].classes = classes;
          }
        } else {
          for (var _i2 = 0; _i2 < idx - 1; _i2++) {
            pages[_i2].classes = classes;
          }

          for (var _i3 = pages.length - 1; _i3 > idx + 1; _i3--) {
            pages[_i3].classes = classes;
          }
        }
      }

      return pages;
    }
  },
  watch: {
    value: function value(newValue, oldValue) {
      if (newValue !== oldValue) {
        this.currentPage = pagination_sanitizeCurrentPage(newValue, this.localNumberOfPages);
      }
    },
    currentPage: function currentPage(newValue, oldValue) {
      if (newValue !== oldValue) {
        this.$emit("input", newValue > 0 ? newValue : null);
      }
    },
    limit: function limit(newValue, oldValue) {
      if (newValue !== oldValue) {
        this.localLimit = pagination_sanitizeLimit(newValue);
      }
    }
  },
  created: function created() {
    var _this = this;

    this.localLimit = pagination_sanitizeLimit(this.limit);
    this.$nextTick(function () {
      _this.currentPage = _this.currentPage > _this.localNumberOfPages ? _this.localNumberOfPages : _this.currentPage;
    });
  },
  methods: {
    handleKeyNav: function handleKeyNav(evt) {
      var keyCode = evt.keyCode,
          shiftKey = evt.shiftKey;

      if (this.isNav) {
        return;
      }

      if (keyCode === key_codes.LEFT || keyCode === key_codes.UP) {
        stopEvent(evt, {
          propagation: false
        });
        shiftKey ? this.focusFirst() : this.focusPrev();
      } else if (keyCode === key_codes.RIGHT || keyCode === key_codes.DOWN) {
        stopEvent(evt, {
          propagation: false
        });
        shiftKey ? this.focusLast() : this.focusNext();
      }
    },
    getButtons: function getButtons() {
      return dom_selectAll("button.page-link, a.page-link", this.$el).filter(function (btn) {
        return isVisible(btn);
      });
    },
    focusCurrent: function focusCurrent() {
      var _this2 = this;

      this.$nextTick(function () {
        var btn = _this2.getButtons().find(function (el) {
          return toInteger(getAttr(el, "aria-posinset"), 0) === _this2.computedCurrentPage;
        });

        if (!dom_attemptFocus(btn)) {
          _this2.focusFirst();
        }
      });
    },
    focusFirst: function focusFirst() {
      var _this3 = this;

      this.$nextTick(function () {
        var btn = _this3.getButtons().find(function (el) {
          return !dom_isDisabled(el);
        });

        dom_attemptFocus(btn);
      });
    },
    focusLast: function focusLast() {
      var _this4 = this;

      this.$nextTick(function () {
        var btn = _this4.getButtons().reverse().find(function (el) {
          return !dom_isDisabled(el);
        });

        dom_attemptFocus(btn);
      });
    },
    focusPrev: function focusPrev() {
      var _this5 = this;

      this.$nextTick(function () {
        var buttons = _this5.getButtons();

        var index = buttons.indexOf(dom_getActiveElement());

        if (index > 0 && !dom_isDisabled(buttons[index - 1])) {
          dom_attemptFocus(buttons[index - 1]);
        }
      });
    },
    focusNext: function focusNext() {
      var _this6 = this;

      this.$nextTick(function () {
        var buttons = _this6.getButtons();

        var index = buttons.indexOf(dom_getActiveElement());

        if (index < buttons.length - 1 && !dom_isDisabled(buttons[index + 1])) {
          dom_attemptFocus(buttons[index + 1]);
        }
      });
    }
  },
  render: function render(h) {
    var _this7 = this;

    var buttons = [];
    var numberOfPages = this.localNumberOfPages;
    var pageNumbers = this.pageList.map(function (p) {
      return p.number;
    });
    var disabled = this.disabled;
    var _this$paginationParam2 = this.paginationParams,
        showFirstDots = _this$paginationParam2.showFirstDots,
        showLastDots = _this$paginationParam2.showLastDots;
    var currentPage = this.computedCurrentPage;
    var fill = this.align === "fill";
    var isNav = this.isNav;

    var isActivePage = function isActivePage(pageNumber) {
      return pageNumber === currentPage;
    };

    var noCurrentPage = this.currentPage < 1;

    var makeEndBtn = function makeEndBtn(linkTo, ariaLabel, btnSlot, btnText, btnClass, pageTest, key) {
      var isDisabled = disabled || isActivePage(pageTest) || noCurrentPage || linkTo < 1 || linkTo > numberOfPages;
      var pageNumber = linkTo < 1 ? 1 : linkTo > numberOfPages ? numberOfPages : linkTo;
      var scope = {
        disabled: isDisabled,
        page: pageNumber,
        index: pageNumber - 1
      };
      var $btnContent = _this7.normalizeSlot(btnSlot, scope) || string_toString(btnText) || h();
      var $inner = h(isDisabled ? "span" : isNav ? NlyLink : "button", {
        staticClass: "page-link",
        class: {
          "flex-grow-1": !isNav && !isDisabled && fill
        },
        props: isDisabled || !isNav ? {} : _this7.linkProps(linkTo),
        attrs: {
          role: isNav ? null : "menuitem",
          type: isNav || isDisabled ? null : "button",
          tabindex: isDisabled || isNav ? null : "-1",
          "aria-label": ariaLabel,
          "aria-controls": _this7.ariaControls || null,
          "aria-disabled": isDisabled ? "true" : null
        },
        on: isDisabled ? {} : {
          "!click": function click(evt) {
            _this7.onClick(evt, linkTo);
          },
          keydown: pagination_onSpaceKey
        }
      }, [$btnContent]);
      return h("li", {
        key: key,
        staticClass: "page-item",
        class: [{
          disabled: isDisabled,
          "flex-fill": fill,
          "d-flex": fill && !isNav && !isDisabled
        }, btnClass],
        attrs: {
          role: isNav ? null : "presentation",
          "aria-hidden": isDisabled ? "true" : null
        }
      }, [$inner]);
    };

    var makeEllipsis = function makeEllipsis(isLast) {
      return h("li", {
        key: "ellipsis-".concat(isLast ? "last" : "first"),
        staticClass: "page-item",
        class: ["disabled", "bv-d-xs-down-none", fill ? "flex-fill" : "", _this7.ellipsisClass],
        attrs: {
          role: "separator"
        }
      }, [h("span", {
        staticClass: "page-link"
      }, [_this7.normalizeSlot("ellipsis-text") || string_toString(_this7.ellipsisText) || h()])]);
    };

    var makePageButton = function makePageButton(page, idx) {
      var active = isActivePage(page.number) && !noCurrentPage;
      var tabIndex = disabled ? null : active || noCurrentPage && idx === 0 ? "0" : "-1";
      var attrs = {
        role: isNav ? null : "menuitemradio",
        type: isNav || disabled ? null : "button",
        "aria-disabled": disabled ? "true" : null,
        "aria-controls": _this7.ariaControls || null,
        "aria-label": isFunction(_this7.labelPage) ? _this7.labelPage(page.number) : "".concat(_this7.labelPage, " ").concat(page.number),
        "aria-checked": isNav ? null : active ? "true" : "false",
        "aria-current": isNav && active ? "page" : null,
        "aria-posinset": isNav ? null : page.number,
        "aria-setsize": isNav ? null : numberOfPages,
        tabindex: isNav ? null : tabIndex
      };
      var btnContent = string_toString(_this7.makePage(page.number));
      var scope = {
        page: page.number,
        index: page.number - 1,
        content: btnContent,
        active: active,
        disabled: disabled
      };
      var $inner = h(disabled ? "span" : isNav ? NlyLink : "button", {
        props: disabled || !isNav ? {} : _this7.linkProps(page.number),
        staticClass: "page-link",
        class: {
          "flex-grow-1": !isNav && !disabled && fill
        },
        attrs: attrs,
        on: disabled ? {} : {
          "!click": function click(evt) {
            _this7.onClick(evt, page.number);
          },
          keydown: pagination_onSpaceKey
        }
      }, [_this7.normalizeSlot("page", scope) || btnContent]);
      return h("li", {
        key: "page-".concat(page.number),
        staticClass: "page-item",
        class: [{
          disabled: disabled,
          active: active,
          "flex-fill": fill,
          "d-flex": fill && !isNav && !disabled
        }, page.classes, _this7.pageClass],
        attrs: {
          role: isNav ? null : "presentation"
        }
      }, [$inner]);
    };

    var $firstPageBtn = h();

    if (!this.firstNumber && !this.hideGotoEndButtons) {
      $firstPageBtn = makeEndBtn(1, this.labelFirstPage, "first-text", this.firstText, this.firstClass, 1, "pagination-goto-first");
    }

    buttons.push($firstPageBtn);
    buttons.push(makeEndBtn(currentPage - 1, this.labelPrevPage, "prev-text", this.prevText, this.prevClass, 1, "pagination-goto-prev"));
    buttons.push(this.firstNumber && pageNumbers[0] !== 1 ? makePageButton({
      number: 1
    }, 0) : h());
    buttons.push(showFirstDots ? makeEllipsis(false) : h());
    this.pageList.forEach(function (page, idx) {
      var offset = showFirstDots && _this7.firstNumber && pageNumbers[0] !== 1 ? 1 : 0;
      buttons.push(makePageButton(page, idx + offset));
    });
    buttons.push(showLastDots ? makeEllipsis(true) : h());
    buttons.push(this.lastNumber && pageNumbers[pageNumbers.length - 1] !== numberOfPages ? makePageButton({
      number: numberOfPages
    }, -1) : h());
    buttons.push(makeEndBtn(currentPage + 1, this.labelNextPage, "next-text", this.nextText, this.nextClass, numberOfPages, "pagination-goto-next"));
    var $lastPageBtn = h();

    if (!this.lastNumber && !this.hideGotoEndButtons) {
      $lastPageBtn = makeEndBtn(numberOfPages, this.labelLastPage, "last-text", this.lastText, this.lastClass, numberOfPages, "pagination-goto-last");
    }

    buttons.push($lastPageBtn);
    var $pagination = h("ul", {
      ref: "ul",
      staticClass: "pagination",
      class: ["nly-pagination", this.btnSize, this.alignment, this.styleClass],
      attrs: {
        role: isNav ? null : "menubar",
        "aria-disabled": disabled ? "true" : "false",
        "aria-label": isNav ? null : this.ariaLabel || null
      },
      on: isNav ? {} : {
        keydown: this.handleKeyNav
      }
    }, buttons);

    if (isNav) {
      return h("nav", {
        attrs: {
          "aria-disabled": disabled ? "true" : null,
          "aria-hidden": disabled ? "true" : "false",
          "aria-label": isNav ? this.ariaLabel || null : null
        }
      }, [$pagination]);
    }

    return $pagination;
  }
});
// CONCATENATED MODULE: ./src/components/bootstrap-pagination/bootstrap-pagination.js








 // --- Constants ---

var DEFAULT_PER_PAGE = 20;
var DEFAULT_TOTAL_ROWS = 0;
var bootstrap_pagination_name = "NlyBootstrapPagination";
var bootstrap_pagination_props = {
  size: {
    type: String,
    default: function _default() {
      return getComponentConfig(bootstrap_pagination_name, "size");
    }
  },
  perPage: {
    type: [Number, String],
    default: DEFAULT_PER_PAGE
  },
  totalRows: {
    type: [Number, String],
    default: DEFAULT_TOTAL_ROWS
  },
  ariaControls: {
    type: String
  }
};

var bootstrap_pagination_sanitizePerPage = function sanitizePerPage(val) {
  return mathMax(toInteger(val) || DEFAULT_PER_PAGE, 1);
};

var bootstrap_pagination_sanitizeTotalRows = function sanitizeTotalRows(val) {
  return mathMax(toInteger(val) || DEFAULT_TOTAL_ROWS, 0);
};

var NlyBootstrapPagination = utils_vue.extend({
  name: bootstrap_pagination_name,
  mixins: [pagination],
  props: bootstrap_pagination_props,
  computed: {
    numberOfPages: function numberOfPages() {
      var result = mathCeil(bootstrap_pagination_sanitizeTotalRows(this.totalRows) / bootstrap_pagination_sanitizePerPage(this.perPage));
      return result < 1 ? 1 : result;
    },
    pageSizeNumberOfPages: function pageSizeNumberOfPages() {
      return {
        perPage: bootstrap_pagination_sanitizePerPage(this.perPage),
        totalRows: bootstrap_pagination_sanitizeTotalRows(this.totalRows),
        numberOfPages: this.numberOfPages
      };
    }
  },
  watch: {
    pageSizeNumberOfPages: function pageSizeNumberOfPages(newVal, oldVal) {
      if (!isUndefinedOrNull(oldVal)) {
        if (newVal.perPage !== oldVal.perPage && newVal.totalRows === oldVal.totalRows) {
          this.currentPage = 1;
        } else if (newVal.numberOfPages !== oldVal.numberOfPages && this.currentPage > newVal.numberOfPages) {
          this.currentPage = 1;
        }
      }

      this.localNumberOfPages = newVal.numberOfPages;
    }
  },
  created: function created() {
    var _this = this;

    this.localNumberOfPages = this.numberOfPages;
    var currentPage = toInteger(this.value, 0);

    if (currentPage > 0) {
      this.currentPage = currentPage;
    } else {
      this.$nextTick(function () {
        _this.currentPage = 0;
      });
    }
  },
  mounted: function mounted() {
    this.localNumberOfPages = this.numberOfPages;
  },
  methods: {
    onClick: function onClick(evt, pageNumber) {
      var _this2 = this;

      if (pageNumber === this.currentPage) {
        return;
      }

      var target = evt.target;
      var clickEvt = new nly_event_class_NlyEvent("page-click", {
        cancelable: true,
        vueTarget: this,
        target: target
      });
      this.$emit(clickEvt.type, clickEvt, pageNumber);

      if (clickEvt.defaultPrevented) {
        return;
      }

      this.currentPage = pageNumber;
      this.$emit("change", this.currentPage);
      this.$nextTick(function () {
        if (isVisible(target) && _this2.$el.contains(target)) {
          dom_attemptFocus(target);
        } else {
          _this2.focusCurrent();
        }
      });
    },
    makePage: function makePage(pageNum) {
      return pageNum;
    },

    /* istanbul ignore next */
    linkProps: function linkProps() {
      return {};
    }
  }
});
// CONCATENATED MODULE: ./src/components/bootstrap-pagination/index.js


var BootstrapPaginationPlugin = plugins_nlyPluginFactory({
  components: {
    NlyBootstrapPagination: NlyBootstrapPagination,
    NlyBPagination: NlyBootstrapPagination
  }
});

// CONCATENATED MODULE: ./src/utils/pluck-props.js





/**
 * Given an array of properties or an object of property keys,
 * plucks all the values off the target object, returning a new object
 * that has props that reference the original prop values
 *
 * @param {{}|string[]} keysToPluck
 * @param {{}} objToPluck
 * @param {Function} transformFn
 * @return {{}}
 */

var pluck_props_pluckProps = function pluckProps(keysToPluck, objToPluck) {
  var transformFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : utils_identity;
  return (isArray(keysToPluck) ? keysToPluck.slice() : keys(keysToPluck)).reduce(function (memo, prop) {
    memo[transformFn(prop)] = objToPluck[prop];
    return memo;
  }, {});
};

/* harmony default export */ var pluck_props = (pluck_props_pluckProps);
// CONCATENATED MODULE: ./src/utils/html.js


var stripTagsRegex = /(<([^>]+)>)/gi; // Removes any thing that looks like an HTML tag from the supplied string

var stripTags = function stripTags() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
  return String(text).replace(stripTagsRegex, "");
}; // Generate a domProps object for either innerHTML, textContent or nothing

var htmlOrText = function htmlOrText(innerHTML, textContent) {
  return innerHTML ? {
    innerHTML: innerHTML
  } : textContent ? {
    textContent: textContent
  } : {};
};
// CONCATENATED MODULE: ./src/components/breadcrumb/breadcrumb-link.js






var breadcrumb_link_props = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, propsFactory()), {}, {
  text: {
    type: String,
    default: null
  },
  html: {
    type: String,
    default: null
  },
  ariaCurrent: {
    type: String,
    default: "location"
  }
});
var breadcrumb_link_name = "NlyBreadcrumbLink";
var NlyBreadcrumbLink = utils_vue.extend({
  name: breadcrumb_link_name,
  functional: true,
  props: breadcrumb_link_props,
  render: function render(h, _ref) {
    var suppliedProps = _ref.props,
        data = _ref.data,
        children = _ref.children;
    var tag = suppliedProps.active ? "span" : NlyLink;
    var componentData = {
      props: pluck_props(breadcrumb_link_props, suppliedProps)
    };

    if (suppliedProps.active) {
      componentData.attrs = {
        "aria-current": suppliedProps.ariaCurrent
      };
    }

    if (!children) {
      componentData.domProps = htmlOrText(suppliedProps.html, suppliedProps.text);
    }

    return h(tag, lib_esm_a(data, componentData), children);
  }
});
// CONCATENATED MODULE: ./src/components/icons/icon.js




var icon_props = {
  size: {
    type: String
  },
  tag: {
    type: String,
    default: "i"
  },
  icon: {
    type: String
  }
};

var icon_customClass = function customClass(props) {
  return [props.icon, nlyGetOptionsByKeyEqual(textSizeOptions, props.size)];
};

var icon_name = "NlyIcon";
var NlyIcon = utils_vue.extend({
  name: icon_name,
  props: icon_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      class: icon_customClass(props)
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/breadcrumb/breadcrumb-item.js





var breadcrumb_item_props = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, breadcrumb_link_props), {}, {
  icon: {
    type: String
  },
  itemClass: {
    type: String
  },
  linkClass: {
    type: String
  }
});
var NlyBreadcrumbItem = utils_vue.extend({
  name: "NlyBreadcrumbItem",
  functional: true,
  props: breadcrumb_item_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;

    if (props.icon) {
      return h("li", lib_esm_a(data, {
        staticClass: "breadcrumb-item",
        class: {
          active: props.active
        }
      }), [h(NlyIcon, {
        staticClass: "mr-1",
        props: {
          icon: props.icon
        }
      }), h(NlyBreadcrumbLink, {
        class: [props.linkClass],
        props: props
      }, children)]);
    } else {
      return h("li", lib_esm_a(data, {
        staticClass: "breadcrumb-item",
        class: [props.active ? "active" : "", props.itemClass]
      }), [h(NlyBreadcrumbLink, {
        class: [props.linkClass],
        props: props
      }, children)]);
    }
  }
});
// CONCATENATED MODULE: ./src/components/breadcrumb/breadcrumb.js







var breadcrumb_name = "NlyBreadcrumb";
var breadcrumb_props = {
  item: {
    type: Array,
    default: null
  },
  breadcrumbClass: {
    type: String
  }
};
var NlyBreadcrumb = utils_vue.extend({
  name: breadcrumb_name,
  functional: true,
  props: breadcrumb_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    var childNodes = children;

    if (isArray(props.item)) {
      var activeDefined = false;
      childNodes = props.item.map(function (item, idx) {
        if (!object_isObject(item)) {
          item = {
            text: string_toString(item)
          };
        }

        var active = item.active;

        if (active) {
          activeDefined = true;
        }

        if (!active && !activeDefined) {
          active = idx + 1 === props.item.length;
        }

        return h(NlyBreadcrumbItem, {
          props: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, item), {}, {
            active: active
          })
        });
      });
    }

    return h("ol", lib_esm_a(data, {
      staticClass: "breadcrumb",
      class: [props.breadcrumbClass]
    }), childNodes);
  }
});
// CONCATENATED MODULE: ./src/components/breadcrumb/index.js



var BreadcrumbPlugin = plugins_nlyPluginFactory({
  components: {
    NlyBreadcrumbItem: NlyBreadcrumbItem,
    NlyBreadcrumb: NlyBreadcrumb
  }
});

// CONCATENATED MODULE: ./src/components/button/button.js















var button_btnProps = {
  block: {
    type: Boolean,
    default: false
  },
  variant: {
    type: String,
    default: "default"
  },
  bgVariant: {
    type: String
  },
  size: {
    type: String
  },
  type: {
    type: String,
    default: "button"
  },
  shape: {
    type: String
  },
  disabled: {
    type: Boolean,
    default: false
  },
  bgGradientVariant: {
    type: String
  },
  buttonClass: {
    type: String
  },
  tool: {
    type: Boolean,
    default: false
  },
  app: {
    type: Boolean,
    default: false
  },
  tag: {
    type: String,
    default: "button"
  },
  pressed: {
    type: Boolean,
    default: null
  },
  isNavbar: {
    type: Boolean,
    default: false
  }
};
var linkProps = propsFactory();
delete linkProps.href.default;
delete linkProps.to.default;
var linkPropKeys = keys(linkProps);
var button_props = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, linkProps), button_btnProps);

var button_tagIs = function tagIs(tag, name) {
  return string_toString(tag).toLowerCase() === string_toString(name).toLowerCase();
};

var button_handleFocus = function handleFocus(evt) {
  if (evt.type === "focusin") {
    addClass(evt.target, "focus");
  } else if (evt.type === "focusout") {
    removeClass(evt.target, "focus");
  }
};

var button_isLink = function isLink(props) {
  return props.href || props.to || button_tagIs(props.tag, "a");
};

var button_isToggle = function isToggle(props) {
  return isBoolean(props.pressed);
};

var isButton = function isButton(props) {
  return !(button_isLink(props) || props.tag && !button_tagIs(props.tag, "button"));
};

var button_isNonStandardTag = function isNonStandardTag(props) {
  return !button_isLink(props) && !isButton(props);
};

var button_customClass = function customClass(props) {
  var btnVariant = function btnVariant() {
    if (!props.bgVariant && !props.bgGradientVariant && !props.tool) {
      return nlyGetOptionsByKeyEqual(btnVariantOptinos, props.variant);
    } else {
      return null;
    }
  };

  var btnBlock = function btnBlock() {
    return props.block ? "btn-block" : null;
  };

  var customSize = function customSize() {
    return nlyGetOptionsByKeyEqual(btnSizeOptions, props.size);
  };

  var btnShape = function btnShape() {
    return nlyGetOptionsByKeyEqual(btnShapeOptions, props.shape);
  };

  var btnBgGradientVariant = function btnBgGradientVariant() {
    return nlyGetOptionsByKeyEqual(bgGradientOptions, props.bgGradientVariant);
  };

  var btnBgVariant = function btnBgVariant() {
    return props.bgGradientVariant ? null : nlyGetOptionsByKeyEqual(bgVariantOptions, props.bgVariant);
  };

  var btnDisabled = function btnDisabled() {
    return props.disabled ? "disabled" : null;
  };

  var btnPressed = function btnPressed() {
    return props.pressed ? "active" : null;
  };

  var btnTool = function btnTool() {
    return props.tool ? "btn-tool" : null;
  };

  var btnApp = function btnApp() {
    return props.app ? "btn-app" : null;
  };

  var btmCustomClass = function btmCustomClass() {
    return props.buttonClass;
  };

  var isNavBarClass = props.isNavbar ? "btn-navbar" : null;
  return [btnVariant(), btnBgVariant(), btnBgGradientVariant(), btnBlock(), customSize(), btnShape(), btnDisabled(), btnPressed(), btnTool(), btnApp(), btmCustomClass(), isNavBarClass];
};

var button_computeLinkProps = function computeLinkProps(props) {
  return button_isLink(props) ? pluck_props(linkPropKeys, props) : null;
};

var computeAttrs = function computeAttrs(props, data) {
  var button = isButton(props);
  var link = button_isLink(props);
  var toggle = button_isToggle(props);
  var nonStandardTag = button_isNonStandardTag(props);
  var hashLink = link && props.href === "#";
  var role = data.attrs && data.attrs.role ? data.attrs.role : null;
  var tabindex = data.attrs ? data.attrs.tabindex : null;

  if (nonStandardTag || hashLink) {
    tabindex = "0";
  }

  return {
    type: button && !link ? props.type : null,
    disabled: button ? props.disabled : null,
    role: nonStandardTag || hashLink ? "button" : role,
    "aria-disabled": nonStandardTag ? String(props.disabled) : null,
    "aria-pressed": toggle ? String(props.pressed) : null,
    autocomplete: toggle ? "off" : null,
    tabindex: props.disabled && !button ? "-1" : tabindex
  };
};
var button_name = "NlyButton";
var NlyButton = utils_vue.extend({
  name: button_name,
  functional: true,
  props: button_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        listeners = _ref.listeners,
        children = _ref.children;
    var toggle = button_isToggle(props);
    var link = button_isLink(props);
    var nonStandardTag = button_isNonStandardTag(props);
    var hashLink = link && props.href === "#";
    var on = {
      keydown: function keydown(evt) {
        if (props.disabled || !(nonStandardTag || hashLink)) {
          return;
        }

        var keyCode = evt.keyCode;

        if (keyCode === key_codes.SPACE || keyCode === key_codes.ENTER && nonStandardTag) {
          var target = evt.currentTarget || evt.target;
          evt.preventDefault();
          target.click();
        }
      },
      click: function click(evt) {
        if (props.disabled && isEvent(evt)) {
          evt.stopPropagation();
          evt.preventDefault();
        } else if (toggle && listeners && listeners["update:pressed"]) {
          concat(listeners["update:pressed"]).forEach(function (fn) {
            if (isFunction(fn)) {
              fn(!props.pressed);
            }
          });
        }
      }
    };

    if (toggle) {
      on.focusin = button_handleFocus;
      on.focusout = button_handleFocus;
    }

    var componentData = {
      staticClass: "btn",
      class: button_customClass(props),
      props: button_computeLinkProps(props),
      attrs: computeAttrs(props, data),
      on: on
    };
    return h(link ? NlyLink : props.tag, lib_esm_a(data, componentData), children);
  }
});
// CONCATENATED MODULE: ./src/components/button/button-close.js






var button_close_NAME = "NlyButtonClose";
var button_close_props = {
  content: {
    type: String,
    default: function _default() {
      return getComponentConfig(button_close_NAME, "content");
    }
  },
  disabled: {
    type: Boolean,
    default: false
  },
  ariaLabel: {
    type: String,
    default: function _default() {
      return getComponentConfig(button_close_NAME, "ariaLabel");
    }
  },
  textVariant: {
    type: String,
    default: function _default() {
      return getComponentConfig(button_close_NAME, "textVariant");
    }
  }
};
var NlyButtonClose = utils_vue.extend({
  name: button_close_NAME,
  functional: true,
  props: button_close_props,
  // eslint-disable-next-line no-unused-vars
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        listeners = _ref.listeners,
        slots = _ref.slots,
        scopedSlots = _ref.scopedSlots;
    var $slots = slots();
    var $scopedSlots = scopedSlots || {};
    var componentData = {
      staticClass: "close",
      class: Object(defineProperty["a" /* default */])({}, "text-".concat(props.textVariant), props.textVariant),
      attrs: {
        type: "button",
        disabled: props.disabled,
        "aria-label": props.ariaLabel ? String(props.ariaLabel) : null
      },
      on: {
        click: function click(evt) {
          if (props.disabled && isEvent(evt)) {
            evt.stopPropagation();
            evt.preventDefault();
          }
        }
      }
    };

    if (!normalize_slot_hasNormalizedSlot("default", $scopedSlots, $slots)) {
      componentData.domProps = {
        innerHTML: props.content
      };
    }

    return h("button", lib_esm_a(data, componentData), normalize_slot_normalizeSlot("default", {}, $scopedSlots, $slots));
  }
});
// CONCATENATED MODULE: ./src/components/button/index.js



var ButtonPlugin = plugins_nlyPluginFactory({
  components: {
    NlyButton: NlyButton,
    NlyBtn: NlyButton,
    NlyButtonClose: NlyButtonClose,
    NlyBtnClose: NlyButtonClose
  }
});

// CONCATENATED MODULE: ./src/components/button-group/button-group.js




var button_group_name = "NlyButtonGroup";
var button_group_props = {
  vertical: {
    type: Boolean,
    default: false
  },
  size: {
    type: String
  },
  tag: {
    type: String,
    default: "div"
  },
  buttonGroupClass: {
    type: String
  }
};

var button_group_customClass = function customClass(props) {
  var customVertical = props.vertical ? "btn-group-vertical" : "btn-group";

  var customSize = function customSize() {
    return nlyGetOptionsByKeyEqual(btnGroupSizeOptions, props.size);
  };

  var customButtonGroupClass = props.buttonGroupClass;
  return [customVertical, customSize(), customButtonGroupClass];
};

var NlyButtonGroup = utils_vue.extend({
  name: button_group_name,
  functional: true,
  props: button_group_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      class: button_group_customClass(props)
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/button-group/index.js


var ButtonGroupPlugin = plugins_nlyPluginFactory({
  components: {
    NlyButtonGroup: NlyButtonGroup,
    NlyBtnGroup: NlyButtonGroup
  }
});

// CONCATENATED MODULE: ./src/components/card/card-group.js




var card_group_props = {
  groupType: {
    type: String,
    default: "default"
  },
  groupClass: {
    type: String
  },
  tag: {
    type: String,
    default: "div"
  }
};

var card_group_customClass = function customClass(props) {
  var groupType = function groupType() {
    return nlyGetOptionsByKeyEqual(cardGroupTypeOption, props.groupType);
  };

  var groupClass = props.groupClass;
  return [groupType(), groupClass];
};

var card_group_name = "NlyCardGroup";
var NlyCardGroup = utils_vue.extend({
  name: card_group_name,
  props: card_group_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      class: card_group_customClass(props)
    }), children);
  }
});
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.fixed.js
var es_string_fixed = __webpack_require__("c7cd");

// CONCATENATED MODULE: ./src/utils/nly-toast-transition.js




var NO_FADE_PROPS = {
  name: "",
  enterClass: "",
  enterActiveClass: "",
  enterToClass: "show",
  leaveClass: "show",
  leaveActiveClass: "",
  leaveToClass: ""
};

var FADE_PROPS = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, NO_FADE_PROPS), {}, {
  enterActiveClass: "fade",
  leaveActiveClass: "fade"
});

var nly_toast_transition_name = "NlyToastTransition";
var NlyToastTransition = utils_vue.extend({
  name: nly_toast_transition_name,
  functional: true,
  props: {
    noFade: {
      type: Boolean,
      default: false
    },
    appear: {
      type: Boolean,
      default: false
    },
    mode: {
      type: String
    },
    transProps: {
      type: Object,
      default: null
    }
  },
  // eslint-disable-next-line no-unused-vars
  render: function render(h, _ref) {
    var children = _ref.children,
        data = _ref.data,
        listeners = _ref.listeners,
        props = _ref.props;
    var transProps = props.transProps;

    if (!isPlainObject(transProps)) {
      transProps = props.noFade ? NO_FADE_PROPS : FADE_PROPS;

      if (props.appear) {
        // Default the appear classes to equal the enter classes
        transProps = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, transProps), {}, {
          appear: true,
          appearClass: transProps.enterClass,
          appearActiveClass: transProps.enterActiveClass,
          appearToClass: transProps.enterToClass
        });
      }
    }

    transProps = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({
      mode: props.mode
    }, transProps), {}, {
      css: true
    });
    return h("transition", lib_esm_a(data, {
      props: transProps
    }), children);
  }
});
/* harmony default export */ var nly_toast_transition = (NlyToastTransition);
// CONCATENATED MODULE: ./src/components/spinner/spinner.js



var spinner_name = "NlySpinner";
var NlySpinner = utils_vue.extend({
  name: spinner_name,
  props: {
    variant: {
      type: String
    },
    type: {
      type: String,
      default: "border"
    },
    sm: {
      type: Boolean,
      default: false
    },
    tag: {
      type: String,
      default: "span"
    },
    label: {
      type: String
    },
    role: {
      type: String,
      default: "status"
    },
    spinnerClass: {
      type: String
    },
    labelClass: {
      String: String
    }
  },
  computed: {
    customProps: function customProps() {
      return {
        variant: nlyGetOptionsByKeyEqual(textVariantOptions, this.variant),
        sm: this.sm ? "spinner-".concat(this.type, "-sm") : "",
        type: "spinner-".concat(this.type),
        tag: this.tag,
        label: this.label,
        role: this.role,
        spinnerClass: this.spinnerClass,
        labelClass: this.labelClass
      };
    }
  },
  render: function render(h) {
    var _this = this;

    var spinnerArray = function spinnerArray() {
      if (_this.customProps.label) {
        return h(_this.customProps.tag, {
          class: [_this.customProps.variant, _this.customProps.type, _this.customProps.sm, _this.customProps.spinnerClass],
          attrs: {
            role: _this.customProps.role,
            ariaHidden: "true"
          }
        }, [h("span", {
          staticClass: "sr-only",
          class: _this.customProps.labelClass
        }, _this.customProps.label)]);
      } else {
        return h(_this.customProps.tag, {
          class: [_this.customProps.variant, _this.customProps.type, _this.customProps.sm],
          attrs: {
            role: _this.customProps.role,
            ariaHidden: "fasle"
          }
        });
      }
    };

    return spinnerArray();
  }
});
// CONCATENATED MODULE: ./src/components/overlay/overlay.js








var positionCover = {
  top: 0,
  left: 0,
  bottom: 0,
  right: 0
};
var overlay_name = "NlyOverlay";
var NlyOverlay = utils_vue.extend({
  name: overlay_name,
  mixins: [mixins_normalize_slot],
  props: {
    sidebar: {
      type: Boolean,
      default: false
    },
    custom: {
      type: Boolean,
      default: false
    },
    dark: {
      type: Boolean,
      default: false
    },
    show: {
      type: Boolean,
      default: false
    },
    variant: {
      type: String,
      default: "light"
    },
    bgColor: {
      type: String
    },
    opacity: {
      type: [Number, String],
      default: 0.85,
      validator: function validator(value) {
        var number = toFloat(value, 0);
        return number >= 0 && number <= 1;
      }
    },
    blur: {
      type: String,
      default: "2px"
    },
    rounded: {
      type: [Boolean, String],
      default: false
    },
    noCenter: {
      type: Boolean,
      default: false
    },
    noFade: {
      type: Boolean,
      default: false
    },
    spinnerType: {
      type: String,
      default: "border"
    },
    spinnerVariant: {
      type: String // default: null

    },
    spinnerSmall: {
      type: Boolean,
      default: false
    },
    overlayTag: {
      type: String,
      default: "div"
    },
    wrapTag: {
      type: String,
      default: "div"
    },
    noWrap: {
      type: Boolean,
      default: false
    },
    fixed: {
      type: Boolean,
      default: false
    },
    zIndex: {
      type: [Number, String],
      default: 10
    }
  },
  computed: {
    computedRounded: function computedRounded() {
      var rounded = this.rounded;
      return rounded === true || rounded === "" ? "rounded" : !rounded ? "" : "rounded-".concat(rounded);
    },
    computedVariant: function computedVariant() {
      return this.variant && !this.bgColor ? "bg-".concat(this.variant) : "";
    },
    overlayScope: function overlayScope() {
      return {
        spinnerType: this.spinnerType || null,
        spinnerVariant: this.spinnerVariant || null,
        spinnerSmall: this.spinnerSmall
      };
    }
  },
  methods: {
    defaultOverlayFn: function defaultOverlayFn(_ref) {
      var spinnerType = _ref.spinnerType,
          spinnerVariant = _ref.spinnerVariant,
          spinnerSmall = _ref.spinnerSmall;
      return this.$createElement(NlySpinner, {
        props: {
          type: spinnerType,
          variant: spinnerVariant,
          small: spinnerSmall
        }
      });
    }
  },
  render: function render(h) {
    var _this = this;

    var $overlay = h();

    if (this.show) {
      var scope = this.overlayScope;
      var $background = h("div", {
        staticClass: "position-absolute",
        class: [this.computedVariant, this.computedRounded],
        style: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, positionCover), {}, {
          opacity: this.opacity,
          backgroundColor: this.bgColor || null,
          backdropFilter: this.blur ? "blur(".concat(this.blur, ")") : null
        })
      });
      var $content = h("div", {
        staticClass: "position-absolute",
        style: this.noCenter ? Object(objectSpread2["a" /* default */])({}, positionCover) : {
          top: "50%",
          left: "50%",
          transform: "translateX(-50%) translateY(-50%)"
        }
      }, [this.normalizeSlot("overlay", scope) || this.defaultOverlayFn(scope)]);
      $overlay = h(this.overlayTag, {
        key: "overlay",
        staticClass: "nly-overlay",
        class: {
          "position-absolute": !this.noWrap || this.noWrap && !this.fixed,
          "position-fixed": this.noWrap && this.fixed
        },
        style: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, positionCover), {}, {
          zIndex: this.zIndex || 10
        }),
        on: {
          click: function click(evt) {
            return _this.$emit("click", evt);
          }
        }
      }, [$background, $content]);
    }

    $overlay = h(NlyToastTransition, {
      props: {
        noFade: this.noFade,
        appear: true
      },
      on: {
        "after-enter": function afterEnter() {
          return _this.$emit("shown");
        },
        "after-leave": function afterLeave() {
          return _this.$emit("hidden");
        }
      }
    }, [$overlay]);

    if (this.noWrap) {
      return $overlay;
    }

    if (this.sidebar) {
      return h(this.wrapTag, {
        staticClass: "nly-overlay",
        attrs: {
          id: "sidebar-overlay"
        }
      }, [$overlay]);
    } else if (this.custom) {
      return h("div", {
        staticClass: "overlay",
        class: this.dark ? "dark" : ""
      }, this.$slots.default);
    } else {
      return h(this.wrapTag, {
        staticClass: "nly-overlay-wrap position-relative",
        attrs: {
          "aria-busy": this.show ? "true" : null
        }
      }, this.noWrap ? [$overlay] : [this.normalizeSlot("default"), $overlay]);
    }
  }
});
// CONCATENATED MODULE: ./src/utils/mixin-id.js
var nlyId = function nlyId(id) {
  return "nly_id_".concat(id);
};
var nlyDropdownParentId = function nlyDropdownParentId(id) {
  return "nly_dropdown_parent_id_".concat(id);
};
var nlyDropdownId = function nlyDropdownId(id) {
  return "nly_dropdown_id_".concat(id);
};
var nlyDropdownMenuId = function nlyDropdownMenuId(id) {
  return "nly_dropdown_menu_id_".concat(id);
};
var nlyCollapseId = function nlyCollapseId(id) {
  return "nly_collapse_id_".concat(id);
};
var nlySwitchId = function nlySwitchId(id) {
  return id ? "nly_switch_id_".concat(id) : "";
};
var nlyCardId = function nlyCardId(id) {
  return id ? "nly_card_id_".concat(id) : null;
};
// CONCATENATED MODULE: ./src/components/card/card.js
/**
 * **** card-group ****
 * .card-group 卡片组
 * .card-deck 水平卡片组
 * .card-columns 垂直卡片组。超过一行无法排列，就会垂直排列
 * .accordion
 *
 * **** card ****
 * .card  card基础类
 * .card-info card-* 背景颜色类，给header添加背景色 card-*一类颜色只能作用于header
 * .card-outline 在有card-info情况下，给header添加顶部border,header背景色为白色，没有则无效
 * .card-outline-tabs 作用于header中的a标签，放在 card div的class中。鼠标悬浮a标签时a标签出现顶部border
 * .card-tabs
 * .text-light 文字颜色
 * .bg-* 背景颜色，整个card一起设置。header中会被card-*一类颜色覆盖
 * .bg-gradient-* 渐变背景色
 * .height-control 控制body高度，最大300px
 *
 * **** card-img ****
 * .card-img 四个圆角
 * .card-img-top top圆角
 * .card-img-buttom buttom圆角
 * 当body,header,footer设置.card-img-overlay的时候，图片作为背景图片。避免三个同时有card-img-overlay，会堆叠
 *
 * **** card-body ****
 * .card-body 基础类
 * .bg-*
 * .card-img-overlay 把card-img作为背景图
 * .text-light 文字颜色
 *
 * **** card-header ****
 * .card-header 基础类
 * .bg-*
 * .card-img-overlay 把card-img作为背景图
 * .text-light 文字颜色
 *
 * **** card-tool ****
 * .card-tool 基础类
 * .card-tool只能放在header中且只能是header的子元素
 *
 * card-tool下可以用btn-group show，将高亮。在没有card-*的情况下
 * btn-group show
 *
 * **** card-footer ****
 * .card-footer 基础类
 * .bg-*
 * .card-img-overlay 把card-img作为背景图
 * .text-light 文字颜色
 *
 * **** card-title ****
 * .card-title 基础类
 * .text-light 文字颜色
 *
 * **** card-subtitle ****
 * .card-subtitle 基础类
 * .text-light 文字颜色
 *
 * **** card-text ****
 * .card-text 基础类
 * .text-light 文字颜色
 *
 * **** card-link ****
 * .card-link link标签
 *
 * **** card-comments ****
 * bg-*
 * text-light
 *
 * **** card-comments-img
 * img-circle
 *
 * **** comment-text ****
 * text-light
 *
 * **** card-comments-username
 * text-light
 *
 */







var card_props = {
  headerVariant: {
    type: String
  },
  headerOutline: {
    type: Boolean,
    default: false
  },
  cardOutlineTabs: {
    type: Boolean,
    default: false
  },
  cardTabs: {
    type: Boolean,
    default: false
  },
  textVariant: {
    type: String
  },
  bgVariant: {
    type: String
  },
  bgGradientVariant: {
    type: String
  },
  heightControl: {
    type: Boolean,
    default: false
  },
  cardClass: {
    type: String
  },
  loading: {
    type: Boolean,
    default: false
  },
  loadingContent: {
    type: String
  },
  loadingContentTag: {
    type: String,
    default: "p"
  },
  loadingContentClass: {
    type: String
  },
  loadingIcon: {
    type: String,
    default: "fas fa-2x fa-sync-alt fa-spin"
  },
  loadingImgSrc: {
    type: String
  },
  loadingImgClass: {
    type: String
  },
  tag: {
    type: String,
    default: "div"
  },
  dark: {
    type: Boolean,
    default: false
  },
  id: {
    type: String
  }
};

var card_customAttrs = function customAttrs(props) {
  var id = function id() {
    return nlyCardId(props.id);
  };

  return {
    id: id()
  };
};

var card_customClass = function customClass(props) {
  var headerVariant = function headerVariant() {
    return nlyGetOptionsByKeyEqual(cardVariantOptions, props.headerVariant);
  };

  var headerOutline = function headerOutline() {
    return props.headerOutline ? "card-outline" : "";
  };

  var cardOutlineTabs = props.cardOutlineTabs ? "card-outline-tabs" : "";
  var cardTabs = props.cardTabs ? "card-tabs" : "";

  var textVariant = function textVariant() {
    return nlyGetOptionsByKeyEqual(textVariantOptions, props.textVariant);
  };

  var bgVariant = function bgVariant() {
    return nlyGetOptionsByKeyEqual(bgVariantOptions, props.bgVariant);
  };

  var bgGradientVariant = function bgGradientVariant() {
    return nlyGetOptionsByKeyEqual(bgGradientOptions, props.bgGradientVariant);
  };

  var heightControl = props.heightControl ? "height-control" : "";
  var cardClass = props.cardClass;
  return [headerVariant(), headerOutline(), cardOutlineTabs, cardTabs, textVariant(), bgVariant(), bgGradientVariant(), heightControl, cardClass];
};

var card_name = "NlyCard";
var NlyCard = utils_vue.extend({
  name: card_name,
  props: card_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;

    var overlayArray = function overlayArray() {
      if (props.loadingContent) {
        return h(NlyOverlay, {
          props: {
            custom: true,
            dark: props.dark
          }
        }, [loadingContentArray()]);
      } else {
        return h(NlyOverlay, {
          props: {
            custom: true,
            dark: props.dark
          }
        }, [loadingIcon()]);
      }
    };

    var loadingContentArray = function loadingContentArray() {
      return h(props.loadingContentTag, {
        class: [props.loadingContentClass]
      }, props.loadingContent);
    };

    var loadingIcon = function loadingIcon() {
      return h(NlyIcon, {
        props: {
          icon: props.loadingIcon
        }
      });
    };

    var loadingImgArray = function loadingImgArray() {
      return h("img", {
        attrs: {
          alt: "loading-img",
          src: props.loadingImgSrc
        },
        staticClass: "loading-img",
        class: [props.loadingImgClass]
      });
    };

    var loadingArray = function loadingArray() {
      if (props.loading && !props.loadingImg) {
        return [children, overlayArray()];
      } else if (props.loading && props.loadingImg) {
        return [children, loadingImgArray()];
      } else {
        return children;
      }
    };

    return h(props.tag, lib_esm_a(data, {
      attrs: card_customAttrs(props),
      staticClass: "card",
      class: card_customClass(props)
    }), loadingArray());
  }
});
// CONCATENATED MODULE: ./src/components/card/card-header.js




var card_header_props = {
  bgVariant: {
    type: String
  },
  bgGradientVariant: {
    type: String
  },
  imgOverlay: {
    type: Boolean,
    default: false
  },
  textVariant: {
    type: String
  },
  cardHeaderClass: {
    type: String
  },
  tag: {
    type: String,
    default: "div"
  }
};

var card_header_customClass = function customClass(props) {
  var bgVariant = function bgVariant() {
    return nlyGetOptionsByKeyEqual(bgVariantOptions, props.bgVariant);
  };

  var bgGradientVariant = function bgGradientVariant() {
    return nlyGetOptionsByKeyEqual(bgGradientOptions, props.bgGradientVariant);
  };

  var textVariant = function textVariant() {
    return nlyGetOptionsByKeyEqual(textVariantOptions, props.textVariant);
  };

  var imgOverlay = props.imgOverlay ? "card-img-overlay" : "";
  var cardHeaderClass = props.cardHeaderClass;
  return [bgVariant(), bgGradientVariant(), textVariant(), imgOverlay, cardHeaderClass];
};

var card_header_name = "NlyCardHeader";
var NlyCardHeader = utils_vue.extend({
  name: card_header_name,
  props: card_header_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "card-header",
      class: card_header_customClass(props)
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/card/card-body.js




var card_body_props = {
  bgVariant: {
    type: String
  },
  bgGradientVariant: {
    type: String
  },
  imgOverlay: {
    type: Boolean,
    default: false
  },
  textVariant: {
    type: String
  },
  cardBodyClass: {
    type: String
  },
  tag: {
    type: String,
    default: "div"
  }
};

var card_body_customClass = function customClass(props) {
  var bgVariant = function bgVariant() {
    return nlyGetOptionsByKeyEqual(bgVariantOptions, props.bgVariant);
  };

  var bgGradientVariant = function bgGradientVariant() {
    return nlyGetOptionsByKeyEqual(bgGradientOptions, props.bgGradientVariant);
  };

  var textVariant = function textVariant() {
    return nlyGetOptionsByKeyEqual(textVariantOptions, props.textVariant);
  };

  var imgOverlay = props.imgOverlay ? "card-img-overlay" : "";
  var cardBodyClass = props.cardBodyClass;
  return [bgVariant(), bgGradientVariant(), textVariant(), imgOverlay, cardBodyClass];
};

var card_body_name = "NlyCardBody";
var NlyCardBody = utils_vue.extend({
  name: card_body_name,
  props: card_body_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "card-body",
      class: card_body_customClass(props)
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/card/card-footer.js




var card_footer_props = {
  bgVariant: {
    type: String
  },
  bgGradientVariant: {
    type: String
  },
  imgOverlay: {
    type: Boolean,
    default: false
  },
  textVariant: {
    type: String
  },
  cardFooterClass: {
    type: String
  },
  tag: {
    type: String,
    default: "div"
  }
};

var card_footer_customClass = function customClass(props) {
  var bgVariant = function bgVariant() {
    return nlyGetOptionsByKeyEqual(bgVariantOptions, props.bgVariant);
  };

  var bgGradientVariant = function bgGradientVariant() {
    return nlyGetOptionsByKeyEqual(bgGradientOptions, props.bgGradientVariant);
  };

  var textVariant = function textVariant() {
    return nlyGetOptionsByKeyEqual(textVariantOptions, props.textVariant);
  };

  var imgOverlay = props.imgOverlay ? "card-img-overlay" : "";
  var cardFooterClass = props.cardFooterClass;
  return [bgVariant(), bgGradientVariant(), textVariant(), imgOverlay, cardFooterClass];
};

var card_footer_name = "NlyCardFooter";
var NlyCardFooter = utils_vue.extend({
  name: card_footer_name,
  props: card_footer_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "card-footer",
      class: card_footer_customClass(props)
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/card/card-title.js




var card_title_name = "NlyCardTitle";
var card_title_props = {
  textVariant: {
    type: String
  },
  cardTitleClass: {
    type: String
  },
  tag: {
    type: String,
    default: "h4"
  },
  left: {
    type: Boolean,
    default: false
  }
};

var card_title_customClass = function customClass(props) {
  var textVariant = function textVariant() {
    return nlyGetOptionsByKeyEqual(textVariantOptions, props.textVariant);
  };

  var cardTitleClass = props.cardTitleClass;
  var left = props.left ? "card-title-left" : "";
  return [textVariant(), cardTitleClass, left];
};

var NlyCardTitle = utils_vue.extend({
  name: card_title_name,
  props: card_title_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "card-title",
      class: card_title_customClass(props)
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/card/card-subtitle.js
// * **** card-title ****
// * .card-title 基础类
// * .text-light 文字颜色




var card_subtitle_name = "NlyCardSubtitle";
var card_subtitle_props = {
  textVariant: {
    type: String
  },
  cardSubtitleClass: {
    type: String
  },
  tag: {
    type: String,
    default: "h6"
  }
};

var card_subtitle_customClass = function customClass(props) {
  var textVariant = function textVariant() {
    return nlyGetOptionsByKeyEqual(textVariantOptions, props.textVariant);
  };

  var cardSubtitleClass = props.cardSubtitleClass;
  return [textVariant(), cardSubtitleClass];
};

var NlyCardSubtitle = utils_vue.extend({
  name: card_subtitle_name,
  props: card_subtitle_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "card-subtitle",
      class: card_subtitle_customClass(props)
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/card/card-img.js


var card_img_props = {
  top: {
    type: Boolean,
    default: false
  },
  bottom: {
    type: Boolean,
    default: false
  },
  src: {
    type: String,
    required: true
  },
  cardImgClass: {
    type: String
  }
};

var card_img_customClass = function customClass(props) {
  var top = props.top ? "card-img-top" : "";
  var bottom = props.bottom ? "card-img-bottom" : "";
  var baseClass = !props.top && !props.bottom ? "card-img" : "";
  var cardImgClass = props.cardImgClass;
  return [top, bottom, baseClass, cardImgClass];
};

var card_img_name = "NlyCardImg";
var NlyCardImg = utils_vue.extend({
  name: card_img_name,
  props: card_img_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h("img", lib_esm_a(data, {
      class: card_img_customClass(props),
      attrs: {
        src: props.src
      }
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/card/card-tool.js


var card_tool_name = "NlyCardTool";
var card_tool_props = {
  cardToolClass: {
    type: String
  },
  tag: {
    type: String,
    default: "div"
  }
};
var NlyCardTool = utils_vue.extend({
  name: card_tool_name,
  props: card_tool_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "card-tools",
      class: [props.cardToolClass]
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/card/card-text.js




var card_text_name = "NlyCardText";
var card_text_props = {
  cardTextClass: {
    type: String
  },
  tag: {
    type: String,
    default: "p"
  },
  textVariant: {
    type: String
  }
};

var card_text_customClass = function customClass(props) {
  var cardTextClass = props.cardTextClass;

  var textVariant = function textVariant() {
    return nlyGetOptionsByKeyEqual(textVariantOptions, props.textVariant);
  };

  return [textVariant(), cardTextClass];
};

var NlyCardText = utils_vue.extend({
  name: card_text_name,
  props: card_text_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "card-text",
      class: card_text_customClass(props)
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/card/index.js











var CardPlugin = plugins_nlyPluginFactory({
  components: {
    NlyCardGroup: NlyCardGroup,
    NlyCard: NlyCard,
    NlyCardHeader: NlyCardHeader,
    NlyCardBody: NlyCardBody,
    NlyCardFooter: NlyCardFooter,
    NlyCardTitle: NlyCardTitle,
    NlyCardSubtitle: NlyCardSubtitle,
    NlyCardImg: NlyCardImg,
    NlyCardTool: NlyCardTool,
    NlyCardText: NlyCardText
  }
});

// CONCATENATED MODULE: ./src/utils/collapse-transition.js




var collapse_transition_onEnter = function onEnter(el) {
  el.style.height = 0;
  requestAF(function () {
    reflow(el);
    el.style.height = "".concat(el.scrollHeight, "px");
  });
};

var collapse_transition_onAfterEnter = function onAfterEnter(el) {
  el.style.height = null;
};

var collapse_transition_onLeave = function onLeave(el) {
  el.style.height = "auto";
  el.style.display = "block";
  el.style.height = "".concat(getBCR(el).height, "px");
  reflow(el);
  el.style.height = 0;
};

var collapse_transition_onAfterLeave = function onAfterLeave(el) {
  el.style.height = null;
};

var TRANSITION_PROPS = {
  css: true,
  enterClass: "",
  enterActiveClass: "collapsing",
  enterToClass: "collapse show",
  leaveClass: "collapse show",
  leaveActiveClass: "collapsing",
  leaveToClass: "collapse"
};
var TRANSITION_HANDLERS = {
  enter: collapse_transition_onEnter,
  afterEnter: collapse_transition_onAfterEnter,
  leave: collapse_transition_onLeave,
  afterLeave: collapse_transition_onAfterLeave
};
var NlyCollapseTransition = utils_vue.extend({
  name: "NlyCollapseTransition",
  functional: true,
  props: {
    appear: {
      type: Boolean,
      default: false
    }
  },
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h("transition", lib_esm_a(data, {
      props: TRANSITION_PROPS,
      on: TRANSITION_HANDLERS
    }, {
      props: props
    }), children);
  }
});
// CONCATENATED MODULE: ./src/utils/nlya-collapse.js
// Generic collapse transion helper component
//
// Note:
//   Applies the classes `collapse`, `show` and `collapsing`
//   during the enter/leave transition phases only
//   Although it appears that Vue may be leaving the classes
//   in-place after the transition completes


 // Transition event handler helpers

var nlya_collapse_onEnter = function onEnter(el) {
  el.style.height = 0; // Animaton frame delay needed for `appear` to work

  requestAF(function () {
    reflow(el);
    el.style.height = "".concat(el.scrollHeight, "px");
  });
};

var nlya_collapse_onAfterEnter = function onAfterEnter(el) {
  el.style.height = null;
};

var nlya_collapse_onLeave = function onLeave(el) {
  el.style.height = "auto";
  el.style.display = "block";
  el.style.height = "".concat(getBCR(el).height, "px");
  reflow(el);
  el.style.height = 0;
};

var nlya_collapse_onAfterLeave = function onAfterLeave(el) {
  el.style.height = null;
}; // Default transition props
// `appear` will use the enter classes


var nlya_collapse_TRANSITION_PROPS = {
  css: true,
  enterClass: "",
  enterActiveClass: "collapsing",
  enterToClass: "collapse show",
  leaveClass: "collapse show",
  leaveActiveClass: "collapsing",
  leaveToClass: "collapse"
}; // Default transition handlers
// `appear` will use the enter handlers

var nlya_collapse_TRANSITION_HANDLERS = {
  enter: nlya_collapse_onEnter,
  afterEnter: nlya_collapse_onAfterEnter,
  leave: nlya_collapse_onLeave,
  afterLeave: nlya_collapse_onAfterLeave
}; // @vue/component

var NLYACollapse = /*#__PURE__*/utils_vue.extend({
  name: "NLYACollapse",
  functional: true,
  props: {
    appear: {
      // If `true` (and `visible` is `true` on mount), animate initially visible
      type: Boolean,
      default: false
    }
  },
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h("transition", // We merge in the `appear` prop last
    lib_esm_a(data, {
      props: nlya_collapse_TRANSITION_PROPS,
      on: nlya_collapse_TRANSITION_HANDLERS
    }, {
      props: props
    }), // Note: `<transition>` supports a single root element only
    children);
  }
});
// CONCATENATED MODULE: ./src/mixins/id.js


/* harmony default export */ var mixins_id = ({
  props: {
    id: {
      type: String,
      default: null
    }
  },
  data: function data() {
    return {
      localId_: null
    };
  },
  computed: {
    safeId: function safeId() {
      var id = this.id || this.localId_;

      var fn = function fn(suffix) {
        if (!id) {
          return null;
        }

        suffix = String(suffix || "").replace(/\s+/g, "_");
        return suffix ? id + "_" + suffix : id;
      };

      return fn;
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      _this.localId_ = "_nly_id_".concat(_this._uid);
    });
  }
});
// CONCATENATED MODULE: ./src/mixins/listen-on-root.js

/* harmony default export */ var listen_on_root = ({
  methods: {
    /**
     * Safely register event listeners on the root Vue node.
     * While Vue automatically removes listeners for individual components,
     * when a component registers a listener on root and is destroyed,
     * this orphans a callback because the node is gone,
     * but the root does not clear the callback.
     *
     * When registering a $root listener, it also registers a listener on
     * the component's `beforeDestroy` hook to automatically remove the
     * event listener from the $root instance.
     *
     * @param {string} event
     * @param {function} callback
     * @chainable
     */
    listenOnRoot: function listenOnRoot(event, callback) {
      var _this = this;

      this.$root.$on(event, callback);
      this.$on("hook:beforeDestroy", function () {
        _this.$root.$off(event, callback);
      }); // Return this for easy chaining

      return this;
    },

    /**
     * Safely register a $once event listener on the root Vue node.
     * While Vue automatically removes listeners for individual components,
     * when a component registers a listener on root and is destroyed,
     * this orphans a callback because the node is gone,
     * but the root does not clear the callback.
     *
     * When registering a $root listener, it also registers a listener on
     * the component's `beforeDestroy` hook to automatically remove the
     * event listener from the $root instance.
     *
     * @param {string} event
     * @param {function} callback
     * @chainable
     */
    listenOnRootOnce: function listenOnRootOnce(event, callback) {
      var _this2 = this;

      this.$root.$once(event, callback);
      this.$on("hook:beforeDestroy", function () {
        _this2.$root.$off(event, callback);
      }); // Return this for easy chaining

      return this;
    },

    /**
     * Convenience method for calling vm.$emit on vm.$root.
     * @param {string} event
     * @param {*} args
     * @chainable
     */
    emitOnRoot: function emitOnRoot(event) {
      var _this$$root;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      (_this$$root = this.$root).$emit.apply(_this$$root, [event].concat(args)); // Return this for easy chaining


      return this;
    }
  }
});
// CONCATENATED MODULE: ./src/utils/loose-equal.js



var compareArrays = function compareArrays(a, b) {
  if (a.length !== b.length) {
    return false;
  }

  var equal = true;

  for (var i = 0; equal && i < a.length; i++) {
    equal = loose_equal_looseEqual(a[i], b[i]);
  }

  return equal;
};

var loose_equal_looseEqual = function looseEqual(a, b) {
  if (a === b) {
    return true;
  }

  var aValidType = isDate(a);
  var bValidType = isDate(b);

  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }

  aValidType = isArray(a);
  bValidType = isArray(b);

  if (aValidType || bValidType) {
    return aValidType && bValidType ? compareArrays(a, b) : false;
  }

  aValidType = object_isObject(a);
  bValidType = object_isObject(b);

  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }

    var aKeysCount = keys(a).length;
    var bKeysCount = keys(b).length;

    if (aKeysCount !== bKeysCount) {
      return false;
    }

    for (var key in a) {
      // eslint-disable-next-line no-prototype-builtins
      var aHasKey = a.hasOwnProperty(key); // eslint-disable-next-line no-prototype-builtins

      var bHasKey = b.hasOwnProperty(key);

      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }

  return String(a) === String(b);
};

/* harmony default export */ var loose_equal = (loose_equal_looseEqual);
// CONCATENATED MODULE: ./src/directives/toggle/toggle.js















 // --- Constants ---

var ENTER = key_codes.ENTER,
    SPACE = key_codes.SPACE; // Classes to apply to trigger element

var CLASS_NLYA_TOGGLE_COLLAPSED = "collapsed";
var CLASS_NLYA_TOGGLE_NOT_COLLAPSED = "not-collapsed"; // Property key for handler storage

var NLYA_BASE = "__NLYA_toggle"; // Root event listener property (Function)

var NLYA_TOGGLE_ROOT_HANDLER = "".concat(NLYA_BASE, "_HANDLER__"); // Trigger element click handler property (Function)

var NLYA_TOGGLE_CLICK_HANDLER = "".concat(NLYA_BASE, "_CLICK__"); // Target visibility state property (Boolean)

var NLYA_TOGGLE_STATE = "".concat(NLYA_BASE, "_STATE__"); // Target ID list property (Array)

var NLYA_TOGGLE_TARGETS = "".concat(NLYA_BASE, "_TARGETS__"); // Commonly used strings

var STRING_FALSE = "false";
var STRING_TRUE = "true"; // Commonly used attribute names

var ATTR_ARIA_CONTROLS = "aria-controls";
var ATTR_ARIA_EXPANDED = "aria-expanded";
var ATTR_ROLE = "role";
var ATTR_TABINDEX = "tabindex"; // Emitted control event for collapse (emitted to collapse)

var EVENT_TOGGLE = "nlya::toggle::collapse"; // Listen to event for toggle state update (emitted by collapse)

var EVENT_STATE = "nlya::collapse::state"; // Private event emitted on `$root` to ensure the toggle state is always synced
// Gets emitted even if the state of b-collapse has not changed
// This event is NOT to be documented as people should not be using it

var EVENT_STATE_SYNC = "nlya::collapse::sync::state"; // Private event we send to collapse to request state update sync event

var EVENT_STATE_REQUEST = "nlya::request::collapse::state";
var KEYDOWN_KEY_CODES = [ENTER, SPACE];
var RX_HASH = /^#/;
var RX_HASH_ID = /^#[A-Za-z]+[\w\-:.]*$/;
var RX_SPLIT_SEPARATOR = /\s+/; // --- Helper methods ---

var toggle_isNonStandardTag = function isNonStandardTag(el) {
  return !arrayIncludes(["button", "a"], el.tagName.toLowerCase());
};

var toggle_getTargets = function getTargets(_ref, el) {
  var modifiers = _ref.modifiers,
      arg = _ref.arg,
      value = _ref.value;
  // Any modifiers are considered target IDs
  var targets = keys(modifiers || {}); // If value is a string, split out individual targets (if space delimited)

  value = isString(value) ? value.split(RX_SPLIT_SEPARATOR) : value; // Support target ID as link href (`href="#id"`)

  if (dom_isTag(el.tagName, "a")) {
    var href = getAttr(el, "href") || "";

    if (RX_HASH_ID.test(href)) {
      targets.push(href.replace(RX_HASH, ""));
    }
  } // Add ID from `arg` (if provided), and support value
  // as a single string ID or an array of string IDs
  // If `value` is not an array or string, then it gets filtered out


  concat(arg, value).forEach(function (t) {
    return isString(t) && targets.push(t);
  }); // Return only unique and truthy target IDs

  return targets.filter(function (t, index, arr) {
    return t && arr.indexOf(t) === index;
  });
};

var toggle_removeClickListener = function removeClickListener(el) {
  var handler = el[NLYA_TOGGLE_CLICK_HANDLER];

  if (handler) {
    eventOff(el, "click", handler);
    eventOff(el, "keydown", handler);
  }

  el[NLYA_TOGGLE_CLICK_HANDLER] = null;
};

var toggle_addClickListener = function addClickListener(el, vnode) {
  toggle_removeClickListener(el);

  if (vnode.context) {
    var handler = function handler(evt) {
      if (!(evt.type === "keydown" && !arrayIncludes(KEYDOWN_KEY_CODES, evt.keyCode)) && !dom_isDisabled(el)) {
        var targets = el[NLYA_TOGGLE_TARGETS] || [];
        targets.forEach(function (target) {
          vnode.context.$root.$emit(EVENT_TOGGLE, target);
        });
      }
    };

    el[NLYA_TOGGLE_CLICK_HANDLER] = handler;
    eventOn(el, "click", handler);

    if (toggle_isNonStandardTag(el)) {
      eventOn(el, "keydown", handler);
    }
  }
};

var removeRootListeners = function removeRootListeners(el, vnode) {
  if (el[NLYA_TOGGLE_ROOT_HANDLER] && vnode.context) {
    vnode.context.$root.$off([EVENT_STATE, EVENT_STATE_SYNC], el[NLYA_TOGGLE_ROOT_HANDLER]);
  }

  el[NLYA_TOGGLE_ROOT_HANDLER] = null;
};

var toggle_addRootListeners = function addRootListeners(el, vnode) {
  removeRootListeners(el, vnode);

  if (vnode.context) {
    var handler = function handler(id, state) {
      // `state` will be `true` if target is expanded
      if (arrayIncludes(el[NLYA_TOGGLE_TARGETS] || [], id)) {
        // Set/Clear 'collapsed' visibility class state
        el[NLYA_TOGGLE_STATE] = state; // Set `aria-expanded` and class state on trigger element

        toggle_setToggleState(el, state);
      }
    };

    el[NLYA_TOGGLE_ROOT_HANDLER] = handler; // Listen for toggle state changes (public) and sync (private)

    vnode.context.$root.$on([EVENT_STATE, EVENT_STATE_SYNC], handler);
  }
};

var toggle_setToggleState = function setToggleState(el, state) {
  // State refers to the visibility of the collapse/sidebar
  if (state) {
    removeClass(el, CLASS_NLYA_TOGGLE_COLLAPSED);
    addClass(el, CLASS_NLYA_TOGGLE_NOT_COLLAPSED);
    setAttr(el, ATTR_ARIA_EXPANDED, STRING_TRUE);
  } else {
    removeClass(el, CLASS_NLYA_TOGGLE_NOT_COLLAPSED);
    addClass(el, CLASS_NLYA_TOGGLE_COLLAPSED);
    setAttr(el, ATTR_ARIA_EXPANDED, STRING_FALSE);
  }
}; // Reset and remove a property from the provided element


var resetProp = function resetProp(el, prop) {
  el[prop] = null;
  delete el[prop];
}; // Handle directive updates


var toggle_handleUpdate = function handleUpdate(el, binding, vnode) {
  /* istanbul ignore next: should never happen */
  if (!env["g" /* isBrowser */] || !vnode.context) {
    return;
  } // If element is not a button or link, we add `role="button"`
  // and `tabindex="0"` for accessibility reasons


  if (toggle_isNonStandardTag(el)) {
    if (!hasAttr(el, ATTR_ROLE)) {
      setAttr(el, ATTR_ROLE, "button");
    }

    if (!hasAttr(el, ATTR_TABINDEX)) {
      setAttr(el, ATTR_TABINDEX, "0");
    }
  } // Ensure the collapse class and `aria-*` attributes persist
  // after element is updated (either by parent re-rendering
  // or changes to this element or its contents)


  toggle_setToggleState(el, el[NLYA_TOGGLE_STATE]); // Parse list of target IDs

  var targets = toggle_getTargets(binding, el);
  /* istanbul ignore else */
  // Ensure the `aria-controls` hasn't been overwritten
  // or removed when vnode updates

  if (targets.length) {
    setAttr(el, ATTR_ARIA_CONTROLS, targets.join(" "));
  } else {
    removeAttr(el, ATTR_ARIA_CONTROLS);
  } // Add/Update our click listener(s)


  toggle_addClickListener(el, vnode); // If targets array has changed, update

  if (!loose_equal(targets, el[NLYA_TOGGLE_TARGETS])) {
    // Update targets array to element storage
    el[NLYA_TOGGLE_TARGETS] = targets; // Ensure `aria-controls` is up to date
    // Request a state update from targets so that we can
    // ensure expanded state is correct (in most cases)

    targets.forEach(function (target) {
      vnode.context.$root.$emit(EVENT_STATE_REQUEST, target);
    });
  }
};
/*
 * Export our directive
 */


var VNlyToggle = {
  bind: function bind(el, binding, vnode) {
    // State is initially collapsed until we receive a state event
    el[NLYA_TOGGLE_STATE] = false; // Assume no targets initially

    el[NLYA_TOGGLE_TARGETS] = []; // Add our root listeners

    toggle_addRootListeners(el, vnode); // Initial update of trigger

    toggle_handleUpdate(el, binding, vnode);
  },
  componentUpdated: toggle_handleUpdate,
  updated: toggle_handleUpdate,
  unbind: function unbind(el, binding, vnode) {
    toggle_removeClickListener(el); // Remove our $root listener

    removeRootListeners(el, vnode); // Reset custom props

    resetProp(el, NLYA_TOGGLE_ROOT_HANDLER);
    resetProp(el, NLYA_TOGGLE_CLICK_HANDLER);
    resetProp(el, NLYA_TOGGLE_STATE);
    resetProp(el, NLYA_TOGGLE_TARGETS); // Reset classes/attrs

    removeClass(el, CLASS_NLYA_TOGGLE_COLLAPSED);
    removeClass(el, CLASS_NLYA_TOGGLE_NOT_COLLAPSED);
    removeAttr(el, ATTR_ARIA_EXPANDED);
    removeAttr(el, ATTR_ARIA_CONTROLS);
    removeAttr(el, ATTR_ROLE);
  }
};
// CONCATENATED MODULE: ./src/components/collapse/collapse.js








 // --- Constants ---
// Accordion event name we emit on `$root`

var EVENT_ACCORDION = "nlya::collapse::accordion"; // --- Main component ---
// @vue/component

var NlyCollapse = /*#__PURE__*/utils_vue.extend({
  name: "NlyCollapse",
  mixins: [mixins_id, listen_on_root, mixins_normalize_slot],
  model: {
    prop: "visible",
    event: "input"
  },
  props: {
    isNav: {
      type: Boolean,
      default: false
    },
    accordion: {
      type: String // default: null

    },
    visible: {
      type: Boolean,
      default: false
    },
    tag: {
      type: String,
      default: "div"
    },
    appear: {
      // If `true` (and `visible` is `true` on mount), animate initially visible
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      show: this.visible,
      transitioning: false
    };
  },
  computed: {
    classObject: function classObject() {
      return {
        "navbar-collapse": this.isNav,
        collapse: !this.transitioning,
        show: this.show && !this.transitioning
      };
    }
  },
  watch: {
    visible: function visible(newVal) {
      if (newVal !== this.show) {
        this.show = newVal;
      }
    },
    show: function show(newVal, oldVal) {
      if (newVal !== oldVal) {
        this.emitState();
      }
    }
  },
  created: function created() {
    this.show = this.visible;
  },
  mounted: function mounted() {
    var _this = this;

    this.show = this.visible; // Listen for toggle events to open/close us

    this.listenOnRoot(EVENT_TOGGLE, this.handleToggleEvt); // Listen to other collapses for accordion events

    this.listenOnRoot(EVENT_ACCORDION, this.handleAccordionEvt);

    if (this.isNav) {
      // Set up handlers
      this.setWindowEvents(true);
      this.handleResize();
    }

    this.$nextTick(function () {
      _this.emitState();
    }); // Listen for "Sync state" requests from `v-b-toggle`

    this.listenOnRoot(EVENT_STATE_REQUEST, function (id) {
      if (id === _this.safeId()) {
        _this.$nextTick(_this.emitSync);
      }
    });
  },
  updated: function updated() {
    // Emit a private event every time this component updates to ensure
    // the toggle button is in sync with the collapse's state
    // It is emitted regardless if the visible state changes
    this.emitSync();
  },

  /* istanbul ignore next */
  deactivated: function deactivated()
  /* istanbul ignore next */
  {
    if (this.isNav) {
      this.setWindowEvents(false);
    }
  },

  /* istanbul ignore next */
  activated: function activated()
  /* istanbul ignore next */
  {
    if (this.isNav) {
      this.setWindowEvents(true);
    }

    this.emitSync();
  },
  beforeDestroy: function beforeDestroy() {
    // Trigger state emit if needed
    this.show = false;

    if (this.isNav && env["g" /* isBrowser */]) {
      this.setWindowEvents(false);
    }
  },
  methods: {
    setWindowEvents: function setWindowEvents(on) {
      eventOnOff(on, window, "resize", this.handleResize, EVENT_OPTIONS_NO_CAPTURE);
      eventOnOff(on, window, "orientationchange", this.handleResize, EVENT_OPTIONS_NO_CAPTURE);
    },
    toggle: function toggle() {
      this.show = !this.show;
    },
    onEnter: function onEnter() {
      this.transitioning = true; // This should be moved out so we can add cancellable events

      this.$emit("show");
    },
    onAfterEnter: function onAfterEnter() {
      this.transitioning = false;
      this.$emit("shown");
    },
    onLeave: function onLeave() {
      this.transitioning = true; // This should be moved out so we can add cancellable events

      this.$emit("hide");
    },
    onAfterLeave: function onAfterLeave() {
      this.transitioning = false;
      this.$emit("hidden");
    },
    emitState: function emitState() {
      this.$emit("input", this.show); // Let `v-b-toggle` know the state of this collapse

      this.emitOnRoot(EVENT_STATE, this.safeId(), this.show);

      if (this.accordion && this.show) {
        // Tell the other collapses in this accordion to close
        this.emitOnRoot(EVENT_ACCORDION, this.safeId(), this.accordion);
      }
    },
    emitSync: function emitSync() {
      // Emit a private event every time this component updates to ensure
      // the toggle button is in sync with the collapse's state
      // It is emitted regardless if the visible state changes
      this.emitOnRoot(EVENT_STATE_SYNC, this.safeId(), this.show);
    },
    checkDisplayBlock: function checkDisplayBlock() {
      // Check to see if the collapse has `display: block !important` set
      // We can't set `display: none` directly on `this.$el`, as it would
      // trigger a new transition to start (or cancel a current one)
      var restore = hasClass(this.$el, "show");
      removeClass(this.$el, "show");
      var isBlock = dom_getCS(this.$el).display === "block";

      if (restore) {
        addClass(this.$el, "show");
      }

      return isBlock;
    },
    clickHandler: function clickHandler(evt) {
      // If we are in a nav/navbar, close the collapse when non-disabled link clicked
      var el = evt.target;

      if (!this.isNav || !el || dom_getCS(this.$el).display !== "block") {
        /* istanbul ignore next: can't test getComputedStyle in JSDOM */
        return;
      }

      if (matches(el, ".nav-link,.dropdown-item") || closest(".nav-link,.dropdown-item", el)) {
        if (!this.checkDisplayBlock()) {
          // Only close the collapse if it is not forced to be `display: block !important`
          this.show = false;
        }
      }
    },
    handleToggleEvt: function handleToggleEvt(target) {
      if (target !== this.safeId()) {
        return;
      }

      this.toggle();
    },
    handleAccordionEvt: function handleAccordionEvt(openedId, accordion) {
      if (!this.accordion || accordion !== this.accordion) {
        return;
      }

      if (openedId === this.safeId()) {
        // Open this collapse if not shown
        if (!this.show) {
          this.toggle();
        }
      } else {
        // Close this collapse if shown
        if (this.show) {
          this.toggle();
        }
      }
    },
    handleResize: function handleResize() {
      // Handler for orientation/resize to set collapsed state in nav/navbar
      this.show = dom_getCS(this.$el).display === "block";
    }
  },
  render: function render(h) {
    var _this2 = this;

    var scope = {
      visible: this.show,
      close: function close() {
        return _this2.show = false;
      }
    };
    var content = h(this.tag, {
      class: this.classObject,
      directives: [{
        name: "show",
        value: this.show
      }],
      attrs: {
        id: this.safeId()
      },
      on: {
        click: this.clickHandler
      }
    }, [this.normalizeSlot("default", scope)]);
    return h(NLYACollapse, {
      props: {
        appear: this.appear
      },
      on: {
        enter: this.onEnter,
        afterEnter: this.onAfterEnter,
        leave: this.onLeave,
        afterLeave: this.onAfterLeave
      }
    }, [content]);
  }
});
// CONCATENATED MODULE: ./src/directives/toggle/index.js


var VNlyTogglePlugin = plugins_nlyPluginFactory({
  directives: {
    VNlyToggle: VNlyToggle
  }
});

// CONCATENATED MODULE: ./src/utils/collapse-noclass-transition.js

 // import { toInteger } from "../../utils/number";

var beforeEnter = function beforeEnter(el) {
  el.style.transition = "all 0.5s";
  if (!el.dataset) el.dataset = {};
  el.dataset.oldPaddingTop = el.style.paddingTop;
  el.dataset.oldPaddingBottom = el.style.paddingBottom;
  el.style.height = 0;
  el.style.paddingTop = 0;
  el.style.paddingBottom = 0;
};

var enter = function enter(el) {
  el.style.display = "block";
  el.dataset.oldOverflow = el.style.overflow;

  if (el.scrollHeight !== 0) {
    el.style.height = el.scrollHeight + "px";
    el.style.paddingTop = el.dataset.oldPaddingTop;
    el.style.paddingBottom = el.dataset.oldPaddingBottom;
  } else {
    el.style.height = "";
    el.style.paddingTop = el.dataset.oldPaddingTop;
    el.style.paddingBottom = el.dataset.oldPaddingBottom;
  }

  el.style.overflow = "hidden";
};

var afterEnter = function afterEnter(el) {
  el.style.transition = "";
  el.style.height = "";
  el.style.overflow = el.dataset.oldOverflow;
};

var beforeLeave = function beforeLeave(el) {
  if (!el.dataset) el.dataset = {};
  el.dataset.oldPaddingTop = el.style.paddingTop;
  el.dataset.oldPaddingBottom = el.style.paddingBottom;
  el.dataset.oldOverflow = el.style.overflow;
  el.style.height = el.scrollHeight + "px";
  el.style.overflow = "hidden";
};

var collapse_noclass_transition_leave = function leave(el) {
  if (el.scrollHeight !== 0) {
    el.style.transition = "all 0.5s";
    el.style.height = 0;
    el.style.paddingTop = 0;
    el.style.paddingBottom = 0;
  }
};

var afterLeave = function afterLeave(el) {
  el.style.transition = "";
  el.style.height = "";
  el.style.overflow = el.dataset.oldOverflow;
  el.style.paddingTop = el.dataset.oldPaddingTop;
  el.style.paddingBottom = el.dataset.oldPaddingBottom;
};

var collapse_noclass_transition_TRANSITION_HANDLERS = {
  beforeEnter: beforeEnter,
  enter: enter,
  afterEnter: afterEnter,
  beforeLeave: beforeLeave,
  leave: collapse_noclass_transition_leave,
  afterLeave: afterLeave
};
var collapse_noclass_transition_name = "NlyCollapseNoclassTransition";
var NlyCollapseNoclassTransition = utils_vue.extend({
  name: collapse_noclass_transition_name,
  props: {
    appear: {
      // If `true` (and `visible` is `true` on mount), animate initially visible
      type: Boolean,
      default: false
    }
  },
  functional: true,
  render: function render(h, _ref) {
    var data = _ref.data,
        children = _ref.children;
    return h("transition", lib_esm_a(data, {
      on: collapse_noclass_transition_TRANSITION_HANDLERS
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/collapse/collapse-noclass.js








 // --- Constants ---
// Accordion event name we emit on `$root`

var collapse_noclass_EVENT_ACCORDION = "nlya::collapse::accordion"; // --- Main component ---
// @vue/component

var NlyCollapseNoclass = /*#__PURE__*/utils_vue.extend({
  name: "NlyCollapseNoclass",
  mixins: [mixins_id, listen_on_root, mixins_normalize_slot],
  model: {
    prop: "visible",
    event: "input"
  },
  props: {
    isNav: {
      type: Boolean,
      default: false
    },
    accordion: {
      type: String // default: null

    },
    visible: {
      type: Boolean,
      default: false
    },
    tag: {
      type: String,
      default: "div"
    },
    appear: {
      // If `true` (and `visible` is `true` on mount), animate initially visible
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      show: this.visible,
      transitioning: false
    };
  },
  computed: {
    classObject: function classObject() {
      return {
        "navbar-collapse": this.isNav,
        collapse: !this.transitioning,
        show: this.show && !this.transitioning
      };
    }
  },
  watch: {
    visible: function visible(newVal) {
      if (newVal !== this.show) {
        this.show = newVal;
      }
    },
    show: function show(newVal, oldVal) {
      if (newVal !== oldVal) {
        this.emitState();
      }
    }
  },
  created: function created() {
    this.show = this.visible;
  },
  mounted: function mounted() {
    var _this = this;

    this.show = this.visible; // Listen for toggle events to open/close us

    this.listenOnRoot(EVENT_TOGGLE, this.handleToggleEvt); // Listen to other collapses for accordion events

    this.listenOnRoot(collapse_noclass_EVENT_ACCORDION, this.handleAccordionEvt);

    if (this.isNav) {
      // Set up handlers
      this.setWindowEvents(true);
      this.handleResize();
    }

    this.$nextTick(function () {
      _this.emitState();
    }); // Listen for "Sync state" requests from `v-b-toggle`

    this.listenOnRoot(EVENT_STATE_REQUEST, function (id) {
      if (id === _this.safeId()) {
        _this.$nextTick(_this.emitSync);
      }
    });
  },
  updated: function updated() {
    // Emit a private event every time this component updates to ensure
    // the toggle button is in sync with the collapse's state
    // It is emitted regardless if the visible state changes
    this.emitSync();
  },

  /* istanbul ignore next */
  deactivated: function deactivated()
  /* istanbul ignore next */
  {
    if (this.isNav) {
      this.setWindowEvents(false);
    }
  },

  /* istanbul ignore next */
  activated: function activated()
  /* istanbul ignore next */
  {
    if (this.isNav) {
      this.setWindowEvents(true);
    }

    this.emitSync();
  },
  beforeDestroy: function beforeDestroy() {
    // Trigger state emit if needed
    this.show = false;

    if (this.isNav && env["g" /* isBrowser */]) {
      this.setWindowEvents(false);
    }
  },
  methods: {
    setWindowEvents: function setWindowEvents(on) {
      eventOnOff(on, window, "resize", this.handleResize, EVENT_OPTIONS_NO_CAPTURE);
      eventOnOff(on, window, "orientationchange", this.handleResize, EVENT_OPTIONS_NO_CAPTURE);
    },
    toggle: function toggle() {
      this.show = !this.show;
    },
    onEnter: function onEnter() {
      this.transitioning = true; // This should be moved out so we can add cancellable events

      this.$emit("show");
    },
    onAfterEnter: function onAfterEnter() {
      this.transitioning = false;
      this.$emit("shown");
    },
    onLeave: function onLeave() {
      this.transitioning = true; // This should be moved out so we can add cancellable events

      this.$emit("hide");
    },
    onAfterLeave: function onAfterLeave() {
      this.transitioning = false;
      this.$emit("hidden");
    },
    emitState: function emitState() {
      this.$emit("input", this.show); // Let `v-b-toggle` know the state of this collapse

      this.emitOnRoot(EVENT_STATE, this.safeId(), this.show);

      if (this.accordion && this.show) {
        // Tell the other collapses in this accordion to close
        this.emitOnRoot(collapse_noclass_EVENT_ACCORDION, this.safeId(), this.accordion);
      }
    },
    emitSync: function emitSync() {
      // Emit a private event every time this component updates to ensure
      // the toggle button is in sync with the collapse's state
      // It is emitted regardless if the visible state changes
      this.emitOnRoot(EVENT_STATE_SYNC, this.safeId(), this.show);
    },
    checkDisplayBlock: function checkDisplayBlock() {
      // Check to see if the collapse has `display: block !important` set
      // We can't set `display: none` directly on `this.$el`, as it would
      // trigger a new transition to start (or cancel a current one)
      var restore = hasClass(this.$el, "show");
      removeClass(this.$el, "show");
      var isBlock = dom_getCS(this.$el).display === "block";

      if (restore) {
        addClass(this.$el, "show");
      }

      return isBlock;
    },
    clickHandler: function clickHandler(evt) {
      // If we are in a nav/navbar, close the collapse when non-disabled link clicked
      var el = evt.target;

      if (!this.isNav || !el || dom_getCS(this.$el).display !== "block") {
        /* istanbul ignore next: can't test getComputedStyle in JSDOM */
        return;
      }

      if (matches(el, ".nav-link,.dropdown-item") || closest(".nav-link,.dropdown-item", el)) {
        if (!this.checkDisplayBlock()) {
          // Only close the collapse if it is not forced to be `display: block !important`
          this.show = false;
        }
      }
    },
    handleToggleEvt: function handleToggleEvt(target) {
      if (target !== this.safeId()) {
        return;
      }

      this.toggle();
    },
    handleAccordionEvt: function handleAccordionEvt(openedId, accordion) {
      if (!this.accordion || accordion !== this.accordion) {
        return;
      }

      if (openedId === this.safeId()) {
        // Open this collapse if not shown
        if (!this.show) {
          this.toggle();
        }
      } else {
        // Close this collapse if shown
        if (this.show) {
          this.toggle();
        }
      }
    },
    handleResize: function handleResize() {
      // Handler for orientation/resize to set collapsed state in nav/navbar
      this.show = dom_getCS(this.$el).display === "block";
    }
  },
  render: function render(h) {
    var _this2 = this;

    var scope = {
      visible: this.show,
      close: function close() {
        return _this2.show = false;
      }
    };
    var content = h(this.tag, {
      class: this.classObject,
      directives: [{
        name: "show",
        value: this.show
      }],
      attrs: {
        id: this.safeId()
      },
      on: {
        click: this.clickHandler
      }
    }, [this.normalizeSlot("default", scope)]);
    return h(NlyCollapseNoclassTransition, {
      props: {
        appear: this.appear
      },
      on: {
        enter: this.onEnter,
        afterEnter: this.onAfterEnter,
        leave: this.onLeave,
        afterLeave: this.onAfterLeave
      }
    }, [content]);
  }
});
// CONCATENATED MODULE: ./src/components/collapse/index.js





var CollapsePlugin = plugins_nlyPluginFactory({
  components: {
    NlyCollapseTransition: NlyCollapseTransition,
    NlyCollapse: NlyCollapse,
    NlyCollapseNoclass: NlyCollapseNoclass
  },
  directives: {
    VNlyToggle: VNlyToggle
  }
});

// CONCATENATED MODULE: ./src/components/container/container.js


var container_props = {
  fluid: {
    type: Boolean,
    default: false
  },
  containerClass: {
    type: String
  },
  tag: {
    type: String,
    default: "div"
  }
};
var container_name = "NlyContainer";
var NlyContainer = utils_vue.extend({
  name: container_name,
  props: container_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      class: [props.fluid ? "container-fluid" : "container", props.containerClass]
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/container/index.js


var ContainerPlugin = plugins_nlyPluginFactory({
  components: {
    NlyContainer: NlyContainer
  }
});

// CONCATENATED MODULE: ./src/components/content/content-wrapper.js


var content_wrapper_props = {
  tag: {
    type: String,
    default: "section"
  }
};
var content_wrapper_name = "NlyContentWrapper";
var NlyContentWrapper = utils_vue.extend({
  name: content_wrapper_name,
  props: content_wrapper_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "content-wrapper"
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/content/content-header.js


var content_header_props = {
  tag: {
    type: String,
    default: "section"
  }
};
var content_header_name = "NlyContentHeader";
var NlyContentHeader = utils_vue.extend({
  name: content_header_name,
  props: content_header_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "content-header"
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/content/content.js


var content_props = {
  tag: {
    type: String,
    default: "section"
  }
};
var content_name = "NlyContent";
var NlyContent = utils_vue.extend({
  name: content_name,
  props: content_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "content"
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/content/index.js




var ContentPlugin = plugins_nlyPluginFactory({
  components: {
    NlyContentWrapper: NlyContentWrapper,
    NlyContentHeader: NlyContentHeader,
    NlyContent: NlyContent
  }
});

// EXTERNAL MODULE: ./node_modules/overlayscrollbars/css/OverlayScrollbars.css
var OverlayScrollbars = __webpack_require__("52b6");

// EXTERNAL MODULE: ./node_modules/overlayscrollbars/js/OverlayScrollbars.js
var js_OverlayScrollbars = __webpack_require__("dbe5");
var js_OverlayScrollbars_default = /*#__PURE__*/__webpack_require__.n(js_OverlayScrollbars);

// CONCATENATED MODULE: ./node_modules/overlayscrollbars-vue/dist/overlayscrollbars-vue.esm.js



class overlayscrollbars_vue_esm_OverlayScrollbarsComponent extends external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
    name: 'overlay-scrollbars',
    props: {
        options: {
            type: Object
        },
        extensions: {
            type: [String, Array, Object]
        }
    },
    methods: {
        osInstance() {
            return this._osInstace;
        },
        osTarget() {
            return this.$el || null;
        }
    },
    watch: {
        options(currOptions, oldOptions) {
            let osInstance = this._osInstace;
            if (js_OverlayScrollbars_default.a.valid(osInstance)) {
                osInstance.options(currOptions);
            }
        }
    },
    data() {
        return {};
    },
    mounted() {
        this._osInstace = js_OverlayScrollbars_default()(this.osTarget(), this.options || {}, this.extensions);
    },
    beforeDestroy() {
        const osInstance = this._osInstace;
        if (js_OverlayScrollbars_default.a.valid(osInstance)) {
            osInstance.destroy();
            this._osInstace = null;
        }
    }
}) {
    constructor() {
        super(...arguments);
        this._osInstace = null;
    }
}

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
        createInjectorSSR = createInjector;
        createInjector = shadowMode;
        shadowMode = false;
    }
    // Vue.extend constructor export interop.
    const options = typeof script === 'function' ? script.options : script;
    // render functions
    if (template && template.render) {
        options.render = template.render;
        options.staticRenderFns = template.staticRenderFns;
        options._compiled = true;
        // functional template
        if (isFunctionalTemplate) {
            options.functional = true;
        }
    }
    // scopedId
    if (scopeId) {
        options._scopeId = scopeId;
    }
    let hook;
    if (moduleIdentifier) {
        // server build
        hook = function (context) {
            // 2.3 injection
            context =
                context || // cached call
                    (this.$vnode && this.$vnode.ssrContext) || // stateful
                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
            // 2.2 with runInNewContext: true
            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                context = __VUE_SSR_CONTEXT__;
            }
            // inject component styles
            if (style) {
                style.call(this, createInjectorSSR(context));
            }
            // register component module identifier for async chunk inference
            if (context && context._registeredComponents) {
                context._registeredComponents.add(moduleIdentifier);
            }
        };
        // used by ssr in case component is cached and beforeCreate
        // never gets called
        options._ssrRegister = hook;
    }
    else if (style) {
        hook = shadowMode
            ? function (context) {
                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
            }
            : function (context) {
                style.call(this, createInjector(context));
            };
    }
    if (hook) {
        if (options.functional) {
            // register for functional component in vue file
            const originalRender = options.render;
            options.render = function renderWithStyleInjection(h, context) {
                hook.call(context);
                return originalRender(h, context);
            };
        }
        else {
            // inject component registration as beforeCreate hook
            const existing = options.beforeCreate;
            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
    }
    return script;
}

/* script */
const __vue_script__ = overlayscrollbars_vue_esm_OverlayScrollbarsComponent;

/* template */
var __vue_render__ = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "os-host" }, [
    _c("div", { staticClass: "os-resize-observer-host" }),
    _vm._v(" "),
    _c("div", { staticClass: "os-padding" }, [
      _c("div", { staticClass: "os-viewport" }, [
        _c("div", { staticClass: "os-content" }, [_vm._t("default")], 2)
      ])
    ]),
    _vm._v(" "),
    _vm._m(0),
    _vm._v(" "),
    _vm._m(1),
    _vm._v(" "),
    _c("div", { staticClass: "os-scrollbar-corner" })
  ])
};
var __vue_staticRenderFns__ = [
  function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "os-scrollbar os-scrollbar-horizontal " }, [
      _c("div", { staticClass: "os-scrollbar-track" }, [
        _c("div", { staticClass: "os-scrollbar-handle" })
      ])
    ])
  },
  function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "os-scrollbar os-scrollbar-vertical" }, [
      _c("div", { staticClass: "os-scrollbar-track" }, [
        _c("div", { staticClass: "os-scrollbar-handle" })
      ])
    ])
  }
];
__vue_render__._withStripped = true;

  /* style */
  const __vue_inject_styles__ = undefined;
  /* scoped */
  const __vue_scope_id__ = undefined;
  /* module identifier */
  const __vue_module_identifier__ = undefined;
  /* functional template */
  const __vue_is_functional_template__ = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__ = normalizeComponent(
    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    false,
    undefined,
    undefined,
    undefined
  );

const OverlayScrollbarsPlugin = {
    install(vue, options) {
        if (options) {
            js_OverlayScrollbars_default.a.defaultOptions(options);
        }
        vue.component('overlay-scrollbars', __vue_component__);
    }
};


//# sourceMappingURL=overlayscrollbars-vue.esm.js.map

// CONCATENATED MODULE: ./src/components/control-sidebar/control-sidebar-container.js
 // import { hasClass } from "../../utils/dom";




var control_sidebar_container_name = "NlyControlSidebarContainer";
var NlyControlSidebarContainer = utils_vue.extend({
  name: control_sidebar_container_name,
  functional: true,
  render: function render(h, _ref) {
    var data = _ref.data,
        children = _ref.children;
    return h(__vue_component__, lib_esm_a(data, {
      staticClass: "control-sidebar-content",
      props: {
        options: {
          scrollbars: {
            autoHide: "scroll"
          }
        }
      }
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/control-sidebar/control-sidebar.js





var control_sidebar_props = {
  light: {
    type: Boolean,
    default: false
  },
  bgVariant: {
    type: String
  },
  bgGradientVariant: {
    type: String
  },
  size: {
    type: String
  },
  controlSidebarClass: {
    type: String
  },
  tag: {
    type: String,
    default: "aside"
  }
};

var control_sidebar_customClass = function customClass(props) {
  var light = function light() {
    if (!props.bgVariant && !props.bgGradientVariant) {
      return props.light ? "control-sidebar-light" : "control-sidebar-dark";
    } else {
      return null;
    }
  };

  var bgVariant = function bgVariant() {
    return !props.bgGradientVariant ? nlyGetOptionsByKeyEqual(bgVariantOptions, props.bgVariant) : null;
  };

  var bgGradientVariant = function bgGradientVariant() {
    return nlyGetOptionsByKeyEqual(bgGradientOptions, props.bgGradientVariant);
  };

  var size = function size() {
    return props.size ? nlyGetOptionsByKeyEqual(textSizeOptions, props.size) : "";
  };

  return [light(), bgVariant(), bgGradientVariant(), size(), props.controlSidebarClass];
};

var control_sidebar_name = "NlyControlSidebar";
var NlyControlSidebar = utils_vue.extend({
  name: control_sidebar_name,
  props: control_sidebar_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "control-sidebar",
      class: control_sidebar_customClass(props)
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/control-sidebar/control-sidebar-button.js

// import Vue from "../../utils/vue";
// import { nlyGetOptionsByKeyEqual } from "../../utils/get-options";
// import { bgVariantOptions } from "../../utils/nly-config";
// const name = "NlyControlSidebarButton";
// export const NlyControlSidebarButton = Vue.extend({
//   name: name,
//   props: {
//     bgVariant: {
//       type: String
//     }
//   },
//   computed: {
//     customProps: function() {
//       return {
//         bgVariant: nlyGetOptionsByKeyEqual(bgVariantOptions, this.bgVariant)
//       };
//     }
//   },
//   methods: {
//     mouseenterFunc() {
//       this.$el.classList.remove("elevation-2");
//       this.$el.classList.add("elevation-4");
//       this.$el.style.opacity = "1";
//     },
//     mouseleaveFunc() {
//       this.$el.classList.remove("elevation-4");
//       this.$el.classList.add("elevation-2");
//       this.$el.style.opacity = "0.8";
//     }
//   },
//   render(h) {
//     return h("div", {
//       class: [this.customProps.bgVariant, "elevation-2"],
//       style: {
//         width: "40px",
//         height: "20px",
//         borderRadius: "25px",
//         marginRight: "10px",
//         marginBottom: "10px",
//         opacity: "0.8",
//         cursor: "pointer"
//       },
//       on: {
//         ...this.$listeners,
//         mouseenter: this.mouseenterFunc,
//         mouseleave: this.mouseleaveFunc
//       }
//     });
//   }
// });




var control_sidebar_button_props = {
  bgVariant: {
    type: String
  },
  bgGradientVariant: {
    type: String
  },
  tag: {
    type: String,
    default: "div"
  },
  role: {
    type: String,
    default: "button"
  },
  controlButtonClass: {
    type: String
  },
  id: {
    type: [String, Number],
    required: true
  }
};

var control_sidebar_button_customClass = function customClass(props) {
  var bgVariant = function bgVariant() {
    return nlyGetOptionsByKeyEqual(bgVariantOptions, props.bgVariant);
  };

  var bgGradientVariant = function bgGradientVariant() {
    return nlyGetOptionsByKeyEqual(bgGradientOptions, props.bgGradientVariant);
  };

  return [bgVariant(), bgGradientVariant(), props.controlButtonClass];
};

var safeId = function safeId(props) {
  return "__nly_control_button_".concat(props.id, "__");
};

var control_sidebar_button_name = "NlyControlSidebarButton";
var NlyControlSidebarButton = utils_vue.extend({
  name: control_sidebar_button_name,
  props: control_sidebar_button_props,
  functional: true,
  render: function render(h, context) {
    return h(context.props.tag, lib_esm_a(context.data, {
      staticClass: "elevation-2",
      class: control_sidebar_button_customClass(context.props),
      style: {
        width: "40px",
        height: "20px",
        borderRadius: "25px",
        marginRight: "10px",
        marginBottom: "10px",
        opacity: "0.8",
        cursor: "pointer"
      },
      attrs: {
        role: context.props.role,
        id: safeId(context.props)
      },
      on: {
        mouseenter: function mouseenter() {
          var id = safeId(context.props);
          var vnodes = document.querySelector("#".concat(id));
          vnodes.classList.remove("elevation-2");
          vnodes.classList.add("elevation-4");
          vnodes.style.opacity = "1";
        },
        mouseleave: function mouseleave() {
          var id = safeId(context.props);
          var vnodes = document.querySelector("#".concat(id));
          vnodes.classList.remove("elevation-4");
          vnodes.classList.add("elevation-2");
          vnodes.style.opacity = "0.8";
        }
      }
    }), context.children);
  }
});
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.promise.js
var es_promise = __webpack_require__("e6cf");

// EXTERNAL MODULE: ./node_modules/regenerator-runtime/runtime.js
var runtime = __webpack_require__("96cf");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js



function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}
// CONCATENATED MODULE: ./src/utils/sidebar-collapse.js






var eventType = {
  collapse: "sidebar-collapse",
  open: "sidebar-open",
  show: "control-sidebar-slide-open",
  animate: "control-sidebar-animate"
};
var sidebar_collapse_selector = {
  controlSidebar: ".control-sidebar",
  header: ".main-header",
  footer: ".main-footer",
  controlSidebarContent: ".control-sidebar-content"
};
var getSelector = function getSelector(cls) {
  return document.querySelector(cls);
};
var getBodyClassName = function getBodyClassName() {
  return document.body.className;
};
var getBodyWidth = function getBodyWidth() {
  return document.body.clientWidth;
};
var navItemOenEvent = function navItemOenEvent() {
  var bodyClassName = getBodyClassName();

  if (bodyClassName.indexOf(eventType.collapse) == -1) {
    if (bodyClassName.indexOf(eventType.open) == -1) {
      document.body.classList.add(eventType.collapse);
    } else {
      document.body.classList.remove(eventType.open);
      document.body.classList.add(eventType.collapse);
    }
  } else {
    document.body.classList.add(eventType.open);
    document.body.classList.remove(eventType.collapse);
  }
};
var navItemCollapseEvent = function navItemCollapseEvent() {
  var bodyClassName = getBodyClassName();

  if (bodyClassName.indexOf(eventType.collapse) == -1) {
    document.body.classList.add(eventType.collapse);
  } else {
    document.body.classList.remove(eventType.collapse);
  }
};
var sidebar_collapse_setInstanceAttr = function setInstanceAttr(vnode) {
  var bodyWidth = getBodyWidth();

  if (bodyWidth < 992) {
    setAttr(vnode.children[0].elm, "data-widget", eventType.open);
  } else {
    setAttr(vnode.children[0].elm, "data-widget", eventType.collapse);
  }
};
var overLayCollapseEvent = function overLayCollapseEvent() {
  var bodyClassName = getBodyClassName();

  if (bodyClassName.indexOf(eventType.collapse) == -1) {
    document.body.classList.remove(eventType.open);
    document.body.classList.add(eventType.collapse);
  }
};
var getScrollTop = function getScrollTop() {
  return document.documentElement && document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body ? document.body.scrollTop : 0;
};
var getScrollHeight = function getScrollHeight() {
  return document.documentElement && document.documentElement.scrollHeight ? document.documentElement.scrollHeight : document.body ? document.body.scrollHeight : 0;
};
var getBodyOffsetHeight = function getBodyOffsetHeight() {
  return document.documentElement && document.documentElement.offsetHeight ? document.documentElement.offsetHeight : document.body ? document.body.offsetHeight : 0;
};
/**
 * 展开先给html添加class='control-sidebar-animate'
 * 设置control-sidebar display='block'
 * 10ms之后给body添加class='control-sidebar-slide-open'
 * 300ms之后给html删除class='control-sidebar-animate'
 *
 * 收起先给html添加class='control-sidebar-animate'
 * 删除body class='control-sidebar-slide-open
 * 300ms之后设置control-sidebar display='none'
 * html删除class='control-sidebar-animate'
 * @param {s} vnode
 */
// 10ms之后给body添加class='control-sidebar-slide-open'

var openAddBodyClass = function openAddBodyClass() {
  return new Promise(function (resolve) {
    setTimeout(function () {
      document.body.classList.add(eventType.show);
      resolve();
    }, 10);
  });
}; // 300ms之后给html删除class='control-sidebar-animate'

var openRemoveHtmlClass = function openRemoveHtmlClass() {
  return new Promise(function (resolve) {
    setTimeout(function () {
      getSelector("html").classList.remove(eventType.animate);
      resolve();
    }, 300);
  });
}; // 300ms之后设置control-sidebar display='none'

var collapseSetAttrsDisplay = function collapseSetAttrsDisplay() {
  return new Promise(function (resolve) {
    setTimeout(function () {
      getSelector(sidebar_collapse_selector.controlSidebar).style.display = "none";
      resolve();
    }, 300);
  });
}; // html删除class='control-sidebar-animate'

var collapseRemoveHtmlClass = function collapseRemoveHtmlClass() {
  getSelector("html").classList.remove(eventType.animate);
}; // 队列执行open操作

function openTasks() {
  return _openTasks.apply(this, arguments);
} // 队列执行collapse操作

function _openTasks() {
  _openTasks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return openAddBodyClass();

          case 2:
            _context.next = 4;
            return openRemoveHtmlClass();

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _openTasks.apply(this, arguments);
}

function collapseTasks() {
  return _collapseTasks.apply(this, arguments);
} // 监听header，footer高度以及滚动条高度，给control-siderbar设置height

function _collapseTasks() {
  _collapseTasks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return collapseSetAttrsDisplay();

          case 2:
            _context2.next = 4;
            return collapseRemoveHtmlClass();

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _collapseTasks.apply(this, arguments);
}

var setControlSidebarStyle = function setControlSidebarStyle() {
  var windowHeight = document.documentElement.clientHeight;
  var bodyHeight = getBodyOffsetHeight();
  var scrollTop = getScrollTop();
  var scrollHeight = getScrollHeight();
  var headerHeight = getSelector(sidebar_collapse_selector.header).offsetHeight;
  var footerHeight = getSelector(sidebar_collapse_selector.footer).offsetHeight;
  var controlSidebarSelector = getSelector(sidebar_collapse_selector.controlSidebar);
  var controlSidebarContentSelector = getSelector(sidebar_collapse_selector.controlSidebarContent);

  if (scrollTop < headerHeight) {
    if (bodyHeight - windowHeight >= footerHeight) {
      controlSidebarSelector.style.top = "".concat(headerHeight - scrollTop, "px");

      if (footerHeight - scrollHeight + windowHeight - headerHeight + scrollTop + footerHeight > 0) {
        controlSidebarSelector.style.height = "".concat(scrollHeight - footerHeight - footerHeight, "px");
        controlSidebarContentSelector.style.height = "".concat(scrollHeight - footerHeight - footerHeight, "px");
      } else {
        controlSidebarSelector.style.height = "".concat(windowHeight - headerHeight + scrollTop, "px");
        controlSidebarContentSelector.style.height = "".concat(windowHeight - headerHeight + scrollTop, "px");
      }
    } else {
      controlSidebarSelector.style.top = "".concat(headerHeight - scrollTop, "px");
      controlSidebarSelector.style.height = "".concat(bodyHeight - headerHeight - footerHeight, "px");
      controlSidebarContentSelector.style.height = "".concat(bodyHeight - headerHeight - footerHeight, "px");
      controlSidebarSelector.style.bottom = "".concat(footerHeight - bodyHeight + windowHeight + scrollTop, "px");
    }
  } else {
    controlSidebarSelector.style.top = "0px";

    if (scrollHeight - windowHeight - scrollTop <= footerHeight) {
      controlSidebarSelector.style.height = "".concat(scrollHeight - footerHeight - scrollTop, "px");
      controlSidebarContentSelector.style.height = "".concat(scrollHeight - footerHeight - scrollTop, "px");
      controlSidebarSelector.style.bottom = "".concat(windowHeight + scrollTop + footerHeight - scrollHeight, "px");
    } else if (scrollHeight - windowHeight - scrollTop > footerHeight) {
      controlSidebarSelector.style.height = "".concat(windowHeight, "px");
      controlSidebarContentSelector.style.height = "".concat(windowHeight, "px");
    }
  }
}; // 展开 control-sidebar

var controlSidebarOpen = function controlSidebarOpen() {
  getSelector("html").classList.add(eventType.animate);
  getSelector(sidebar_collapse_selector.controlSidebar).style.display = "block";
  openTasks();
  window.addEventListener("scroll", setControlSidebarStyle, false);
  window.addEventListener("resize", setControlSidebarStyle, false);
}; // 收起 control-sidebar

var controlSidebarCollapse = function controlSidebarCollapse() {
  getSelector("html").classList.add(eventType.animate);
  document.body.classList.remove(eventType.show);
  collapseTasks();
  window.removeEventListener("scroll", setControlSidebarStyle, false);
  window.removeEventListener("resize", setControlSidebarStyle, false);
};
var controlSidebarShow = function controlSidebarShow() {
  var bodyClassName = getBodyClassName();

  if (bodyClassName.indexOf(eventType.show) == -1) {
    controlSidebarOpen();
  } else {
    //收起
    controlSidebarCollapse();
  }
};
// CONCATENATED MODULE: ./src/directives/sidebar-collapse/sidebar-collapse.js



var VNlySidebarCollapse = {
  bind: function bind(el, binding, vnode) {
    var instanceNameList = Object.keys(binding.modifiers);

    if (instanceNameList.indexOf("navitem") != -1) {
      window.addEventListener("resize", function () {
        return sidebar_collapse_setInstanceAttr(vnode);
      }, false);
    }

    el.onclick = function () {
      if (instanceNameList.indexOf("navitem") != -1) {
        var bodyWidth = document.body.clientWidth;

        if (bodyWidth < 992) {
          navItemOenEvent();
        } else {
          navItemCollapseEvent();
        }
      }

      if (instanceNameList.indexOf("overlay") != -1) {
        overLayCollapseEvent();
      }
    };
  }
};
// CONCATENATED MODULE: ./src/directives/sidebar-collapse/control-sidebar-collapse.js

var VNlyControlSidebarCollapse = {
  bind: function bind(el) {
    el.onclick = function () {
      var windowHeight = document.documentElement.clientHeight;
      var bodyHeight = getBodyOffsetHeight();
      var scrollTop = getScrollTop();
      var scrollHeight = getScrollHeight();
      var headerHeight = getSelector(sidebar_collapse_selector.header).offsetHeight;
      var footerHeight = getSelector(sidebar_collapse_selector.footer).offsetHeight;
      var controlSidebarSelector = getSelector(sidebar_collapse_selector.controlSidebar);
      var controlSidebarContentSelector = getSelector(sidebar_collapse_selector.controlSidebarContent);

      if (bodyHeight - windowHeight >= footerHeight) {
        controlSidebarSelector.style.top = "".concat(headerHeight - scrollTop, "px");

        if (footerHeight - scrollHeight + windowHeight - headerHeight + scrollTop + footerHeight > 0) {
          controlSidebarSelector.style.height = "".concat(scrollHeight - footerHeight - footerHeight, "px");
          controlSidebarContentSelector.style.height = "".concat(scrollHeight - footerHeight - footerHeight, "px");
        } else {
          controlSidebarSelector.style.height = "".concat(windowHeight - headerHeight + scrollTop, "px");
          controlSidebarContentSelector.style.height = "".concat(windowHeight - headerHeight + scrollTop, "px");
        }
      } else {
        controlSidebarSelector.style.top = "".concat(headerHeight - scrollTop, "px");
        controlSidebarSelector.style.height = "".concat(bodyHeight - headerHeight - footerHeight, "px");
        controlSidebarContentSelector.style.height = "".concat(bodyHeight - headerHeight - footerHeight, "px");
        controlSidebarSelector.style.bottom = "".concat(footerHeight - bodyHeight + windowHeight + scrollTop, "px");
      }

      controlSidebarShow();
    };
  }
};
// CONCATENATED MODULE: ./src/directives/sidebar-collapse/index.js



var VNlyCollapseSidebarPlugin = plugins_nlyPluginFactory({
  directives: {
    VNlySidebarCollapse: VNlySidebarCollapse,
    VNlyControlSidebarCollapse: VNlyControlSidebarCollapse
  }
});

// CONCATENATED MODULE: ./src/components/control-sidebar/index.js





var ControlSidebarPlugin = plugins_nlyPluginFactory({
  components: {
    NlyControlSidebarContainer: NlyControlSidebarContainer,
    NlyControlSidebar: NlyControlSidebar,
    NlyControlSidebarButton: NlyControlSidebarButton
  },
  directives: {
    VNlyControlSidebarCollapse: VNlyControlSidebarCollapse
  }
});

// EXTERNAL MODULE: ./node_modules/popper.js/dist/esm/popper.js
var popper = __webpack_require__("f0bd");

// CONCATENATED MODULE: ./src/mixins/click-out.js

 // @vue/component

/* harmony default export */ var click_out = ({
  data: function data() {
    return {
      listenForClickOut: false
    };
  },
  watch: {
    listenForClickOut: function listenForClickOut(newValue, oldValue) {
      if (newValue !== oldValue) {
        eventOff(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, EVENT_OPTIONS_NO_CAPTURE);

        if (newValue) {
          eventOn(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, EVENT_OPTIONS_NO_CAPTURE);
        }
      }
    }
  },
  beforeCreate: function beforeCreate() {
    // Declare non-reactive properties
    this.clickOutElement = null;
    this.clickOutEventName = null;
  },
  mounted: function mounted() {
    if (!this.clickOutElement) {
      this.clickOutElement = document;
    }

    if (!this.clickOutEventName) {
      this.clickOutEventName = "click";
    }

    if (this.listenForClickOut) {
      eventOn(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, EVENT_OPTIONS_NO_CAPTURE);
    }
  },
  beforeDestroy: function beforeDestroy()
  /* istanbul ignore next */
  {
    eventOff(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, EVENT_OPTIONS_NO_CAPTURE);
  },
  methods: {
    isClickOut: function isClickOut(evt) {
      return !dom_contains(this.$el, evt.target);
    },
    _clickOutHandler: function _clickOutHandler(evt) {
      if (this.clickOutHandler && this.isClickOut(evt)) {
        this.clickOutHandler(evt);
      }
    }
  }
});
// CONCATENATED MODULE: ./src/mixins/focus-in.js
 // @vue/component

/* harmony default export */ var focus_in = ({
  data: function data() {
    return {
      listenForFocusIn: false
    };
  },
  watch: {
    listenForFocusIn: function listenForFocusIn(newValue, oldValue) {
      if (newValue !== oldValue) {
        eventOff(this.focusInElement, "focusin", this._focusInHandler, EVENT_OPTIONS_NO_CAPTURE);

        if (newValue) {
          eventOn(this.focusInElement, "focusin", this._focusInHandler, EVENT_OPTIONS_NO_CAPTURE);
        }
      }
    }
  },
  beforeCreate: function beforeCreate() {
    // Declare non-reactive properties
    this.focusInElement = null;
  },
  mounted: function mounted() {
    if (!this.focusInElement) {
      this.focusInElement = document;
    }

    if (this.listenForFocusIn) {
      eventOn(this.focusInElement, "focusin", this._focusInHandler, EVENT_OPTIONS_NO_CAPTURE);
    }
  },
  beforeDestroy: function beforeDestroy()
  /* istanbul ignore next */
  {
    eventOff(this.focusInElement, "focusin", this._focusInHandler, EVENT_OPTIONS_NO_CAPTURE);
  },
  methods: {
    _focusInHandler: function _focusInHandler(evt) {
      if (this.focusInHandler) {
        this.focusInHandler(evt);
      }
    }
  }
});
// CONCATENATED MODULE: ./src/mixins/dropdown.js


















 // Return an array of visible items

var dropdown_filterVisibles = function filterVisibles(els) {
  return (els || []).filter(isVisible);
}; // Root dropdown event names


var ROOT_DROPDOWN_PREFIX = "nlya::dropdown::";
var ROOT_DROPDOWN_SHOWN = "".concat(ROOT_DROPDOWN_PREFIX, "shown");
var ROOT_DROPDOWN_HIDDEN = "".concat(ROOT_DROPDOWN_PREFIX, "hidden"); // Dropdown item CSS selectors

var Selector = {
  FORM_CHILD: ".dropdown form",
  ITEM_SELECTOR: [".dropdown-item", ".nly-dropdown-form"].map(function (selector) {
    return "".concat(selector, ":not(.disabled):not([disabled])");
  }).join(", ")
}; // Popper attachment positions

var AttachmentMap = {
  // Dropup left align
  TOP: "top-start",
  // Dropup right align
  TOPEND: "top-end",
  // Dropdown left align
  BOTTOM: "bottom-start",
  // Dropdown right align
  BOTTOMEND: "bottom-end",
  // Dropright left align
  RIGHT: "right-start",
  // Dropright right align
  RIGHTEND: "right-end",
  // Dropleft left align
  LEFT: "left-start",
  // Dropleft right align
  LEFTEND: "left-end"
};
var commonProps = {
  dropup: {
    // place on top if possible
    type: Boolean,
    default: false
  },
  dropright: {
    // place right if possible
    type: Boolean,
    default: false
  },
  dropleft: {
    // place left if possible
    type: Boolean,
    default: false
  },
  right: {
    // Right align menu (default is left align)
    type: Boolean,
    default: false
  },
  offset: {
    // Number of pixels to offset menu, or a CSS unit value (i.e. 1px, 1rem, etc)
    type: [Number, String],
    default: 0
  },
  noFlip: {
    // Disable auto-flipping of menu from bottom<=>top
    type: Boolean,
    default: false
  },
  popperOpts: {
    // type: Object,
    default: function _default() {}
  },
  boundary: {
    // String: `scrollParent`, `window` or `viewport`
    // HTMLElement: HTML Element reference
    type: [String, safe_types_HTMLElement],
    default: "scrollParent"
  }
}; // @vue/component

/* harmony default export */ var mixins_dropdown = ({
  mixins: [mixins_id, click_out, focus_in],
  provide: function provide() {
    return {
      nlyaDropdown: this
    };
  },
  inject: {
    nlyaNavbar: {
      default: null
    }
  },
  props: Object(objectSpread2["a" /* default */])({
    disabled: {
      type: Boolean,
      default: false
    }
  }, commonProps),
  data: function data() {
    return {
      visible: false,
      visibleChangePrevented: false
    };
  },
  computed: {
    inNavbar: function inNavbar() {
      return !isNull(this.nlyaNavbar);
    },
    toggler: function toggler() {
      var toggle = this.$refs.toggle;
      return toggle ? toggle.$el || toggle : null;
    },
    directionClass: function directionClass() {
      if (this.dropup) {
        return "dropup";
      } else if (this.dropright) {
        return "dropright";
      } else if (this.dropleft) {
        return "dropleft";
      }

      return "";
    }
  },
  watch: {
    visible: function visible(newValue, oldValue) {
      if (this.visibleChangePrevented) {
        this.visibleChangePrevented = false;
        return;
      }

      if (newValue !== oldValue) {
        var evtName = newValue ? "show" : "hide";
        var nlyEvt = new nly_event_class_NlyEvent(evtName, {
          cancelable: true,
          vueTarget: this,
          target: this.$refs.menu,
          relatedTarget: null,
          componentId: this.safeId ? this.safeId() : this.id || null
        });
        this.emitEvent(nlyEvt);

        if (nlyEvt.defaultPrevented) {
          // Reset value and exit if canceled
          this.visibleChangePrevented = true;
          this.visible = oldValue; // Just in case a child element triggered `this.hide(true)`

          this.$off("hidden", this.focusToggler);
          return;
        }

        if (evtName === "show") {
          this.showMenu();
        } else {
          this.hideMenu();
        }
      }
    },
    disabled: function disabled(newValue, oldValue) {
      if (newValue !== oldValue && newValue && this.visible) {
        // Hide dropdown if disabled changes to true
        this.visible = false;
      }
    }
  },
  created: function created() {
    // Create non-reactive property
    this.$_popper = null;
  },

  /* istanbul ignore next */
  deactivated: function deactivated()
  /* istanbul ignore next: not easy to test */
  {
    // In case we are inside a `<keep-alive>`
    this.visible = false;
    this.whileOpenListen(false);
    this.destroyPopper();
  },
  beforeDestroy: function beforeDestroy() {
    this.visible = false;
    this.whileOpenListen(false);
    this.destroyPopper();
  },
  methods: {
    // Event emitter
    emitEvent: function emitEvent(nlyEvt) {
      var type = nlyEvt.type;
      this.$emit(type, nlyEvt);
      this.$root.$emit("".concat(ROOT_DROPDOWN_PREFIX).concat(type), nlyEvt);
    },
    showMenu: function showMenu() {
      var _this = this;

      if (this.disabled) {
        /* istanbul ignore next */
        return;
      }

      if (!this.inNavbar) {
        if (typeof popper["a" /* default */] === "undefined") {
          /* istanbul ignore next */
          warn_warn("Popper.js not found. Falling back to CSS positioning", "NlyDropdown");
        } else {
          // For dropup with alignment we use the parent element as popper container
          var el = this.dropup && this.right || this.split ? this.$el : this.$refs.toggle; // Make sure we have a reference to an element, not a component!

          el = el.$el || el; // Instantiate Popper.js

          this.createPopper(el);
        }
      } // Ensure other menus are closed


      this.$root.$emit(ROOT_DROPDOWN_SHOWN, this); // Enable listeners

      this.whileOpenListen(true); // Wrap in `$nextTick()` to ensure menu is fully rendered/shown

      this.$nextTick(function () {
        // Focus on the menu container on show
        _this.focusMenu(); // Emit the shown event


        _this.$emit("shown");
      });
    },
    hideMenu: function hideMenu() {
      this.whileOpenListen(false);
      this.$root.$emit(ROOT_DROPDOWN_HIDDEN, this);
      this.$emit("hidden");
      this.destroyPopper();
    },
    createPopper: function createPopper(element) {
      this.destroyPopper();
      this.$_popper = new popper["a" /* default */](element, this.$refs.menu, this.getPopperConfig());
    },
    destroyPopper: function destroyPopper() {
      // Ensure popper event listeners are removed cleanly
      if (this.$_popper) {
        this.$_popper.destroy();
      }

      this.$_popper = null;
    },
    updatePopper: function updatePopper()
    /* istanbul ignore next: not easy to test */
    {
      // Instructs popper to re-computes the dropdown position
      // usefull if the content changes size
      try {
        this.$_popper.scheduleUpdate(); // eslint-disable-next-line no-empty
      } catch (_unused) {}
    },
    getPopperConfig: function getPopperConfig() {
      var placement = AttachmentMap.BOTTOM;

      if (this.dropup) {
        placement = this.right ? AttachmentMap.TOPEND : AttachmentMap.TOP;
      } else if (this.dropright) {
        placement = AttachmentMap.RIGHT;
      } else if (this.dropleft) {
        placement = AttachmentMap.LEFT;
      } else if (this.right) {
        placement = AttachmentMap.BOTTOMEND;
      }

      var popperConfig = {
        placement: placement,
        modifiers: {
          offset: {
            offset: this.offset || 0
          },
          flip: {
            enabled: !this.noFlip
          }
        }
      };

      if (this.boundary) {
        popperConfig.modifiers.preventOverflow = {
          boundariesElement: this.boundary
        };
      }

      return Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, popperConfig), this.popperOpts || {});
    },
    // Turn listeners on/off while open
    whileOpenListen: function whileOpenListen(isOpen) {
      // Hide the dropdown when clicked outside
      this.listenForClickOut = isOpen; // Hide the dropdown when it loses focus

      this.listenForFocusIn = isOpen; // Hide the dropdown when another dropdown is opened

      var method = isOpen ? "$on" : "$off";
      this.$root[method](ROOT_DROPDOWN_SHOWN, this.rootCloseListener);
    },
    rootCloseListener: function rootCloseListener(vm) {
      if (vm !== this) {
        this.visible = false;
      }
    },
    show: function show() {
      var _this2 = this;

      // Public method to show dropdown
      if (this.disabled) {
        return;
      } // Wrap in a `requestAF()` to allow any previous
      // click handling to occur first


      requestAF(function () {
        _this2.visible = true;
      });
    },
    hide: function hide() {
      var refocus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      // Public method to hide dropdown
      if (this.disabled) {
        /* istanbul ignore next */
        return;
      }

      this.visible = false;

      if (refocus) {
        // Child element is closing the dropdown on click
        this.$once("hidden", this.focusToggler);
      }
    },
    // Called only by a button that toggles the menu
    toggle: function toggle(evt) {
      evt = evt || {}; // Early exit when not a click event or ENTER, SPACE or DOWN were pressed

      var _evt = evt,
          type = _evt.type,
          keyCode = _evt.keyCode;

      if (type !== "click" && !(type === "keydown" && [key_codes.ENTER, key_codes.SPACE, key_codes.DOWN].indexOf(keyCode) !== -1)) {
        /* istanbul ignore next */
        return;
      }
      /* istanbul ignore next */


      if (this.disabled) {
        this.visible = false;
        return;
      }

      this.$emit("toggle", evt);
      evt.preventDefault();
      evt.stopPropagation(); // Toggle visibility

      if (this.visible) {
        this.hide(true);
      } else {
        this.show();
      }
    },
    // Mousedown handler for the toggle

    /* istanbul ignore next */
    onMousedown: function onMousedown(evt)
    /* istanbul ignore next */
    {
      // We prevent the 'mousedown' event for the toggle to stop the
      // 'focusin' event from being fired
      // The event would otherwise be picked up by the global 'focusin'
      // listener and there is no cross-browser solution to detect it
      // relates to the toggle click
      // The 'click' event will still be fired and we handle closing
      // other dropdowns there too
      // See https://github.com/bootstrap-vue/bootstrap-vue/issues/4328
      evt.preventDefault();
    },
    // Called from dropdown menu context
    onKeydown: function onKeydown(evt) {
      var keyCode = evt.keyCode;

      if (keyCode === key_codes.ESC) {
        // Close on ESC
        this.onEsc(evt);
      } else if (keyCode === key_codes.DOWN) {
        // Down Arrow
        this.focusNext(evt, false);
      } else if (keyCode === key_codes.UP) {
        // Up Arrow
        this.focusNext(evt, true);
      }
    },
    // If user presses ESC, close the menu
    onEsc: function onEsc(evt) {
      if (this.visible) {
        this.visible = false;
        evt.preventDefault();
        evt.stopPropagation(); // Return focus to original trigger button

        this.$once("hidden", this.focusToggler);
      }
    },
    // Called only in split button mode, for the split button
    onSplitClick: function onSplitClick(evt) {
      /* istanbul ignore next */
      if (this.disabled) {
        this.visible = false;
        return;
      }

      this.$emit("click", evt);
    },
    // Shared hide handler between click-out and focus-in events
    hideHandler: function hideHandler(evt) {
      var target = evt.target;

      if (this.visible && !dom_contains(this.$refs.menu, target) && !dom_contains(this.toggler, target)) {
        this.hide();
      }
    },
    // Document click-out listener
    clickOutHandler: function clickOutHandler(evt) {
      this.hideHandler(evt);
    },
    // Document focus-in listener
    focusInHandler: function focusInHandler(evt) {
      this.hideHandler(evt);
    },
    // Keyboard nav
    focusNext: function focusNext(evt, up) {
      var _this3 = this;

      // Ignore key up/down on form elements
      var target = evt.target;

      if (!this.visible || evt && closest(Selector.FORM_CHILD, target)) {
        /* istanbul ignore next: should never happen */
        return;
      }

      evt.preventDefault();
      evt.stopPropagation();
      this.$nextTick(function () {
        var items = _this3.getItems();

        if (items.length < 1) {
          /* istanbul ignore next: should never happen */
          return;
        }

        var index = items.indexOf(target);

        if (up && index > 0) {
          index--;
        } else if (!up && index < items.length - 1) {
          index++;
        }

        if (index < 0) {
          /* istanbul ignore next: should never happen */
          index = 0;
        }

        _this3.focusItem(index, items);
      });
    },
    focusItem: function focusItem(idx, items) {
      var el = items.find(function (el, i) {
        return i === idx;
      });

      if (el && el.focus) {
        el.focus();
      }
    },
    getItems: function getItems() {
      // Get all items
      return dropdown_filterVisibles(dom_selectAll(Selector.ITEM_SELECTOR, this.$refs.menu));
    },
    focusMenu: function focusMenu() {
      try {
        this.$refs.menu.focus(); // eslint-disable-next-line no-empty
      } catch (_unused2) {}
    },
    focusToggler: function focusToggler() {
      var _this4 = this;

      this.$nextTick(function () {
        var toggler = _this4.toggler;

        if (toggler && toggler.focus) {
          toggler.focus();
        }
      });
    }
  }
});
// CONCATENATED MODULE: ./src/components/dropdown/dropdown.js










var dropdown_NAME = "NlyDropdown";
var dropdown_props = {
  text: {
    // Button label
    type: String,
    default: ""
  },
  html: {
    // Button label
    type: String // default: undefined

  },
  size: {
    type: String,
    default: function _default() {
      return getComponentConfig(dropdown_NAME, "size");
    }
  },
  variant: {
    type: String,
    default: function _default() {
      return getComponentConfig(dropdown_NAME, "variant");
    }
  },
  block: {
    type: Boolean,
    default: false
  },
  menuClass: {
    type: [String, Array, Object] // default: null

  },
  toggleTag: {
    type: String,
    default: "button"
  },
  toggleText: {
    // This really should be toggleLabel
    type: String,
    default: function _default() {
      return getComponentConfig(dropdown_NAME, "toggleText");
    }
  },
  toggleClass: {
    type: [String, Array, Object] // default: null

  },
  noCaret: {
    type: Boolean,
    default: false
  },
  split: {
    type: Boolean,
    default: false
  },
  splitHref: {
    type: String // default: undefined

  },
  splitTo: {
    type: [String, Object] // default: undefined

  },
  splitVariant: {
    type: String,
    default: function _default() {
      return getComponentConfig(dropdown_NAME, "splitVariant");
    }
  },
  splitClass: {
    type: [String, Array, Object] // default: null

  },
  splitButtonType: {
    type: String,
    default: "button",
    validator: function validator(value) {
      return arrayIncludes(["button", "submit", "reset"], value);
    }
  },
  lazy: {
    // If true, only render menu contents when open
    type: Boolean,
    default: false
  },
  role: {
    type: String,
    default: "menu"
  }
};
var NlyDropdown = utils_vue.extend({
  name: dropdown_NAME,
  mixins: [mixins_id, mixins_dropdown, mixins_normalize_slot],
  props: dropdown_props,
  computed: {
    dropdownClasses: function dropdownClasses() {
      return [this.directionClass, {
        show: this.visible,
        "btn-group": this.split || !this.block,
        "d-flex": this.block && this.split,
        "position-static": this.boundary !== "scrollParent" || !this.boundary
      }];
    },
    menuClasses: function menuClasses() {
      return [this.menuClass, {
        "dropdown-menu-right": this.right,
        show: this.visible
      }];
    },
    toggleClasses: function toggleClasses() {
      return [this.toggleClass, {
        "dropdown-toggle-split": this.split,
        "dropdown-toggle-no-caret": this.noCaret && !this.split
      }];
    }
  },
  render: function render(h) {
    var split = h();
    var buttonContent = this.normalizeSlot("button-content") || this.html || stripTags(this.text);

    if (this.split) {
      var btnProps = {
        variant: this.splitVariant || this.variant,
        size: this.size,
        block: this.block,
        disabled: this.disabled
      }; // We add these as needed due to router-link issues with defined property with undefined/null values

      if (this.splitTo) {
        btnProps.to = this.splitTo;
      } else if (this.splitHref) {
        btnProps.href = this.splitHref;
      } else if (this.splitButtonType) {
        btnProps.type = this.splitButtonType;
      }

      split = h(NlyButton, {
        ref: "button",
        props: btnProps,
        class: this.splitClass,
        attrs: {
          id: this.safeId("_NLY_button_")
        },
        on: {
          click: this.onSplitClick
        }
      }, [buttonContent]);
    }

    var toggle = h(NlyButton, {
      ref: "toggle",
      staticClass: "dropdown-toggle",
      class: this.toggleClasses,
      props: {
        tag: this.toggleTag,
        variant: this.variant,
        size: this.size,
        block: this.block && !this.split,
        disabled: this.disabled
      },
      attrs: {
        id: this.safeId("_NLY_toggle_"),
        "aria-haspopup": "true",
        "aria-expanded": this.visible ? "true" : "false"
      },
      on: {
        mousedown: this.onMousedown,
        click: this.toggle,
        keydown: this.toggle
      }
    }, [this.split ? h("span", {
      class: ["sr-only"]
    }, [this.toggleText]) : buttonContent]);
    var menu = h("ul", {
      ref: "menu",
      staticClass: "dropdown-menu",
      class: this.menuClasses,
      attrs: {
        role: this.role,
        tabindex: "-1",
        "aria-labelledby": this.safeId(this.split ? "_NLY_button_" : "_NLY_toggle_")
      },
      on: {
        keydown: this.onKeydown
      }
    }, !this.lazy || this.visible ? this.normalizeSlot("default", {
      hide: this.hide
    }) : [h()]);
    return h("div", {
      staticClass: "dropdown nly-dropdown",
      class: this.dropdownClasses,
      attrs: {
        id: this.safeId()
      }
    }, [split, toggle, menu]);
  }
});
// CONCATENATED MODULE: ./src/components/dropdown/dropdown-item.js






var dropdown_item_props = propsFactory();
var NlyDropdownItem = utils_vue.extend({
  name: "NlyDropdownItem",
  mixins: [mixins_normalize_slot],
  inheritAttrs: false,
  inject: {
    nlyaDropdown: {
      default: null
    }
  },
  props: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, dropdown_item_props), {}, {
    linkClass: {
      type: [String, Array, Object],
      default: null
    },
    variant: {
      type: String,
      default: null
    }
  }),
  methods: {
    closeDropdown: function closeDropdown() {
      var _this = this;

      requestAF(function () {
        if (_this.nlyaDropdown) {
          _this.nlyaDropdown.hide(true);
        }
      });
    },
    onClick: function onClick(evt) {
      this.$emit("click", evt);
      this.closeDropdown();
    }
  },
  render: function render(h) {
    return h("li", {
      attrs: {
        role: "presentation"
      }
    }, [h(NlyLink, {
      props: this.$props,
      staticClass: "dropdown-item",
      class: [this.linkClass, Object(defineProperty["a" /* default */])({}, "text-".concat(this.variant), this.variant && !(this.active || this.disabled))],
      attrs: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.$attrs), {}, {
        role: "menuitem"
      }),
      on: {
        click: this.onClick
      },
      ref: "item"
    }, this.normalizeSlot("default"))]);
  }
});
// CONCATENATED MODULE: ./src/components/dropdown/dropdown-item-button.js




var dropdown_item_button_props = {
  active: {
    type: Boolean,
    default: false
  },
  activeClass: {
    type: String,
    default: "active"
  },
  buttonClass: {
    type: [String, Array, Object] // default: null

  },
  disabled: {
    type: Boolean,
    default: false
  },
  variant: {
    type: String // default: null

  }
};
var NlyDropdownItemButton = utils_vue.extend({
  name: "NlyDropdownItemButton",
  mixins: [mixins_normalize_slot],
  inheritAttrs: false,
  inject: {
    nlyaDropdown: {
      default: null
    }
  },
  props: dropdown_item_button_props,
  methods: {
    closeDropdown: function closeDropdown() {
      if (this.nlyaDropdown) {
        this.nlyaDropdown.hide(true);
      }
    },
    onClick: function onClick(evt) {
      this.$emit("click", evt);
      this.closeDropdown();
    }
  },
  render: function render(h) {
    var _ref;

    return h("li", {
      attrs: {
        role: "presentation"
      }
    }, [h("button", {
      staticClass: "dropdown-item",
      class: [this.buttonClass, (_ref = {}, Object(defineProperty["a" /* default */])(_ref, this.activeClass, this.active), Object(defineProperty["a" /* default */])(_ref, "text-".concat(this.variant), this.variant && !(this.active || this.disabled)), _ref)],
      attrs: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.$attrs), {}, {
        role: "menuitem",
        type: "button",
        disabled: this.disabled
      }),
      on: {
        click: this.onClick
      },
      ref: "button"
    }, this.normalizeSlot("default"))]);
  }
});
// CONCATENATED MODULE: ./src/components/dropdown/dropdown-header.js




var dropdown_header_props = {
  id: {
    type: String // default: null

  },
  tag: {
    type: String,
    default: "header"
  },
  variant: {
    type: String // default: null

  }
};
var NlyDropdownHeader = utils_vue.extend({
  name: "NlyDropdownHeader",
  functional: true,
  props: dropdown_header_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    var $attrs = data.attrs || {};
    data.attrs = {};
    return h("li", lib_esm_a(data, {
      attrs: {
        role: "presentation"
      }
    }), [h(props.tag, {
      staticClass: "dropdown-header",
      class: Object(defineProperty["a" /* default */])({}, "text-".concat(props.variant), props.variant),
      attrs: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, $attrs), {}, {
        id: props.id || null,
        role: "heading"
      }),
      ref: "header"
    }, children)]);
  }
});
// CONCATENATED MODULE: ./src/components/dropdown/dropdown-divider.js



var dropdown_divider_props = {
  tag: {
    type: String,
    default: "hr"
  }
};
var NlyDropdownDivider = utils_vue.extend({
  name: "NlyDropdownDivider",
  functional: true,
  props: dropdown_divider_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data;
    var $attrs = data.attrs || {};
    data.attrs = {};
    return h("li", lib_esm_a(data, {
      attrs: {
        role: "presentation"
      }
    }), [h(props.tag, {
      staticClass: "dropdown-divider",
      attrs: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, $attrs), {}, {
        role: "separator",
        "aria-orientation": "horizontal"
      }),
      ref: "divider"
    })]);
  }
});
// CONCATENATED MODULE: ./src/components/form/form.js


var form_props = {
  id: {
    type: String,
    default: null
  },
  inline: {
    type: Boolean,
    default: false
  },
  novalidate: {
    type: Boolean,
    default: false
  },
  validated: {
    type: Boolean,
    default: false
  },
  role: {
    type: String,
    default: "form"
  }
};
var form_name = "NlyForm";
var NlyForm = utils_vue.extend({
  name: form_name,
  functional: true,
  props: form_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h("form", lib_esm_a(data, {
      class: {
        "form-inline": props.inline,
        "was-validated": props.validated
      },
      attrs: {
        id: props.id,
        novalidate: props.novalidate,
        role: props.role
      }
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/dropdown/dropdown-form.js




var NlyDropdownForm = utils_vue.extend({
  name: "NlyDropdownForm",
  functional: true,
  props: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, form_props), {}, {
    disabled: {
      type: Boolean,
      default: false
    },
    formClass: {
      type: [String, Object, Array] // default: null

    }
  }),
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    var $attrs = data.attrs || {};
    var $listeners = data.on || {};
    data.attrs = {};
    data.on = {};
    return h("li", lib_esm_a(data, {
      attrs: {
        role: "presentation"
      }
    }), [h(NlyForm, {
      ref: "form",
      staticClass: "nly-dropdown-form",
      class: [props.formClass, {
        disabled: props.disabled
      }],
      props: props,
      attrs: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, $attrs), {}, {
        disabled: props.disabled,
        // Tab index of -1 for keyboard navigation
        tabindex: props.disabled ? null : "-1"
      }),
      on: $listeners
    }, children)]);
  }
});
// CONCATENATED MODULE: ./src/components/dropdown/dropdown-text.js



var NlyDropdownText = utils_vue.extend({
  name: "NlyDropdownText",
  functional: true,
  props: {
    tag: {
      type: String,
      default: "p"
    },
    variant: {
      type: String // default: null

    }
  },
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    var $attrs = data.attrs || {};
    data.attrs = {};
    return h("li", lib_esm_a(data, {
      attrs: {
        role: "presentation"
      }
    }), [h(props.tag, {
      staticClass: "nly-dropdown-text",
      class: Object(defineProperty["a" /* default */])({}, "text-".concat(props.variant), props.variant),
      props: props,
      attrs: $attrs,
      ref: "text"
    }, children)]);
  }
});
// CONCATENATED MODULE: ./src/components/dropdown/dropdown-group.js









var dropdown_group_props = {
  id: {
    type: String // default: null

  },
  header: {
    type: String // default: null

  },
  headerTag: {
    type: String,
    default: "header"
  },
  headerVariant: {
    type: String // default: null

  },
  headerClasses: {
    type: [String, Array, Object] // default: null

  },
  ariaDescribedby: {
    type: String // default: null

  }
}; // @vue/component

var NlyDropdownGroup = /*#__PURE__*/utils_vue.extend({
  name: "NlyDropdownGroup",
  functional: true,
  props: dropdown_group_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        slots = _ref.slots,
        scopedSlots = _ref.scopedSlots;
    var $slots = slots();
    var $scopedSlots = scopedSlots || {};
    var $attrs = data.attrs || {};
    data.attrs = {};
    var header;
    var headerId = null;

    if (normalize_slot_hasNormalizedSlot("header", $scopedSlots, $slots) || props.header) {
      headerId = props.id ? "_nly_".concat(props.id, "_group_dd_header") : null;
      header = h(props.headerTag, {
        staticClass: "dropdown-header",
        class: [props.headerClasses, Object(defineProperty["a" /* default */])({}, "text-".concat(props.variant), props.variant)],
        attrs: {
          id: headerId,
          role: "heading"
        }
      }, normalize_slot_normalizeSlot("header", {}, $scopedSlots, $slots) || props.header);
    }

    var adb = [headerId, props.ariaDescribedBy].filter(utils_identity).join(" ").trim();
    return h("li", lib_esm_a(data, {
      attrs: {
        role: "presentation"
      }
    }), [header || h(), h("ul", {
      staticClass: "list-unstyled",
      attrs: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, $attrs), {}, {
        id: props.id || null,
        role: "group",
        "aria-describedby": adb || null
      })
    }, normalize_slot_normalizeSlot("default", {}, $scopedSlots, $slots))]);
  }
});
// CONCATENATED MODULE: ./src/components/dropdown/dropdown-footer.js




var dropdown_footer_props = {
  id: {
    type: String // default: null

  },
  tag: {
    type: String,
    default: "header"
  },
  variant: {
    type: String // default: null

  }
};
var NlyDropdownFooter = utils_vue.extend({
  name: "NlyDropdownFooter",
  functional: true,
  props: dropdown_footer_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    var $attrs = data.attrs || {};
    data.attrs = {};
    return h("li", lib_esm_a(data, {
      attrs: {
        role: "presentation"
      }
    }), [h(props.tag, {
      staticClass: "dropdown-footer",
      class: Object(defineProperty["a" /* default */])({}, "text-".concat(props.variant), props.variant),
      attrs: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, $attrs), {}, {
        id: props.id || null,
        role: "footer"
      }),
      ref: "footer"
    }, children)]);
  }
});
// CONCATENATED MODULE: ./src/components/dropdown/index.js










var DropdownPlugin = plugins_nlyPluginFactory({
  components: {
    NlyDropdown: NlyDropdown,
    NlyDd: NlyDropdown,
    NlyDropdownItem: NlyDropdownItem,
    NlyDdItem: NlyDropdownItem,
    NlyDropdownItemButton: NlyDropdownItemButton,
    NlyDropdownItemBtn: NlyDropdownItemButton,
    NlyDdItemButton: NlyDropdownItemButton,
    NlyDdItemBtn: NlyDropdownItemButton,
    NlyDropdownHeader: NlyDropdownHeader,
    NlyDdHeader: NlyDropdownHeader,
    NlyDropdownDivider: NlyDropdownDivider,
    NlyDdDivider: NlyDropdownDivider,
    NlyDropdownForm: NlyDropdownForm,
    NlyDdForm: NlyDropdownForm,
    NlyDropdownText: NlyDropdownText,
    NlyDdText: NlyDropdownText,
    NlyDropdownGroup: NlyDropdownGroup,
    NlyDdGroup: NlyDropdownGroup,
    NlyDropdownFooter: NlyDropdownFooter,
    NlyDdFooter: NlyDropdownFooter
  }
});

// CONCATENATED MODULE: ./src/utils/loose-index-of.js


var loose_index_of_looseIndexOf = function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (loose_equal(arr[i], val)) {
      return i;
    }
  }

  return -1;
};

/* harmony default export */ var loose_index_of = (loose_index_of_looseIndexOf);
// CONCATENATED MODULE: ./src/mixins/form/form.js

var SELECTOR = "input, textarea, select";
/* harmony default export */ var form_form = ({
  props: {
    // form中可以通过name取值
    name: {
      type: String
    },
    // id
    id: {
      type: String
    },
    // 禁用
    disabled: {
      type: Boolean,
      default: false
    },
    // html校验必填
    required: {
      type: Boolean,
      default: false
    },
    // 指定归属表单
    form: {
      type: String,
      default: null
    },
    // 自动聚焦
    autofocus: {
      type: Boolean,
      default: false
    }
  },
  mounted: function mounted() {
    this.handleAutofocus();
  },
  // keep-alive才有的钩子
  activated: function activated() {
    this.handleAutofocus();
  },
  methods: {
    handleAutofocus: function handleAutofocus() {
      var _this = this;

      this.$nextTick(function () {
        requestAF(function () {
          var el = _this.$el;

          if (_this.autofocus && isVisible(el)) {
            if (!matches(el, SELECTOR)) {
              el = dom_select(SELECTOR, el);
            }

            el && el.focus && el.focus();
          }
        });
      });
    }
  }
});
// CONCATENATED MODULE: ./src/utils/cache.js



var cache_makePropWatcher = function makePropWatcher(propName) {
  return {
    handler: function handler(newVal, oldVal) {
      for (var key in oldVal) {
        if (!object_hasOwnProperty(newVal, key)) {
          this.$delete(this.$data[propName], key);
        }
      }

      for (var _key in newVal) {
        this.$set(this.$data[propName], _key, newVal[_key]);
      }
    }
  };
};
var cache_makePropCacheMixin = function makePropCacheMixin(propName, proxyPropName) {
  return {
    data: function data() {
      return Object(defineProperty["a" /* default */])({}, proxyPropName, {});
    },
    watch: Object(defineProperty["a" /* default */])({}, propName, cache_makePropWatcher(proxyPropName)),
    created: function created() {
      this[proxyPropName] = Object(objectSpread2["a" /* default */])({}, this[propName]);
    }
  };
};
// CONCATENATED MODULE: ./src/mixins/attrs.js

/* harmony default export */ var mixins_attrs = (cache_makePropCacheMixin("$attrs", "nlyaAttrs"));
// CONCATENATED MODULE: ./src/mixins/form/form-radio-check.js







/* harmony default export */ var form_radio_check = ({
  mixins: [mixins_attrs, mixins_normalize_slot],
  inheritAttrs: false,
  model: {
    prop: "checked",
    event: "input"
  },
  props: {
    value: {// Value when checked
      // type: Object,
      // default: undefined
    },
    checked: {// This is the v-model
      // type: Object,
      // default: undefined
    },
    inline: {
      type: Boolean,
      default: false
    },
    plain: {
      type: Boolean,
      default: false
    },
    button: {
      type: Boolean,
      default: false
    },
    buttonVariant: {
      type: String // default: null

    },
    ariaLabel: {
      type: String // default: null

    },
    ariaLabelledby: {
      type: String // default: null

    }
  },
  data: function data() {
    return {
      localChecked: this.isGroup ? this.nlyaGroup.checked : this.checked,
      hasFocus: false
    };
  },
  computed: {
    computedLocalChecked: {
      get: function get() {
        return this.isGroup ? this.nlyaGroup.localChecked : this.localChecked;
      },
      set: function set(val) {
        if (this.isGroup) {
          this.nlyaGroup.localChecked = val;
        } else {
          this.localChecked = val;
        }
      }
    },
    isGroup: function isGroup() {
      return Boolean(this.nlyaGroup);
    },
    isBtnMode: function isBtnMode() {
      return this.isGroup ? this.nlyaGroup.buttons : this.button;
    },
    isPlain: function isPlain() {
      return this.isBtnMode ? false : this.isGroup ? this.nlyaGroup.plain : this.plain;
    },
    isCustom: function isCustom() {
      return this.isBtnMode ? false : !this.isPlain;
    },
    isSwitch: function isSwitch() {
      return this.isBtnMode || this.isRadio || this.isPlain ? false : this.isGroup ? this.nlyaGroup.switches : this.switch;
    },
    isInline: function isInline() {
      return this.isGroup ? this.nlyaGroup.inline : this.inline;
    },
    isDisabled: function isDisabled() {
      return this.isGroup ? this.nlyaGroup.disabled || this.disabled : this.disabled;
    },
    isRequired: function isRequired() {
      return this.getName && (this.isGroup ? this.nlyaGroup.required : this.required);
    },
    getName: function getName() {
      return (this.isGroup ? this.nlyaGroup.groupName : this.name) || null;
    },
    getForm: function getForm() {
      return (this.isGroup ? this.nlyaGroup.form : this.form) || null;
    },
    getSize: function getSize() {
      return (this.isGroup ? this.nlyaGroup.size : this.size) || "";
    },
    getState: function getState() {
      return this.isGroup ? this.nlyaGroup.computedValid : this.computedValid;
    },
    getButtonVariant: function getButtonVariant() {
      if (this.buttonVariant) {
        return this.buttonVariant;
      } else if (this.isGroup && this.nlyaGroup.buttonVariant) {
        return this.nlyaGroup.buttonVariant;
      }

      return "secondary";
    },
    buttonClasses: function buttonClasses() {
      var _ref;

      return ["btn", "btn-".concat(this.getButtonVariant), (_ref = {}, Object(defineProperty["a" /* default */])(_ref, "btn-".concat(this.getSize), this.getSize), Object(defineProperty["a" /* default */])(_ref, "disabled", this.isDisabled), Object(defineProperty["a" /* default */])(_ref, "active", this.isChecked), Object(defineProperty["a" /* default */])(_ref, "focus", this.hasFocus), _ref)];
    },
    computedAttrs: function computedAttrs() {
      return Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.nlyaAttrs), {}, {
        id: this.safeId(),
        type: this.isRadio ? "radio" : "checkbox",
        name: this.getName,
        form: this.getForm,
        disabled: this.isDisabled,
        required: this.isRequired,
        "aria-required": this.isRequired || null,
        "aria-label": this.ariaLabel || null,
        "aria-labelledby": this.ariaLabelledby || null
      });
    }
  },
  watch: {
    checked: function checked(newValue) {
      if (!loose_equal(newValue, this.computedLocalChecked)) {
        this.computedLocalChecked = newValue;
      }
    }
  },
  methods: {
    handleFocus: function handleFocus(evt) {
      if (evt.target) {
        if (evt.type === "focus") {
          this.hasFocus = true;
        } else if (evt.type === "blur") {
          this.hasFocus = false;
        }
      }
    },
    focus: function focus() {
      if (!this.isDisabled) {
        dom_attemptFocus(this.$refs.input);
      }
    },
    blur: function blur() {
      if (!this.isDisabled) {
        attemptBlur(this.$refs.input);
      }
    }
  },
  render: function render(h) {
    var defaultSlot = this.normalizeSlot("default");
    var on = {
      change: this.handleChange
    };

    if (this.isBtnMode) {
      on.focus = on.blur = this.handleFocus;
    }

    var input = h("input", {
      ref: "input",
      key: "input",
      on: on,
      class: {
        "form-check-input": this.isPlain,
        "custom-control-input": this.isCustom,
        "is-valid": this.getState === "valid" && !this.isBtnMode,
        "is-invalid": this.getState === "invalid" && !this.isBtnMode,
        "is-warning": this.getState === "warning" && !this.isBtnMode,
        "position-static": this.isPlain && !defaultSlot
      },
      directives: [{
        name: "model",
        rawName: "v-model",
        value: this.computedLocalChecked,
        expression: "computedLocalChecked"
      }],
      attrs: this.computedAttrs,
      domProps: {
        value: this.value,
        checked: this.isChecked
      }
    });

    if (this.isBtnMode) {
      var button = h("label", {
        class: this.buttonClasses
      }, [input, defaultSlot]);

      if (!this.isGroup) {
        button = h("div", {
          class: ["btn-group-toggle", "d-inline-block"]
        }, [button]);
      }

      return button;
    } else {
      var label = h();

      if (!(this.isPlain && !defaultSlot)) {
        label = h("label", {
          class: {
            "form-check-label": this.isPlain,
            "custom-control-label": this.isCustom
          },
          attrs: {
            for: this.safeId()
          }
        }, defaultSlot);
      }

      return h("div", {
        class: Object(defineProperty["a" /* default */])({
          "form-check": this.isPlain,
          "form-check-inline": this.isPlain && this.isInline,
          "custom-control": this.isCustom,
          "custom-control-inline": this.isCustom && this.isInline,
          "custom-checkbox": this.isCustom && this.isCheck && !this.isSwitch,
          "custom-switch": this.isSwitch,
          "custom-radio": this.isCustom && this.isRadio
        }, "nly-custom-control-".concat(this.getSize), Boolean(this.getSize && !this.isBtnMode))
      }, [input, label]);
    }
  }
});
// CONCATENATED MODULE: ./src/mixins/form/form-size.js

/* harmony default export */ var form_size = ({
  props: {
    // 大小 sm,lg
    size: {
      type: String
    },
    col: {
      type: Boolean,
      default: false
    },
    xs: {
      type: [String, Number]
    },
    sm: {
      type: [String, Number]
    },
    md: {
      type: [String, Number]
    },
    lg: {
      type: [String, Number]
    },
    xl: {
      type: [String, Number]
    },
    offsetXs: {
      type: [String, Number]
    },
    offsetSm: {
      type: [String, Number]
    },
    offsetMd: {
      type: [String, Number]
    },
    offsetLg: {
      type: [String, Number]
    },
    offsetXl: {
      type: [String, Number]
    },
    orderXs: {
      type: [String, Number]
    },
    orderSm: {
      type: [String, Number]
    },
    orderMd: {
      type: [String, Number]
    },
    orderLg: {
      type: [String, Number]
    },
    orderXl: {
      type: [String, Number]
    }
  },
  computed: {
    sizeFormClass: function sizeFormClass() {
      return [this.size ? "form-control-".concat(this.size) : null];
    },
    sizeBtnClass: function sizeBtnClass() {
      return [this.size ? "btn-".concat(this.size) : null];
    },
    customCol: function customCol() {
      return this.xs || this.sm || this.md || this.lg || this.xl ? null : this.col ? "col" : null;
    },
    customXs: function customXs() {
      return this.xs ? "col-".concat(this.xs) : null;
    },
    customSm: function customSm() {
      return this.sm ? "col-sm-".concat(this.sm) : null;
    },
    customMd: function customMd() {
      return this.md ? "col-md-".concat(this.md) : null;
    },
    customLg: function customLg() {
      return this.lg ? "col-lg-".concat(this.lg) : null;
    },
    customXl: function customXl() {
      return this.xl ? "col-xl-".concat(this.xl) : null;
    },
    customOffsetXs: function customOffsetXs() {
      return this.offsetXs === 0 || this.offsetXs ? "offset-".concat(this.offsetXs) : null;
    },
    customOffsetSm: function customOffsetSm() {
      return this.offsetSm === 0 || this.offsetSm ? "offset-sm-".concat(this.offsetSm) : null;
    },
    customOffsetMd: function customOffsetMd() {
      return this.offsetMd === 0 || this.offsetMd ? "offset-md-".concat(this.offsetMd) : null;
    },
    customOffsetLg: function customOffsetLg() {
      return this.offsetLg === 0 || this.offsetLg ? "offset-lg-".concat(this.offsetLg) : null;
    },
    customOffsetXl: function customOffsetXl() {
      return this.offsetXl === 0 || this.offsetXl ? "offset-xl-".concat(this.offsetXl) : null;
    },
    customOrderXs: function customOrderXs() {
      return this.orderXs === 0 || this.orderXs ? "order-".concat(this.orderXs) : null;
    },
    customOrderSm: function customOrderSm() {
      return this.orderSm === 0 || this.orderSm ? "order-sm-".concat(this.orderSm) : null;
    },
    customOrderMd: function customOrderMd() {
      return this.orderMd === 0 || this.orderMd ? "order-md-".concat(this.orderMd) : null;
    },
    customOrderLg: function customOrderLg() {
      return this.orderLg === 0 || this.orderLg ? "order-lg-".concat(this.orderLg) : null;
    },
    customOrderXl: function customOrderXl() {
      return this.orderXl === 0 || this.orderXl ? "order-xl-".concat(this.orderXl) : null;
    }
  }
});
// CONCATENATED MODULE: ./src/mixins/form/form-valid.js


/* harmony default export */ var form_valid = ({
  props: {
    valid: {
      type: String,
      validator: function validator(valid) {
        return nlyGetOptionInclusion(formValidOptions, valid);
      }
    }
  },
  computed: {
    computedValid: function computedValid() {
      return this.valid;
    },
    validClass: function validClass() {
      var valid = this.computedValid;
      return valid === "valid" ? "is-valid" : valid === "invalid" ? "is-invalid" : valid === "warning" ? "is-warning" : valid === "loading" ? "is-loading" : null;
    }
  }
});
// CONCATENATED MODULE: ./src/components/form-checkbox/form-checkbox.js











var form_checkbox_name = "NlyFormCheckbox";
var NlyFormCheckbox = utils_vue.extend({
  name: form_checkbox_name,
  mixins: [form_radio_check, // Includes shared render function
  mixins_id, form_form, form_size, form_valid],
  inject: {
    nlyaGroup: {
      from: "nlyaCheckGroup",
      default: false
    }
  },
  props: {
    value: {
      // type: [String, Number, Boolean, Object],
      default: true
    },
    uncheckedValue: {
      // type: [String, Number, Boolean, Object],
      default: false
    },
    indeterminate: {
      type: Boolean,
      default: false
    },
    switch: {
      // Custom switch styling
      type: Boolean,
      default: false
    },
    checked: {
      // v-model (Array when multiple checkboxes have same name)
      // type: [String, Number, Boolean, Object, Array],
      default: null
    }
  },
  computed: {
    isChecked: function isChecked() {
      var value = this.value,
          checked = this.computedLocalChecked;
      return isArray(checked) ? loose_index_of(checked, value) > -1 : loose_equal(checked, value);
    },
    isRadio: function isRadio() {
      return false;
    },
    isCheck: function isCheck() {
      return true;
    }
  },
  watch: {
    computedLocalChecked: function computedLocalChecked(newValue, oldValue) {
      if (!loose_equal(newValue, oldValue)) {
        this.$emit("input", newValue);
        var $input = this.$refs.input;

        if ($input) {
          this.$emit("update:indeterminate", $input.indeterminate);
        }
      }
    },
    indeterminate: function indeterminate(newVal) {
      this.setIndeterminate(newVal);
    }
  },
  mounted: function mounted() {
    this.setIndeterminate(this.indeterminate);
  },
  methods: {
    handleChange: function handleChange(_ref) {
      var _ref$target = _ref.target,
          checked = _ref$target.checked,
          indeterminate = _ref$target.indeterminate;
      var value = this.value,
          uncheckedValue = this.uncheckedValue;
      var localChecked = this.computedLocalChecked;

      if (isArray(localChecked)) {
        var index = loose_index_of(localChecked, value);

        if (checked && index < 0) {
          localChecked = localChecked.concat(value);
        } else if (!checked && index > -1) {
          localChecked = localChecked.slice(0, index).concat(localChecked.slice(index + 1));
        }
      } else {
        localChecked = checked ? value : uncheckedValue;
      }

      this.computedLocalChecked = localChecked;
      this.$emit("change", localChecked);

      if (this.isGroup) {
        this.nlyaGroup.$emit("change", localChecked);
      }

      this.$emit("update:indeterminate", indeterminate);
    },
    setIndeterminate: function setIndeterminate(state) {
      if (isArray(this.computedLocalChecked)) {
        state = false;
      }

      var $input = this.$refs.input;

      if ($input) {
        $input.indeterminate = state;
        this.$emit("update:indeterminate", state);
      }
    }
  }
});
// CONCATENATED MODULE: ./src/mixins/form/form-options.js







var OPTIONS_OBJECT_DEPRECATED_MSG = 'Setting prop "options" to an object is deprecated. Use the array format instead.'; // @vue/component

/* harmony default export */ var form_options = ({
  props: {
    options: {
      type: [Array, Object],
      default: function _default() {
        return [];
      }
    },
    valueField: {
      type: String,
      default: "value"
    },
    textField: {
      type: String,
      default: "text"
    },
    htmlField: {
      type: String,
      default: "html"
    },
    disabledField: {
      type: String,
      default: "disabled"
    }
  },
  computed: {
    formOptions: function formOptions() {
      return this.normalizeOptions(this.options);
    }
  },
  methods: {
    normalizeOption: function normalizeOption(option) {
      var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      // When the option is an object, normalize it
      if (isPlainObject(option)) {
        var value = utils_get(option, this.valueField);
        var text = utils_get(option, this.textField);
        return {
          value: isUndefined(value) ? key || text : value,
          text: stripTags(String(isUndefined(text) ? key : text)),
          html: utils_get(option, this.htmlField),
          disabled: Boolean(utils_get(option, this.disabledField))
        };
      } // Otherwise create an `<option>` object from the given value


      return {
        value: key || option,
        text: stripTags(String(option)),
        disabled: false
      };
    },
    normalizeOptions: function normalizeOptions(options) {
      var _this = this;

      // Normalize the given options array
      if (isArray(options)) {
        return options.map(function (option) {
          return _this.normalizeOption(option);
        });
      } else if (isPlainObject(options)) {
        // Deprecate the object options format
        warn_warn(OPTIONS_OBJECT_DEPRECATED_MSG, this.$options.name); // Normalize a `options` object to an array of options

        return keys(options).map(function (key) {
          return _this.normalizeOption(options[key] || {}, key);
        });
      } // If not an array or object, return an empty array

      /* istanbul ignore next */


      return [];
    }
  }
});
// CONCATENATED MODULE: ./src/components/form-radio/form-radio.js







var form_radio_name = "NlyFormRadio";
var NlyFormRadio = utils_vue.extend({
  name: form_radio_name,
  mixins: [mixins_id, form_radio_check, // Includes shared render function
  form_form, form_size, form_valid],
  inject: {
    nlyaGroup: {
      from: "nlyaRadioGroup",
      default: false
    }
  },
  props: {
    checked: {
      // v-model
      // type: [String, Number, Boolean, Object],
      default: null
    }
  },
  computed: {
    isChecked: function isChecked() {
      return loose_equal(this.value, this.computedLocalChecked);
    },
    // Flags for form-radio-check mixin
    isRadio: function isRadio() {
      return true;
    },
    isCheck: function isCheck() {
      return false;
    }
  },
  watch: {
    computedLocalChecked: function computedLocalChecked() {
      this.$emit("input", this.computedLocalChecked);
    }
  },
  methods: {
    handleChange: function handleChange(_ref) {
      var checked = _ref.target.checked;
      var value = this.value;
      this.computedLocalChecked = value;
      this.$emit("change", checked ? value : null);

      if (this.isGroup) {
        this.nlyaGroup.$emit("change", checked ? value : null);
      }
    }
  }
});
// CONCATENATED MODULE: ./src/mixins/form/form-radio-check-group.js







/* harmony default export */ var form_radio_check_group = ({
  mixins: [mixins_normalize_slot],
  model: {
    prop: "checked",
    event: "input"
  },
  props: {
    validated: {
      type: Boolean,
      default: false
    },
    ariaInvalid: {
      type: [Boolean, String],
      default: false
    },
    stacked: {
      type: Boolean,
      default: false
    },
    plain: {
      type: Boolean,
      default: false
    },
    buttons: {
      // Render as button style
      type: Boolean,
      default: false
    },
    buttonVariant: {
      // Only applicable when rendered with button style
      type: String,
      default: "secondary"
    }
  },
  computed: {
    inline: function inline() {
      return !this.stacked;
    },
    groupName: function groupName() {
      // Checks/Radios tied to the same model must have the same name,
      // especially for ARIA accessibility.
      return this.name || this.safeId();
    },
    groupClasses: function groupClasses() {
      if (this.buttons) {
        return ["btn-group-toggle", this.inline ? "btn-group" : "btn-group-vertical", this.size ? "btn-group-".concat(this.size) : "", this.validated ? "was-validated" : ""];
      }

      return [this.validated ? "was-validated" : ""];
    },
    computedAriaInvalid: function computedAriaInvalid() {
      var ariaInvalid = this.ariaInvalid;

      if (ariaInvalid === true || ariaInvalid === "true" || ariaInvalid === "") {
        return "true";
      }

      return this.computedValid !== "novalid" ? "true" : null;
    }
  },
  watch: {
    checked: function checked(newVal) {
      if (!loose_equal(newVal, this.localChecked)) {
        this.localChecked = newVal;
      }
    },
    localChecked: function localChecked(newValue, oldValue) {
      if (!loose_equal(newValue, oldValue)) {
        this.$emit("input", newValue);
      }
    }
  },
  render: function render(h) {
    var _this = this;

    var $inputs = this.formOptions.map(function (option, index) {
      var key = "NLYA_option_".concat(index);
      return h(_this.isRadioGroup ? NlyFormRadio : NlyFormCheckbox, {
        props: {
          id: _this.safeId(key),
          value: option.value,
          disabled: option.disabled || false
        },
        key: key
      }, [h("span", {
        domProps: htmlOrText(option.html, option.text)
      })]);
    });
    return h("div", {
      class: [this.groupClasses, "nly-no-focus-ring"],
      attrs: {
        id: this.safeId(),
        role: this.isRadioGroup ? "radiogroup" : "group",
        // Add `tabindex="-1"` to allow group to be focused if needed by screen readers
        tabindex: "-1",
        "aria-required": this.required ? "true" : null,
        "aria-invalid": this.computedAriaInvalid
      }
    }, [this.normalizeSlot("first"), $inputs, this.normalizeSlot("default")]);
  }
});
// CONCATENATED MODULE: ./src/components/form-checkbox/form-checkbox-group.js







var form_checkbox_group_props = {
  switches: {
    type: Boolean,
    default: false
  },
  checked: {
    type: Array,
    default: null
  }
};
var form_checkbox_group_name = "NlyFormCheckboxGroup";
var NlyFormCheckboxGroup = utils_vue.extend({
  name: form_checkbox_group_name,
  mixins: [mixins_id, form_form, form_radio_check_group, // Includes render function
  form_options, form_size, form_valid],
  provide: function provide() {
    return {
      nlyaCheckGroup: this
    };
  },
  props: form_checkbox_group_props,
  data: function data() {
    return {
      localChecked: this.checked || []
    };
  },
  computed: {
    isRadioGroup: function isRadioGroup() {
      return false;
    }
  }
});
// CONCATENATED MODULE: ./src/components/form-checkbox/index.js



var FormCheckboxPlugin = /*#__PURE__*/plugins_nlyPluginFactory({
  components: {
    NlyFormCheckbox: NlyFormCheckbox,
    NlyCheckbox: NlyFormCheckbox,
    NlyCheck: NlyFormCheckbox,
    NlyFormCheckboxGroup: NlyFormCheckboxGroup,
    BCheckboxGroup: NlyFormCheckboxGroup,
    NlyCheckGroup: NlyFormCheckboxGroup
  }
});

// EXTERNAL MODULE: ./src/utils/daterange-picker/util.js
var daterange_picker_util = __webpack_require__("27b0");

// CONCATENATED MODULE: ./src/mixins/date-util.js

/* harmony default export */ var date_util = ({
  props: {
    dateUtil: {
      type: [Object, String],
      default: "native"
    }
  },
  created: function created() {
    this.$dateUtil = Object(daterange_picker_util["getDateUtil"])("native");
  }
});
// CONCATENATED MODULE: ./src/components/form-daterangepicker/pulgin/calendar.js







var calendar_name = "NlyCalendar";
var NlyCalendar = utils_vue.extend({
  name: calendar_name,
  mixins: [date_util],
  props: {
    monthDate: Date,
    localeData: Object,
    start: Date,
    end: Date,
    minDate: Date,
    maxDate: Date,
    showDropdowns: {
      type: Boolean,
      default: false
    },
    showWeekNumbers: {
      type: Boolean,
      default: false
    },
    dateFormat: {
      type: Function,
      default: null
    }
  },
  data: function data() {
    var currentMonthDate = this.monthDate || this.start || new Date();
    return {
      currentMonthDate: currentMonthDate,
      year_text: currentMonthDate.getFullYear()
    };
  },
  methods: {
    onChange: function onChange(evt) {
      this.month = evt.target.value;
    },
    onInput: function onInput(evt) {
      this.year = evt.target.value;
    },
    prevMonthClick: function prevMonthClick() {
      this.changeMonthDate(this.$dateUtil.prevMonth(this.currentMonthDate));
    },
    nextMonthClick: function nextMonthClick() {
      this.changeMonthDate(this.$dateUtil.nextMonth(this.currentMonthDate));
    },
    changeMonthDate: function changeMonthDate(date) {
      var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var year_month = this.$dateUtil.yearMonth(this.currentMonthDate);
      this.currentMonthDate = this.$dateUtil.validateDateRange(date, this.minDate, this.maxDate);

      if (emit && year_month !== this.$dateUtil.yearMonth(this.currentMonthDate)) {
        this.$emit("change-month", {
          month: this.currentMonthDate.getMonth() + 1,
          year: this.currentMonthDate.getFullYear()
        });
      }

      this.checkYear();
    },
    dayClass: function dayClass(date) {
      var dt = new Date(date);
      dt.setHours(0, 0, 0, 0);
      var start = new Date(this.start);
      start.setHours(0, 0, 0, 0);
      var end = new Date(this.end);
      end.setHours(0, 0, 0, 0);
      var classes = {
        off: date.getMonth() + 1 !== this.month,
        weekend: date.getDay() === 6 || date.getDay() === 0,
        today: dt.setHours(0, 0, 0, 0) == new Date().setHours(0, 0, 0, 0),
        active: dt.setHours(0, 0, 0, 0) == new Date(this.start).setHours(0, 0, 0, 0) || dt.setHours(0, 0, 0, 0) == new Date(this.end).setHours(0, 0, 0, 0),
        "in-range": dt >= start && dt <= end,
        "start-date": dt.getTime() === start.getTime(),
        "end-date": dt.getTime() === end.getTime(),
        disabled: this.minDate && dt.getTime() < this.minDate.getTime() || this.maxDate && dt.getTime() > this.maxDate.getTime()
      };
      return this.dateFormat ? this.dateFormat(classes, date) : classes;
    },
    checkYear: function checkYear() {
      var _this = this;

      if (this.$refs.yearSelect !== document.activeElement) {
        this.$nextTick(function () {
          _this.year_text = _this.monthDate.getFullYear();
        });
      }
    }
  },
  computed: {
    monthName: function monthName() {
      return this.locale.monthNames[this.currentMonthDate.getMonth()];
    },
    year: {
      get: function get() {
        //return this.currentMonthDate.getFullYear()
        return this.year_text;
      },
      set: function set(value) {
        this.year_text = value;
        var newDate = this.$dateUtil.validateDateRange(new Date(value, this.month, 1), this.minDate, this.maxDate);

        if (this.$dateUtil.isValidDate(newDate)) {
          this.$emit("change-month", {
            month: newDate.getMonth(),
            year: newDate.getFullYear()
          });
        }
      }
    },
    month: {
      get: function get() {
        return this.currentMonthDate.getMonth() + 1;
      },
      set: function set(value) {
        var newDate = this.$dateUtil.validateDateRange(new Date(this.year, value - 1, 1), this.minDate, this.maxDate);
        this.$emit("change-month", {
          month: newDate.getMonth() + 1,
          year: newDate.getFullYear()
        });
      }
    },
    calendar: function calendar() {
      var month = this.month;
      var year = this.currentMonthDate.getFullYear();
      var firstDay = new Date(year, month - 1, 1);
      var lastMonth = this.$dateUtil.prevMonth(firstDay).getMonth() + 1;
      var lastYear = this.$dateUtil.prevMonth(firstDay).getFullYear();
      var daysInLastMonth = new Date(lastYear, month - 1, 0).getDate();
      var dayOfWeek = firstDay.getDay();
      var calendar = [];

      for (var i = 0; i < 6; i++) {
        calendar[i] = [];
      }

      var startDay = daysInLastMonth - dayOfWeek + this.locale.firstDay + 1;
      if (startDay > daysInLastMonth) startDay -= 7;
      if (dayOfWeek === this.locale.firstDay) startDay = daysInLastMonth - 6;
      var curDate = new Date(lastYear, lastMonth - 1, startDay, 12, 0, 0);

      for (var _i = 0, col = 0, row = 0; _i < 6 * 7; _i++, col++, curDate.setDate(curDate.getDate() + 1)) {
        if (_i > 0 && col % 7 === 0) {
          col = 0;
          row++;
        }

        calendar[row][col] = new Date(curDate.getTime());
      }

      return calendar;
    },
    months: function months() {
      var monthsData = this.locale.monthNames.map(function (m, idx) {
        return {
          label: m,
          value: idx
        };
      });

      if (this.maxDate && this.minDate) {
        var y = this.maxDate.getFullYear() - this.minDate.getFullYear();

        if (y < 2) {
          // get months
          var months = [];

          if (y < 1) {
            for (var i = this.minDate.getMonth(); i <= this.maxDate.getMonth(); i++) {
              months.push(i);
            }
          } else {
            for (var _i2 = 0; _i2 <= this.maxDate.getMonth(); _i2++) {
              months.push(_i2);
            }

            for (var _i3 = this.minDate.getMonth(); _i3 < 12; _i3++) {
              months.push(_i3);
            }
          } // do filter


          if (months.length > 0) {
            return monthsData.filter(function (m) {
              return months.find(function (i) {
                return m.value === i;
              }) > -1;
            });
          }
        }
      }

      return monthsData;
    },
    locale: function locale() {
      return this.$dateUtil.localeData(this.localeData);
    }
  },
  watch: {
    monthDate: function monthDate(value) {
      if (this.currentMonthDate.getTime() !== value.getTime()) {
        this.changeMonthDate(value, false);
      }
    }
  },
  render: function render(h) {
    var _this2 = this;

    var self = this;
    var monthselectOptinos = [];
    this.months.forEach(function (element) {
      monthselectOptinos.push(h("option", {
        key: element.value,
        domProps: {
          value: element.value + 1
        }
      }, element.label));
    });
    var monthselect = h("select", {
      class: "monthselect col",
      domProps: {
        value: this.month
      },
      on: {
        change: this.onChange
      }
    }, monthselectOptinos);

    var thead = function thead() {
      if (_this2.showDropdowns) {
        return h("thead", [h("tr", [h("th", {
          class: "nly-datarange-calendar-prev available nly-datarange-calendar-th",
          on: {
            click: _this2.prevMonthClick
          },
          attrs: {
            tabindex: 0
          }
        }, [h("span")]), h("th", {
          class: "month nly-datarange-calendar-th",
          attrs: {
            colspan: self.showWeekNumbers ? 6 : 5
          }
        }, [h("div", {
          class: "row mx-1"
        }, [monthselect, h("input", {
          class: "yearselect col",
          ref: "yearSelect",
          attrs: {
            type: "number"
          },
          on: {
            // ...self.$listeners,
            blur: self.checkYear,
            input: self.onInput
          },
          directives: [{
            name: "model",
            rawName: "v-model",
            value: self.year,
            expression: "value"
          }],
          domProps: {
            value: self.year
          }
        }), self.year])]), h("th", {
          class: "nly-datarange-calendar-next available nly-datarange-calendar-th",
          on: {
            click: _this2.nextMonthClick
          },
          attrs: {
            tabindex: 0
          }
        }, [h("span")])])]);
      } else {
        return h("thead", [h("tr", [h("th", {
          class: "nly-datarange-calendar-prev available nly-datarange-calendar-th",
          on: {
            click: _this2.prevMonthClick
          },
          attrs: {
            tabindex: 0
          }
        }, [h("span")]), h("th", {
          class: "month nly-datarange-calendar-th",
          attrs: {
            colspan: self.showWeekNumbers ? 6 : 5
          }
        }, [_this2.monthName, "  ", _this2.year]), h("th", {
          class: "nly-datarange-calendar-next available nly-datarange-calendar-th",
          on: {
            click: _this2.nextMonthClick
          },
          attrs: {
            tabindex: 0
          }
        }, [h("span")])])]);
      }
    };

    var tbodyWeekDayTrVnodes = [];

    if (this.showWeekNumbers) {
      tbodyWeekDayTrVnodes.push(h("th", {
        class: "week nly-datarange-calendar-th"
      }, this.locale.weekLabel));
    }

    this.locale.daysOfWeek.forEach(function (item) {
      tbodyWeekDayTrVnodes.push(h("th", {
        key: item,
        class: "nly-datarange-calendar-th"
      }, item));
    });
    var tbodyWeekDayTr = h("tr", tbodyWeekDayTrVnodes);
    var tobody = [tbodyWeekDayTr];
    this.calendar.forEach(function (item, index) {
      var tobodyDateRowVnodes = [];

      if (_this2.showWeekNumbers && (index % 7 || index === 0)) {
        tobodyDateRowVnodes.push(h("td", {
          class: "week nly-datarange-calendar-td"
        }, _this2.$dateUtil.weekNumber(item[0])));
      }

      item.forEach(function (childItem, childIndex) {
        tobodyDateRowVnodes.push(h("td", {
          class: _this2.dayClass(childItem),
          staticClass: "nly-datarange-calendar-td",
          on: {
            click: function click() {
              _this2.$emit("dateClick", childItem);
            },
            mouseover: function mouseover() {
              _this2.$emit("hoverDate", childItem);
            }
          },
          key: childIndex
        }, childItem.getDate()));
      });
      tobody.push(h("tr", {
        key: index
      }, tobodyDateRowVnodes));
    });
    return h("table", {
      class: "table-condensed"
    }, [thead(), tobody]);
  }
});
// CONCATENATED MODULE: ./src/components/form-daterangepicker/pulgin/calendar-time.js





var calendar_time_name = "NlyCalendarTime";
var NlyCalendarTime = utils_vue.extend({
  name: calendar_time_name,
  filters: {
    formatNumber: function formatNumber(value) {
      if (value < 10) {
        return "0" + value.toString();
      }

      return value.toString();
    }
  },
  props: {
    miniuteIncrement: {
      type: Number,
      default: 5
    },
    hour24: {
      type: Boolean,
      default: true
    },
    secondPicker: {
      type: Boolean,
      default: false
    },
    currentTime: {
      default: function _default() {
        return new Date();
      }
    },
    readonly: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    var current = this.currentTime ? this.currentTime : new Date();
    var hours = current.getHours();
    return {
      hour: this.hour24 ? hours : hours % 12 || 12,
      minute: current.getMinutes() - current.getMinutes() % this.miniuteIncrement,
      second: current.getSeconds(),
      ampm: hours < 12 ? "AM" : "PM"
    };
  },
  computed: {
    hours: function hours() {
      var values = [];
      var max = this.hour24 ? 24 : 12;

      for (var i = 0; i < max; i++) {
        values.push(this.hour24 ? i : i + 1);
      }

      return values;
    },
    minutes: function minutes() {
      var values = [];
      var max = 60;

      for (var i = 0; i < max; i = i + this.miniuteIncrement) {
        values.push(i);
      }

      return values;
    }
  },
  watch: {
    hour: function hour() {
      this.onChange();
    },
    minute: function minute() {
      this.onChange();
    },
    second: function second() {
      this.onChange();
    },
    ampm: function ampm() {
      this.onChange();
    }
  },
  methods: {
    hourOnChange: function hourOnChange(evt) {
      this.hour = evt.target.value;
    },
    minuteOnChange: function minuteOnChange(evt) {
      this.minute = evt.target.value;
    },
    secondOnChange: function secondOnChange(evt) {
      this.second = evt.target.value;
    },
    ampmOnChange: function ampmOnChange(evt) {
      this.ampm = evt.target.value;
    },
    getHour: function getHour() {
      if (this.hour24) {
        return this.hour;
      } else {
        if (this.hour === 12) {
          return this.ampm === "AM" ? 0 : 12;
        } else {
          return this.hour + (this.ampm === "PM" ? 12 : 0);
        }
      }
    },
    onChange: function onChange() {
      this.$emit("update", {
        hours: this.getHour(),
        minutes: this.minute,
        seconds: this.second
      });
    }
  },
  render: function render(h) {
    var _this = this;

    var hourselectVnodes = function hourselectVnodes() {
      var hourselectOptionsVnodes = _this.hours.map(function (item) {
        return h("option", {
          key: item,
          domProps: {
            value: item
          }
        }, item | _this.formatNumber);
      });

      return h("select", {
        class: "hourselect form-control mr-1",
        attrs: {
          disabled: _this.readonly
        },
        domProps: {
          value: _this.hour
        },
        on: {
          change: _this.hourOnChange
        }
      }, hourselectOptionsVnodes);
    };

    var minuteselectVnodes = function minuteselectVnodes() {
      var minuteselectOptionsVnodes = _this.minutes.map(function (item) {
        return h("option", {
          key: item,
          domProps: {
            value: item
          }
        }, item | _this.formatNumber);
      });

      return h("select", {
        class: "minuteselect form-control ml-1",
        attrs: {
          disabled: _this.readonly
        },
        domProps: {
          value: _this.minute
        },
        on: {
          change: _this.minuteOnChange
        }
      }, minuteselectOptionsVnodes);
    };

    var secondPickerVnodes = function secondPickerVnodes() {
      var secondPickerOptionsVnodes = [];

      for (var i = 1; i < 60; i++) {
        secondPickerOptionsVnodes.push(h("option", {
          key: i - 1,
          domProps: {
            value: i - 1
          }
        }, i - 1 | _this.formatNumber));
      }

      return h("select", {
        class: "secondselect form-control ml-1",
        attrs: {
          disabled: _this.readonly
        },
        domProps: {
          value: _this.second
        },
        on: {
          change: _this.secondOnChange
        }
      }, secondPickerOptionsVnodes);
    };

    var ampmselectVnodes = function ampmselectVnodes() {
      return h("select", {
        class: "ampmselect",
        attrs: {
          disabled: _this.readonly
        },
        domProps: {
          value: _this.ampm
        },
        on: {
          change: _this.ampmOnChange
        }
      }, [h("option", {
        domProps: {
          value: _this.AM
        }
      }, "AM"), h("option", {
        domProps: {
          value: _this.PM
        }
      }, "PM")]);
    };

    var renderVnodes = function renderVnodes() {
      if (_this.secondPicker) {
        if (!_this.hour24) {
          return h("div", {
            class: "calendar-time"
          }, [hourselectVnodes(), ":", minuteselectVnodes(), ":", secondPickerVnodes(), ampmselectVnodes()]);
        } else {
          return h("div", {
            class: "calendar-time"
          }, [hourselectVnodes(), ":", minuteselectVnodes(), ":", secondPickerVnodes()]);
        }
      } else {
        if (!_this.hour24) {
          return h("div", {
            class: "calendar-time"
          }, [hourselectVnodes(), ":", minuteselectVnodes(), ampmselectVnodes()]);
        } else {
          return h("div", {
            class: "calendar-time"
          }, [hourselectVnodes(), ":", minuteselectVnodes()]);
        }
      }
    };

    return renderVnodes();
  }
});
// CONCATENATED MODULE: ./src/components/form-daterangepicker/pulgin/calendar-rangs.js







var calendar_rangs_name = "NlyCalendarRangs";
var NlyCalendarRangs = utils_vue.extend({
  name: calendar_rangs_name,
  mixins: [date_util],
  props: {
    ranges: Object,
    selected: Object,
    localeData: Object,
    alwaysShowCalendars: Boolean
  },
  data: function data() {
    return {
      customRangeActive: false
    };
  },
  methods: {
    clickRange: function clickRange(range) {
      this.customRangeActive = false;
      this.$emit("clickRange", range);
    },
    clickCustomRange: function clickCustomRange() {
      this.customRangeActive = true;
      this.$emit("showCustomRange");
    },
    range_class: function range_class(range) {
      return {
        active: range.selected === true
      };
    }
  },
  computed: {
    listedRanges: function listedRanges() {
      var _this = this;

      if (!this.ranges) return false;
      return Object.keys(this.ranges).map(function (value) {
        return {
          label: value,
          value: _this.ranges[value],
          selected: _this.$dateUtil.isSame(_this.selected.startDate, _this.ranges[value][0]) && _this.$dateUtil.isSame(_this.selected.endDate, _this.ranges[value][1])
        };
      });
    },
    selectedRange: function selectedRange() {
      return this.listedRanges.find(function (r) {
        return r.selected === true;
      });
    },
    showCustomRangeLabel: function showCustomRangeLabel() {
      return !this.alwaysShowCalendars;
    }
  },
  render: function render(h) {
    var _this2 = this;

    var customRangeLabelVnodes = h("li", {
      class: {
        active: this.customRangeActive || !this.selectedRange
      },
      attrs: {
        tabindex: 0
      },
      on: {
        click: this.clickCustomRange
      }
    }, this.localeData.customRangeLabel);
    var listedRangesVnodes = [];
    this.listedRanges.forEach(function (item) {
      listedRangesVnodes.push(h("li", {
        attrs: {
          "data-range-key": item.label,
          tabindex: 0
        },
        class: _this2.range_class(item),
        key: item.label,
        on: {
          click: function click() {
            _this2.clickRange(item.value);
          }
        }
      }, item.label));
    });

    if (this.showCustomRangeLabel) {
      listedRangesVnodes.push(customRangeLabelVnodes);
    }

    var renderVnodes = function renderVnodes() {
      if (_this2.ranges) {
        return h("div", {
          class: "ranges"
        }, [h("ul", listedRangesVnodes)]);
      } else {
        return h("div", {
          class: "ranges"
        });
      }
    };

    return renderVnodes();
  }
});
// CONCATENATED MODULE: ./src/components/form-daterangepicker/pulgin/append-to-body.js
var VNlyAppendToBody = {
  inserted: function inserted(el, bindings, _ref) {
    var context = _ref.context;

    if (context.appendToBody) {
      var _context$$refs$toggle = context.$refs.toggle.getBoundingClientRect(),
          height = _context$$refs$toggle.height,
          top = _context$$refs$toggle.top,
          left = _context$$refs$toggle.left,
          width = _context$$refs$toggle.width,
          right = _context$$refs$toggle.right;

      el.unbindPosition = context.calculatePosition(el, context, {
        width: width,
        top: window.scrollY + top + height,
        left: window.scrollX + left,
        right: right
      });
      document.body.appendChild(el);
    } else {
      context.$refs.toggle.appendChild(el);
    }
  },
  unbind: function unbind(el, bindings, _ref2) {
    var context = _ref2.context;

    if (context.appendToBody) {
      if (el.unbindPosition && typeof el.unbindPosition === "function") {
        el.unbindPosition();
      }

      if (el.parentNode) {
        el.parentNode.removeChild(el);
      }
    }
  }
};
// CONCATENATED MODULE: ./src/components/input-group/input-group-text.js


var input_group_text_name = "NlyInputGroupText";
var input_group_text_props = {
  tag: {
    type: String,
    default: "span"
  },
  textClass: {
    type: String,
    default: null
  }
};
var NlyInputGroupText = utils_vue.extend({
  name: input_group_text_name,
  functional: true,
  props: input_group_text_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "input-group-text",
      class: [props.textClass]
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/input-group/input-group-append.js



var input_group_append_name = "NlyInputGroupAppend";
var input_group_append_props = {
  tag: {
    type: String,
    default: "div"
  },
  id: {
    type: String,
    default: null
  },
  isText: {
    type: Boolean,
    default: false
  },
  appendClass: {
    type: String,
    default: null
  },
  textTag: {
    type: String,
    default: "span"
  },
  textClass: {
    type: String,
    default: null
  }
};
var NlyInputGroupAppend = utils_vue.extend({
  name: input_group_append_name,
  props: input_group_append_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;

    if (props.isText) {
      return h(props.tag, lib_esm_a(data, {
        staticClass: "input-group-append",
        class: [props.appendClass],
        attrs: {
          id: props.id
        }
      }), [h(NlyInputGroupText, {
        props: {
          tag: props.textTag,
          textClass: props.textClass
        }
      }, children)]);
    } else {
      return h(props.tag, lib_esm_a(data, {
        staticClass: "input-group-append",
        class: [props.prependClass],
        attrs: {
          id: props.id
        }
      }), children);
    }
  }
});
// CONCATENATED MODULE: ./src/components/input-group/input-group-prepend.js



var input_group_prepend_name = "NlyInputGroupPrepend";
var input_group_prepend_props = {
  tag: {
    type: String,
    default: "div"
  },
  id: {
    type: String,
    default: null
  },
  isText: {
    type: Boolean,
    default: false
  },
  prependClass: {
    type: String,
    default: null
  },
  textTag: {
    type: String,
    default: "span"
  },
  textClass: {
    type: String,
    default: null
  }
};
var NlyInputGroupPrepend = utils_vue.extend({
  name: input_group_prepend_name,
  props: input_group_prepend_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;

    if (props.isText) {
      return h(props.tag, lib_esm_a(data, {
        staticClass: "input-group-prepend",
        class: [props.prependClass]
      }), [h(NlyInputGroupText, {
        props: {
          tag: props.textTag,
          textClass: props.textClass
        }
      }, children)]);
    } else {
      return h(props.tag, lib_esm_a(data, {
        staticClass: "input-group-prepend",
        class: [props.prependClass]
      }), children);
    }
  }
});
// CONCATENATED MODULE: ./src/components/form/form-text.js




var form_text_NAME = "NlyFormText";
var form_text_props = {
  id: {
    type: String
  },
  tag: {
    type: String,
    default: "small"
  },
  textVariant: {
    type: String,
    default: function _default() {
      return getComponentConfig(form_text_NAME, "textVariant");
    }
  },
  inline: {
    type: Boolean,
    default: false
  }
};
var NlyFormText = utils_vue.extend({
  name: form_text_NAME,
  functional: true,
  props: form_text_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      class: Object(defineProperty["a" /* default */])({
        "form-text": !props.inline
      }, "text-".concat(props.textVariant), props.textVariant),
      attrs: {
        id: props.id
      }
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/form/form-feedback.js




var form_feedback_name = "NlyFormFeedback";
var form_feedback_props = {
  id: {
    type: String
  },
  tag: {
    type: String,
    default: "span"
  },
  tooltip: {
    type: Boolean,
    default: false
  },
  forceShow: {
    type: Boolean,
    default: false
  },
  state: {
    type: String,
    default: "valid",
    validator: function validator(state) {
      return nlyGetOptionInclusion(formValidOptions, state);
    }
  },
  ariaLive: {
    type: String
  },
  role: {
    type: String
  },
  text: {
    type: String
  }
};

var form_feedback_coustomclass = function coustomclass(props) {
  var validClass = function validClass() {
    return props.tooltip ? nlyGetOptionsByKeyEqual(formFeedBackTooltipOptions, props.state) : nlyGetOptionsByKeyEqual(formFeedBackValidOptions, props.state);
  };

  var showClass = props.forceShow === true || props.state === "novalid" ? "d-block" : null;
  return [validClass(), showClass];
};

var form_feedback_customAttrs = function customAttrs(props) {
  return {
    id: props.id || null,
    role: props.role || null,
    "aria-live": props.ariaLive || null,
    "aria-atomic": props.ariaLive ? "true" : null
  };
};

var NlyFormFeedback = utils_vue.extend({
  name: form_feedback_name,
  props: form_feedback_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;

    if (props.text) {
      return h(props.tag, lib_esm_a(data, {
        class: form_feedback_coustomclass(props),
        attrs: form_feedback_customAttrs(props)
      }), props.text);
    } else {
      return h(props.tag, lib_esm_a(data, {
        class: form_feedback_coustomclass(props),
        attrs: form_feedback_customAttrs(props)
      }), children);
    }
  }
});
// CONCATENATED MODULE: ./src/components/input-group/input-group.js














var input_group_name = "NlyInputGroup";
var input_group_props = {
  id: {
    type: String
  },
  size: {
    type: String,
    default: null
  },
  prepend: {
    type: String
  },
  prependHtml: {
    type: String
  },
  append: {
    type: String
  },
  appendHtml: {
    type: String
  },
  tag: {
    type: String,
    default: "div"
  },
  description: {
    type: String
  },
  invalidFeedback: {
    type: String
  },
  validFeedback: {
    type: String
  },
  warningFeedback: {
    type: String
  },
  valid: {
    type: String,
    validator: function validator(valid) {
      return nlyGetOptionInclusion(formValidOptions, valid);
    }
  },
  textTag: {
    type: String,
    default: "small"
  },
  textVariant: {
    type: String,
    default: function _default() {
      return getComponentConfig("NlyFormText", "textVariant");
    }
  },
  textInline: {
    type: Boolean,
    default: false
  }
};

var input_group_validClass = function validClass(props) {
  return props.valid === "valid" ? "is-valid" : props.valid === "invalid" ? "is-invalid" : props.valid === "warning" ? "is-warning" : null;
};

var sizeClass = function sizeClass(props) {
  return props.size ? "input-group-".concat(props.size) : null;
};

var NlyInputGroup = utils_vue.extend({
  name: input_group_name,
  props: input_group_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        slots = _ref.slots,
        scopedSlots = _ref.scopedSlots;
    var prepend = props.prepend,
        prependHtml = props.prependHtml,
        append = props.append,
        appendHtml = props.appendHtml;
    var $scopedSlots = scopedSlots || {};
    var $slots = slots();
    var slotScope = {};
    var $prepend = h();
    var hasPrependSlot = normalize_slot_hasNormalizedSlot("prepend", $scopedSlots, $slots);

    if (hasPrependSlot || prepend || prependHtml) {
      $prepend = h(NlyInputGroupPrepend, [hasPrependSlot ? normalize_slot_normalizeSlot("prepend", slotScope, $scopedSlots, $slots) : h(NlyInputGroupText, {
        domProps: htmlOrText(prependHtml, prepend)
      })]);
    }

    var $append = h();
    var hasAppendSlot = normalize_slot_hasNormalizedSlot("append", $scopedSlots, $slots);

    if (hasAppendSlot || append || appendHtml) {
      $append = h(NlyInputGroupAppend, [hasAppendSlot ? normalize_slot_normalizeSlot("append", slotScope, $scopedSlots, $slots) : h(NlyInputGroupText, {
        domProps: htmlOrText(appendHtml, append)
      })]);
    }

    var $description = h();

    if (props.description) {
      $description = h(NlyFormText, {
        props: {
          tag: props.textTag,
          inline: props.textInline,
          textVariant: props.textVariant
        }
      }, props.description);
    }

    var $invalidFeedback = h();

    if (props.invalidFeedback) {
      $invalidFeedback = h(NlyFormFeedback, {
        props: {
          state: "invalid",
          text: props.invalidFeedback
        }
      });
    }

    var $validFeedback = h();

    if (props.validFeedback) {
      $validFeedback = h(NlyFormFeedback, {
        props: {
          state: "valid",
          text: props.validFeedback
        }
      });
    }

    var $warningFeedback = h();

    if (props.warningFeedback) {
      $warningFeedback = h(NlyFormFeedback, {
        props: {
          state: "warning",
          text: props.warningFeedback
        }
      });
    }

    if (props.invalidFeedback || props.validFeedback || props.warningFeedback || props.description) {
      return h("div", [h(props.tag, lib_esm_a(data, {
        staticClass: "input-group nly-input-group",
        class: [sizeClass(props), input_group_validClass(props)],
        attrs: {
          id: props.id || null,
          role: "group"
        }
      }), [$prepend, normalize_slot_normalizeSlot("default", slotScope, $scopedSlots, $slots), $append]), $invalidFeedback, $validFeedback, $warningFeedback, $description]);
    } else {
      return h(props.tag, lib_esm_a(data, {
        staticClass: "input-group",
        class: [sizeClass(props)],
        attrs: {
          id: props.id || null,
          role: "group"
        }
      }), [$prepend, normalize_slot_normalizeSlot("default", slotScope, $scopedSlots, $slots), $append]);
    }
  }
});
// CONCATENATED MODULE: ./src/mixins/form/form-text.js






/* harmony default export */ var form_text = ({
  model: {
    prop: "value",
    event: "update"
  },
  props: {
    // v-model传值会传给value，也可以直接给value传值
    value: {
      type: [String, Object, Number, Boolean, Date],
      default: ""
    },
    // 只读
    readonly: {
      type: Boolean,
      default: false
    },
    // 无外框
    plaintext: {
      type: Boolean,
      default: false
    },
    // 自动提示完成填写
    autocomplete: {
      type: String,
      default: null
    },
    // 提示内容
    placeholder: {
      type: String,
      default: null
    },
    // 格式转换
    formatter: {
      type: Function,
      default: null
    },
    // 懒加载格式转换
    lazyFormatter: {
      type: Boolean,
      default: false
    },
    // 去除首位空格
    trim: {
      type: Boolean,
      default: false
    },
    number: {
      type: Boolean,
      default: false
    },
    lazy: {
      // Only update the `v-model` on blur/change events
      type: Boolean,
      default: false
    },
    debounce: {
      // Debounce timout (in ms). Not applicable with `lazy` prop
      type: [Number, String],
      default: 0
    }
  },
  data: function data() {
    return {
      localValue: string_toString(this.value),
      cloneValue: this.value
    };
  },
  computed: {
    customHasFormatter: function customHasFormatter() {
      return isFunction(this.formatter);
    },
    computedDebounce: function computedDebounce() {
      // Ensure we have a positive number equal to or greater than 0
      return mathMax(toInteger(this.debounce, 0), 0);
    }
  },
  watch: {
    value: function value(newVal) {
      var stringifyValue = string_toString(newVal);

      if (stringifyValue !== this.localValue && newVal !== this.vModelValue) {
        // Clear any pending debounce timeout, as we are overwriting the user input
        this.clearDebounce(); // Update the local values

        this.localValue = stringifyValue;
        this.vModelValue = newVal;
      }
    }
  },
  mounted: function mounted() {
    // Create non-reactive property and set up destroy handl
    this.$_inputDebounceTimer = null;
    this.$on("hook:beforeDestroy", this.clearDebounce); // Preset the internal state

    var value = this.value;
    var stringifyValue = string_toString(value);
    /* istanbul ignore next */

    if (stringifyValue !== this.localValue && value !== this.vModelValue) {
      this.localValue = stringifyValue;
      this.vModelValue = value;
    }
  },
  methods: {
    clearDebounce: function clearDebounce() {
      clearTimeout(this.$_inputDebounceTimer);
      this.$_inputDebounceTimer = null;
    },
    // 转换格式
    formatValue: function formatValue(value, evt) {
      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      value = string_toString(value);

      if (this.customHasFormatter && (!this.lazyFormatter || force)) {
        value = this.formatter(value, evt);
      }

      return value;
    },
    // 去除首尾空格
    modifyValue: function modifyValue(value) {
      // Emulate `.trim` modifier behaviour
      if (this.trim) {
        value = value.trim();
      } // Emulate `.number` modifier behaviour


      if (this.number) {
        value = toFloat(value, value);
      }

      return value;
    },
    // 更新value值给v-model
    updateValue: function updateValue(value) {
      var _this = this;

      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var lazy = this.lazy;

      if (lazy && !force) {
        return;
      }

      value = this.modifyValue(value);

      if (value !== this.vModelValue) {
        this.clearDebounce();

        var doUpdate = function doUpdate() {
          _this.vModelValue = value;

          _this.$emit("update", value);
        };

        var debounce = this.computedDebounce;

        if (debounce > 0 && !lazy && !force) {
          this.$_inputDebounceTimer = setTimeout(doUpdate, debounce);
        } else {
          doUpdate();
        }
      } else if (this.hasFormatter) {
        var $input = this.$refs.input;

        if ($input && value !== $input.value) {
          $input.value = value;
        }
      }
    },
    onInput: function onInput(evt) {
      // 阻止IME
      if (evt.target.composing) {
        return;
      }

      var value = evt.target.value;
      var formattedValue = this.formatValue(value, evt);

      if (formattedValue === false || evt.defaultPrevented) {
        evt.preventDefault();
        return;
      }

      this.localValue = formattedValue;
      this.updateValue(formattedValue);
      this.$emit("input", formattedValue);
    },
    onChange: function onChange(evt) {
      var value = evt.target.value;
      var formattedValue = this.formatValue(value, evt);

      if (formattedValue === false || evt.defaultPrevented) {
        evt.preventDefault();
        return;
      }

      this.localValue = formattedValue;
      this.updateValue(formattedValue, true);
      this.$emit("change", formattedValue);
    },
    onBlur: function onBlur(evt) {
      var value = evt.target.value;
      var formattedValue = this.formatValue(value, evt, true);

      if (formattedValue !== false) {
        this.localValue = string_toString(this.modifyValue(formattedValue));
        this.updateValue(formattedValue, true);
      }

      this.$emit("blur", evt);
    },
    focus: function focus() {
      if (!this.disabled) {
        this.$el.focus();
      }
    },
    blur: function blur() {
      if (!this.disabled) {
        this.$el.blur();
      }
    }
  }
});
// CONCATENATED MODULE: ./src/mixins/form/form-selection.js
// @vue/component
/* harmony default export */ var form_selection = ({
  computed: {
    selectionStart: {
      // Expose selectionStart for formatters, etc
      cache: false,

      /* istanbul ignore next */
      get: function get() {
        return this.$refs.input.selectionStart;
      },

      /* istanbul ignore next */
      set: function set(val) {
        this.$refs.input.selectionStart = val;
      }
    },
    selectionEnd: {
      // Expose selectionEnd for formatters, etc
      cache: false,

      /* istanbul ignore next */
      get: function get() {
        return this.$refs.input.selectionEnd;
      },

      /* istanbul ignore next */
      set: function set(val) {
        this.$refs.input.selectionEnd = val;
      }
    },
    selectionDirection: {
      // Expose selectionDirection for formatters, etc
      cache: false,

      /* istanbul ignore next */
      get: function get() {
        return this.$refs.input.selectionDirection;
      },

      /* istanbul ignore next */
      set: function set(val) {
        this.$refs.input.selectionDirection = val;
      }
    }
  },
  methods: {
    /* istanbul ignore next */
    select: function select() {
      var _this$$refs$input;

      // For external handler that may want a select() method
      (_this$$refs$input = this.$refs.input).select.apply(_this$$refs$input, arguments);
    },

    /* istanbul ignore next */
    setSelectionRange: function setSelectionRange() {
      var _this$$refs$input2;

      // For external handler that may want a setSelectionRange(a,b,c) method
      (_this$$refs$input2 = this.$refs.input).setSelectionRange.apply(_this$$refs$input2, arguments);
    },

    /* istanbul ignore next */
    setRangeText: function setRangeText() {
      var _this$$refs$input3;

      // For external handler that may want a setRangeText(a,b,c) method
      (_this$$refs$input3 = this.$refs.input).setRangeText.apply(_this$$refs$input3, arguments);
    }
  }
});
// CONCATENATED MODULE: ./src/mixins/form/form-validity.js
// @vue/component
/* harmony default export */ var form_validity = ({
  computed: {
    validity: {
      // Expose validity property
      cache: false,

      /* istanbul ignore next */
      get: function get() {
        return this.$refs.input.validity;
      }
    },
    validationMessage: {
      // Expose validationMessage property
      cache: false,

      /* istanbul ignore next */
      get: function get() {
        return this.$refs.input.validationMessage;
      }
    },
    willValidate: {
      // Expose willValidate property
      cache: false,

      /* istanbul ignore next */
      get: function get() {
        return this.$refs.input.willValidate;
      }
    }
  },
  methods: {
    /* istanbul ignore next */
    setCustomValidity: function setCustomValidity() {
      var _this$$refs$input;

      // For external handler that may want a setCustomValidity(...) method
      return (_this$$refs$input = this.$refs.input).setCustomValidity.apply(_this$$refs$input, arguments);
    },

    /* istanbul ignore next */
    checkValidity: function checkValidity() {
      var _this$$refs$input2;

      // For external handler that may want a checkValidity(...) method
      return (_this$$refs$input2 = this.$refs.input).checkValidity.apply(_this$$refs$input2, arguments);
    },

    /* istanbul ignore next */
    reportValidity: function reportValidity() {
      var _this$$refs$input3;

      // For external handler that may want a reportValidity(...) method
      return (_this$$refs$input3 = this.$refs.input).reportValidity.apply(_this$$refs$input3, arguments);
    }
  }
});
// CONCATENATED MODULE: ./src/components/form-input/form-input.js














 // import { toFloat } from "../../../utils/number";

var form_input_name = "NlyFormInput";
var NlyFormInput = utils_vue.extend({
  name: form_input_name,
  mixins: [form_text, form_form, mixins_id, form_size, form_valid, form_selection, form_validity],
  props: {
    // input类型
    type: {
      type: String,
      default: "text",
      validator: function validator(type) {
        return nlyGetOptionInclusion(inputTypeOptions, type);
      }
    },
    noWheel: {
      // Disable mousewheel to prevent wheel from changing values (i.e. number/date).
      type: Boolean,
      default: false
    },
    //颜色拾取器默认类型
    colorDefault: {
      type: Boolean,
      default: true
    },
    // 输入值的最大范围，type=number和range才有左右
    max: {
      type: [String, Number]
    },
    // 输入值的最小范围，type=number和range才有用
    min: {
      type: [String, Number]
    },
    // 输入值的最大长度，type='text'或者'password'时有用
    maxlength: {
      type: [String, Number]
    },
    // 有效间隔
    step: {
      type: [String, Number],
      default: null
    },
    // 输入时出现预先设定的option下拉列表，password无效
    list: {
      type: String,
      default: null
    },
    variant: {
      type: String
    },
    isNavbar: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    customProps: function customProps() {
      return {
        type: nlyGetOptionInclusion(inputTypeOptions, this.type) ? this.type : "text",
        min: nlyGetOptionInclusion(inputMaxMinStepOptions, this.type) ? this.min : null,
        max: nlyGetOptionInclusion(inputMaxMinStepOptions, this.type) ? this.max : null,
        maxlength: this.maxlength,
        step: nlyGetOptionInclusion(inputMaxMinStepOptions, this.type) ? this.step : null
      };
    },
    computedClass: function computedClass() {
      var _this = this;

      var variantClass = this.type === "range" && this.variant ? "custom-range-".concat(this.variant) : null;
      var rangeClass = this.type === "range" ? "custom-range" : null;

      var plaintextClass = function plaintextClass() {
        if (_this.plaintext && _this.type !== "range" && _this.type !== "color") {
          return "form-control-plaintext";
        } else {
          return null;
        }
      };

      var formControlClass = function formControlClass() {
        if (_this.type === "range" || _this.plaintext) {
          return null;
        } else {
          return "form-control";
        }
      };

      var isNavbarClass = this.isNavbar ? "form-control-navbar" : null;
      return [formControlClass(), rangeClass, plaintextClass(), this.sizeFormClass, this.validClass, variantClass, isNavbarClass, this.customCol, this.customXl, this.customLg, this.customMd, this.customSm, this.customXs, this.customOffsetXl, this.customOffsetLg, this.customOffsetMd, this.customOffsetSm, this.customOffsetXs, this.customOrderXl, this.customOrderLg, this.customOrderMd, this.customOrderSm, this.customOrderXs];
    },
    // 检查formatter prop是不是函数
    customHasFormatter: function customHasFormatter() {
      return isFunction(this.formatter);
    }
  },
  watch: {
    noWheel: function noWheel(newVal) {
      this.setWheelStopper(newVal);
    }
  },
  methods: {
    setWheelStopper: function setWheelStopper(on) {
      var input = this.$el; // We use native events, so that we don't interfere with propagation

      eventOnOff(on, input, "focus", this.onWheelFocus);
      eventOnOff(on, input, "blur", this.onWheelBlur);

      if (!on) {
        eventOff(document, "wheel", this.stopWheel);
      }
    },
    onWheelFocus: function onWheelFocus() {
      eventOn(document, "wheel", this.stopWheel);
    },
    onWheelBlur: function onWheelBlur() {
      eventOff(document, "wheel", this.stopWheel);
    },
    stopWheel: function stopWheel(evt) {
      evt.preventDefault();
      this.$el.blur();
    }
  },
  mounted: function mounted() {
    this.setWheelStopper(this.noWheel);
  },
  deactivated: function deactivated() {
    // Turn off listeners when keep-alive component deactivated

    /* istanbul ignore next */
    this.setWheelStopper(false);
  },

  /* istanbul ignore next */
  activated: function activated() {
    // Turn on listeners (if no-wheel) when keep-alive component activated

    /* istanbul ignore next */
    this.setWheelStopper(this.noWheel);
  },
  beforeDestroy: function beforeDestroy() {
    /* istanbul ignore next */
    this.setWheelStopper(false);
  },
  render: function render(h) {
    var self = this;
    return h("input", {
      ref: "input",
      class: this.computedClass,
      attrs: {
        id: self.safeId(),
        name: self.name,
        form: self.form || null,
        type: self.customProps.type,
        max: self.customProps.max,
        min: self.customProps.min,
        maxlength: self.customProps.maxlength,
        step: self.customProps.step,
        disabled: self.disabled,
        placeholder: self.placeholder,
        required: self.required,
        autocomplete: self.autocomplete || null,
        readonly: self.readonly || self.plaintext,
        list: self.localType !== "password" ? self.list : null
      },
      directives: [{
        name: "model",
        rawName: "v-model",
        value: self.value,
        expression: "value"
      }],
      domProps: {
        value: self.value
      },
      on: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, self.$listeners), {}, {
        input: self.onInput,
        change: self.onChange,
        blur: self.onBlur
      })
    });
  }
});
// CONCATENATED MODULE: ./src/components/form-daterangepicker/pulgin/transition.js

 // import { toInteger } from "../../utils/number";
// const beforeEnter = el => {
//   el.style.transform = "translateX(10px)";
//   el.style.opacity = 0;
// };
// const enter = el => {
//   el.style.transition = `all 0.2s ease`;
// };
// const afterEnter = el => {
//   el.style.opacity = "";
//   el.style.transform = "";
//   el.style.transition = "";
// };
// const leave = el => {
//   el.style.transition = "all 1s cubic-bezier(1, 0.5, 0.8, 1)";
// };
// const leaveTo = el => {
//   el.style.transform = "translateX(10px)";
//   el.style.opacity = 0;
// };
// // const afterLeave = el => {
// //   el.style.transition = "";
// //   el.style.transform = "";
// //   el.style.opacity = "";
// // };
// const TRANSITION_HANDLERS = {
//   beforeEnter: beforeEnter,
//   enter: enter,
//   afterEnter: afterEnter,
//   leave: leave,
//   leaveTo: leaveTo
//   // afterLeave: afterLeave
// };

var transition_name = "NlyDaterangePickerTransition";
var NlyDaterangePickerTransition = utils_vue.extend({
  name: transition_name,
  functional: true,
  render: function render(h, _ref) {
    var data = _ref.data,
        children = _ref.children;
    return h("transition", lib_esm_a(data, {
      // on: TRANSITION_HANDLERS,
      // name: "slide-fade",
      mode: "out-in",
      props: {
        enterClass: "slide-fade-enter",
        enterActiveClass: "slide-fade-enter-active",
        leaveActiveClass: "slide-fade-leave-active",
        leaveToClass: "slide-fade-leave-to"
      } // enterClass: "slide-fade-enter",
      // enterActiveClass: "slide-fade-enter-active",
      // leaveActiveClass: "slide-fade-leave-active",
      // leaveToClass: "slide-fade-leave-to",

    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/form-daterangepicker/form-daterangepicker.js

































var form_daterangepicker_name = "NlyFormDaterangepicker";
var NlyFormDaterangepicker = utils_vue.extend({
  name: form_daterangepicker_name,
  inheritAttrs: false,
  mixins: [date_util, form_valid, mixins_id],
  directives: {
    VNlyAppendToBody: VNlyAppendToBody
  },
  model: {
    prop: "value",
    event: "update"
  },
  props: {
    textTag: {
      type: String,
      default: "small"
    },
    textVariant: {
      type: String,
      default: function _default() {
        return getComponentConfig("NlyFormText", "textVariant");
      }
    },
    textInline: {
      type: Boolean,
      default: false
    },
    description: {
      type: String
    },
    invalidFeedback: {
      type: String
    },
    validFeedback: {
      type: String
    },
    warningFeedback: {
      type: String
    },
    valid: {
      type: String,
      validator: function validator(valid) {
        return nlyGetOptionInclusion(formValidOptions, valid);
      }
    },
    size: {
      type: String,
      default: null
    },
    prepend: {
      type: String
    },
    prependHtml: {
      type: String
    },
    append: {
      type: String
    },
    appendHtml: {
      type: String
    },

    /**
     * minimum date allowed to be selected
     * @default null
     */
    minDate: {
      type: [String, Date],
      default: function _default() {
        return null;
      }
    },

    /**
     * maximum date allowed to be selected
     * @default null
     */
    maxDate: {
      type: [String, Date],
      default: function _default() {
        return null;
      }
    },

    /**
     * Show the week numbers on the left side of the calendar
     */
    showWeekNumbers: {
      type: Boolean,
      default: false
    },

    /**
     * Each calendar has separate navigation when this is false
     */
    linkedCalendars: {
      type: Boolean,
      default: true
    },

    /**
     * Only show a single calendar, with or without ranges.
     *
     * Set true or 'single' for a single calendar with no ranges, single dates only.
     * Set 'range' for a single calendar WITH ranges.
     * Set false for a double calendar with ranges.
     */
    singleDatePicker: {
      type: [Boolean, String],
      default: false
    },

    /**
     * Show the dropdowns for month and year selection above the calendars
     */
    showDropdowns: {
      type: Boolean,
      default: false
    },

    /**
     * Show the dropdowns for time (hour/minute) selection below the calendars
     */
    timePicker: {
      type: Boolean,
      default: false
    },

    /**
     * Determines the increment of minutes in the minute dropdown
     */
    timePickerIncrement: {
      type: Number,
      default: 5
    },

    /**
     * Use 24h format for the time
     */
    timePicker24Hour: {
      type: Boolean,
      default: true
    },

    /**
     * Allows you to select seconds except hour/minute
     */
    timePickerSeconds: {
      type: Boolean,
      default: false
    },

    /**
     * Auto apply selected range. If false you need to click an apply button
     */
    autoApply: {
      type: Boolean,
      default: false
    },

    /**
     * Object containing locale data used by the picker. See example below the table
     *
     * @default *see below
     */
    localeData: {
      type: Object,
      default: function _default() {
        return {};
      }
    },

    /**
     * This is the v-model prop which the component uses. This should be an object containing startDate and endDate props.
     * Each of the props should be a string which can be parsed by Date, or preferably a Date Object.
     * @default {
     * startDate: null,
     * endDate: null
     * }
     */
    value: {
      // for v-model
      type: [Object],
      default: null,
      required: true
    },

    /**
     * You can set this to false in order to hide the ranges selection. Otherwise it is an object with key/value. See below
     * @default *see below
     */
    ranges: {
      type: [Object, Boolean],
      default: function _default() {
        var today = new Date();
        today.setHours(0, 0, 0, 0);
        var yesterday = new Date();
        yesterday.setDate(today.getDate() - 1);
        yesterday.setHours(0, 0, 0, 0);
        var thisMonthStart = new Date(today.getFullYear(), today.getMonth(), 1);
        var thisMonthEnd = new Date(today.getFullYear(), today.getMonth() + 1, 0);
        return {
          Today: [today, today],
          Yesterday: [yesterday, yesterday],
          "This month": [thisMonthStart, thisMonthEnd],
          "This year": [new Date(today.getFullYear(), 0, 1), new Date(today.getFullYear(), 11, 31)],
          "Last month": [new Date(today.getFullYear(), today.getMonth() - 1, 1), new Date(today.getFullYear(), today.getMonth(), 0)]
        };
      }
    },

    /**
     * which way the picker opens - "center", "left", "right" or "inline"
     */
    opens: {
      type: String,
      default: "center"
    },

    /**
       function(classes, date) - special prop type function which accepts 2 params:
       "classes" - the classes that the component's logic has defined,
       "date" - tha date currently processed.
       You should return Vue class object which should be applied to the date rendered.
       */
    dateFormat: Function,

    /**
     * If set to false and one of the predefined ranges is selected then calendars are hidden.
     * If no range is selected or you have clicked the "Custom ranges" then the calendars are shown.
     */
    alwaysShowCalendars: {
      type: Boolean,
      default: true
    },

    /**
     * Disabled state. If true picker do not popup on click.
     */
    disabled: {
      type: Boolean,
      default: false
    },

    /**
     * Class of html picker control container
     */
    controlContainerClass: {
      type: [Object, String],
      default: "form-control reportrange-text"
    },

    /**
     * Append the dropdown element to the end of the body
     * and size/position it dynamically. Use it if you have
     * overflow or z-index issues.
     * @type {Boolean}
     */
    appendToBody: {
      type: Boolean,
      default: false
    },

    /**
     * Whether to close the dropdown on "esc"
     */
    closeOnEsc: {
      type: Boolean,
      default: true
    },

    /**
     * Makes the picker readonly. No button in footer. No ranges. Cannot change.
     */
    readonly: {
      type: Boolean
    }
  },
  data: function data() {
    //copy locale data object
    var util = Object(daterange_picker_util["getDateUtil"])();
    var data = {
      locale: util.localeData(Object(objectSpread2["a" /* default */])({}, this.localeData))
    };
    var startDate = this.value.startDate || null;
    var endDate = this.value.endDate || null;
    data.monthDate = startDate ? new Date(startDate) : new Date(); //get next month date

    data.nextMonthDate = util.nextMonth(data.monthDate);
    data.start = startDate ? new Date(startDate) : null;

    if (this.singleDatePicker && this.singleDatePicker !== "range") {
      // ignore endDate for singleDatePicker
      data.end = data.start;
    } else {
      data.end = endDate ? new Date(endDate) : null;
    }

    data.in_selection = false;
    data.open = false; //When alwaysShowCalendars = false and custom range is clicked

    data.showCustomRangeCalendars = false; // update day names order to firstDay

    if (data.locale.firstDay !== 0) {
      var iterator = data.locale.firstDay;

      var weekDays = _toConsumableArray(data.locale.daysOfWeek);

      while (iterator > 0) {
        weekDays.push(weekDays.shift());
        iterator--;
      }

      data.locale.daysOfWeek = weekDays;
    }

    return data;
  },
  methods: {
    calculatePosition: function calculatePosition(dropdownList, component, _ref) {
      var width = _ref.width,
          top = _ref.top,
          left = _ref.left,
          right = _ref.right;

      // which way the picker opens - "center", "left" or "right"
      if (component.opens === "center") {
        // console.log('center open', left, width)
        dropdownList.style.left = left + width / 2 + "px";
      } else if (component.opens === "left") {
        // console.log('left open', right, width)
        dropdownList.style.right = window.innerWidth - right + "px";
      } else if (component.opens === "right") {
        // console.log('right open')
        dropdownList.style.left = left + "px";
      }

      dropdownList.style.top = top + "px"; // dropdownList.style.width = width + 'px'
    },
    dateFormatFn: function dateFormatFn(classes, date) {
      var dt = new Date(date);
      dt.setHours(0, 0, 0, 0);
      var start = new Date(this.start);
      start.setHours(0, 0, 0, 0);
      var end = new Date(this.end);
      end.setHours(0, 0, 0, 0);
      classes["in-range"] = dt >= start && dt <= end;
      return this.dateFormat ? this.dateFormat(classes, date) : classes;
    },
    changeLeftMonth: function changeLeftMonth(value) {
      var newDate = new Date(value.year, value.month - 1, 1);
      this.monthDate = newDate;

      if (this.linkedCalendars || this.$dateUtil.yearMonth(this.monthDate) >= this.$dateUtil.yearMonth(this.nextMonthDate)) {
        this.nextMonthDate = this.$dateUtil.validateDateRange(this.$dateUtil.nextMonth(newDate), this.minDate, this.maxDate);

        if ((!this.singleDatePicker || this.singleDatePicker === "range") && this.$dateUtil.yearMonth(this.monthDate) === this.$dateUtil.yearMonth(this.nextMonthDate)) {
          this.monthDate = this.$dateUtil.validateDateRange(this.$dateUtil.prevMonth(this.monthDate), this.minDate, this.maxDate);
        }
      }
      /**
       * Emits event when the viewing month is changes. The second param is the index of the calendar.
       *
       * @param {monthDate} date displayed (first day of the month)
       * @param calendarIndex int 0 - first(left) calendar, 1 - second(right) calendar
       */


      this.$emit("change-month", this.monthDate, 0);
    },
    changeRightMonth: function changeRightMonth(value) {
      var newDate = new Date(value.year, value.month - 1, 1);
      this.nextMonthDate = newDate;

      if (this.linkedCalendars || this.$dateUtil.yearMonth(this.nextMonthDate) <= this.$dateUtil.yearMonth(this.monthDate)) {
        this.monthDate = this.$dateUtil.validateDateRange(this.$dateUtil.prevMonth(newDate), this.minDate, this.maxDate);

        if (this.$dateUtil.yearMonth(this.monthDate) === this.$dateUtil.yearMonth(this.nextMonthDate)) {
          this.nextMonthDate = this.$dateUtil.validateDateRange(this.$dateUtil.nextMonth(this.nextMonthDate), this.minDate, this.maxDate);
        }
      }

      this.$emit("change-month", this.monthDate, 1);
    },
    normalizeDatetime: function normalizeDatetime(value, oldValue) {
      var newDate = new Date(value);

      if (this.timePicker && oldValue) {
        newDate.setHours(oldValue.getHours());
        newDate.setMinutes(oldValue.getMinutes());
        newDate.setSeconds(oldValue.getSeconds());
        newDate.setMilliseconds(oldValue.getMilliseconds());
      }

      return newDate;
    },
    dateClick: function dateClick(value) {
      if (this.readonly) return false;

      if (this.in_selection) {
        this.in_selection = false;
        this.end = this.normalizeDatetime(value, this.end);

        if (this.end < this.start) {
          this.in_selection = true;
          this.start = this.normalizeDatetime(value, this.start);
        }

        if (!this.in_selection) {
          this.onSelect();
          if (this.autoApply) this.clickedApply();
        }
      } else {
        this.start = this.normalizeDatetime(value, this.start);
        this.end = this.normalizeDatetime(value, this.end);

        if (!this.singleDatePicker || this.singleDatePicker === "range") {
          this.in_selection = true;
        } else {
          this.onSelect();
          if (this.autoApply) this.clickedApply();
        }
      }
    },
    hoverDate: function hoverDate(value) {
      if (this.readonly) return false;
      var dt = this.normalizeDatetime(value, this.end);
      if (this.in_selection && dt >= this.start) this.end = dt;
      /**
       * Emits event when the mouse hovers a date
       * @param {Date} value the date that is being hovered
       */

      this.$emit("hoverDate", value);
    },
    onClickPicker: function onClickPicker() {
      if (!this.disabled) {
        this.togglePicker(null, true);
      }
    },
    togglePicker: function togglePicker(value, event) {
      if (typeof value === "boolean") {
        this.open = value;
      } else {
        this.open = !this.open;
      }

      if (event === true)
        /**
         * Emits whenever the picker opens/closes
         * @param {boolean} open - the current state of the picker
         * @param {Function} togglePicker - function (show, event) which can be used to control the picker. where "show" is the new state and "event" is boolean indicating whether a new event should be raised
         */
        this.$emit("toggle", this.open, this.togglePicker);
    },
    clickedApply: function clickedApply() {
      // this.open = false
      this.togglePicker(false, true);
      /**
       * Emits when the user selects a range from the picker and clicks "apply" (if autoApply is true).
       * @param {json} value - json object containing the dates: {startDate, endDate}
       */

      this.$emit("update", {
        startDate: this.start,
        endDate: this.singleDatePicker && this.singleDatePicker !== "range" ? this.start : this.end
      });
    },
    clickCancel: function clickCancel() {
      if (this.open) {
        // reset start and end
        var startDate = this.value.startDate;
        var endDate = this.value.endDate;
        this.start = startDate ? new Date(startDate) : null;
        this.end = endDate ? new Date(endDate) : null; // this.open = false

        this.togglePicker(false, true);
      }
    },
    onSelect: function onSelect() {
      /**
       * Emits when the user selects a range from the picker.
       * @param {json} value - json object containing the dates: {startDate, endDate}
       */
      this.$emit("select", {
        startDate: this.start,
        endDate: this.end
      });
    },
    clickAway: function clickAway($event) {
      if ($event && $event.target && !this.$el.contains($event.target) && this.$refs.dropdown && !this.$refs.dropdown.contains($event.target)) {
        this.clickCancel();
      }
    },
    clickRange: function clickRange(value) {
      this.in_selection = false;

      if (this.$dateUtil.isValidDate(value[0]) && this.$dateUtil.isValidDate(value[1])) {
        this.start = this.$dateUtil.validateDateRange(new Date(value[0]), this.minDate, this.maxDate);
        this.end = this.$dateUtil.validateDateRange(new Date(value[1]), this.minDate, this.maxDate);
        this.changeLeftMonth({
          month: this.start.getMonth() + 1,
          year: this.start.getFullYear()
        });
      } else {
        this.start = null;
        this.end = null;
      }

      this.onSelect();
      if (this.autoApply) this.clickedApply();
    },
    onUpdateStartTime: function onUpdateStartTime(value) {
      var start = new Date(this.start);
      start.setHours(value.hours);
      start.setMinutes(value.minutes);
      start.setSeconds(value.seconds);
      this.start = this.$dateUtil.validateDateRange(start, this.minDate, this.maxDate); // if autoapply is ON we should update the value on time selection change

      if (this.autoApply) {
        this.$emit("update", {
          startDate: this.start,
          endDate: this.singleDatePicker && this.singleDatePicker !== "range" ? this.start : this.end
        });
      }
    },
    onUpdateEndTime: function onUpdateEndTime(value) {
      var end = new Date(this.end);
      end.setHours(value.hours);
      end.setMinutes(value.minutes);
      end.setSeconds(value.seconds);
      this.end = this.$dateUtil.validateDateRange(end, this.minDate, this.maxDate); // if autoapply is ON we should update the value on time selection change

      if (this.autoApply) {
        this.$emit("update", {
          startDate: this.start,
          endDate: this.end
        });
      }
    },
    handleEscape: function handleEscape(e) {
      if (this.open && e.keyCode === 27 && this.closeOnEsc) {
        this.clickCancel();
      }
    }
  },
  computed: {
    showRanges: function showRanges() {
      return this.ranges !== false && !this.readonly;
    },
    showCalendars: function showCalendars() {
      return this.alwaysShowCalendars || this.showCustomRangeCalendars;
    },
    startText: function startText() {
      if (this.start === null) return "";
      return this.$dateUtil.format(this.start, this.locale.format);
    },
    endText: function endText() {
      if (this.end === null) return "";
      return this.$dateUtil.format(this.end, this.locale.format);
    },
    rangeText: function rangeText() {
      var range = this.startText;

      if (!this.singleDatePicker || this.singleDatePicker === "range") {
        range += this.locale.separator + this.endText;
      }

      return range;
    },
    min: function min() {
      return this.minDate ? new Date(this.minDate) : null;
    },
    max: function max() {
      return this.maxDate ? new Date(this.maxDate) : null;
    },
    pickerStyles: function pickerStyles() {
      var _ref2;

      return _ref2 = {
        "show-calendar": this.open || this.opens === "inline",
        "show-ranges": this.showRanges,
        "show-weeknumbers": this.showWeekNumbers,
        single: this.singleDatePicker
      }, Object(defineProperty["a" /* default */])(_ref2, "opens" + this.opens, true), Object(defineProperty["a" /* default */])(_ref2, "linked", this.linkedCalendars), Object(defineProperty["a" /* default */])(_ref2, "hide-calendars", !this.showCalendars), _ref2;
    },
    isClear: function isClear() {
      return !this.value.startDate || !this.value.endDate;
    },
    isDirty: function isDirty() {
      var origStart = new Date(this.value.startDate);
      var origEnd = new Date(this.value.endDate);
      return !this.isClear && (this.start.getTime() !== origStart.getTime() || this.end.getTime() !== origEnd.getTime());
    }
  },
  watch: {
    minDate: function minDate() {
      var dt = this.$dateUtil.validateDateRange(this.monthDate, this.minDate || new Date(), this.maxDate);
      this.changeLeftMonth({
        year: dt.getFullYear(),
        month: dt.getMonth() + 1
      });
    },
    maxDate: function maxDate() {
      var dt = this.$dateUtil.validateDateRange(this.nextMonthDate, this.minDate, this.maxDate || new Date());
      this.changeRightMonth({
        year: dt.getFullYear(),
        month: dt.getMonth() + 1
      });
    },
    "value.startDate": function valueStartDate(value) {
      if (!this.$dateUtil.isValidDate(new Date(value))) return;
      this.start = !!value && !this.isClear && this.$dateUtil.isValidDate(new Date(value)) ? new Date(value) : null;

      if (this.isClear) {
        this.start = null;
        this.end = null;
      } else {
        this.start = new Date(this.value.startDate);
        this.end = new Date(this.value.endDate);
      }
    },
    "value.endDate": function valueEndDate(value) {
      if (!this.$dateUtil.isValidDate(new Date(value))) return;
      this.end = !!value && !this.isClear ? new Date(value) : null;

      if (this.isClear) {
        this.start = null;
        this.end = null;
      } else {
        this.start = new Date(this.value.startDate);
        this.end = new Date(this.value.endDate);
      }
    },
    open: {
      handler: function handler(value) {
        var _this = this;

        if ((typeof document === "undefined" ? "undefined" : Object(esm_typeof["a" /* default */])(document)) === "object") {
          this.$nextTick(function () {
            value ? document.body.addEventListener("click", _this.clickAway) : document.body.removeEventListener("click", _this.clickAway);
            value ? document.addEventListener("keydown", _this.handleEscape) : document.removeEventListener("keydown", _this.handleEscape);

            if (!_this.alwaysShowCalendars && _this.ranges) {
              _this.showCustomRangeCalendars = !Object.keys(_this.ranges).find(function (key) {
                return _this.$dateUtil.isSame(_this.start, _this.ranges[key][0], "date") && _this.$dateUtil.isSame(_this.end, _this.ranges[key][1], "date");
              });
            }
          });
        }
      },
      immediate: true
    }
  },
  render: function render(h) {
    var _this2 = this;

    var drpCalendarLeftChildrenVnodes = [h("div", {
      class: "calendar-table"
    }, [h(NlyCalendar, {
      props: {
        monthDate: this.monthDate,
        localeData: this.locale,
        start: this.start,
        end: this.end,
        minDate: this.min,
        maxDate: this.max,
        showDropdowns: this.showDropdowns,
        dateFormat: this.dateFormatFn,
        showWeekNumbers: this.showWeekNumbers
      },
      on: {
        "change-month": this.changeLeftMonth,
        dateClick: this.dateClick,
        hoverDate: this.hoverDate
      }
    })])];

    if (this.timePicker && this.start) {
      drpCalendarLeftChildrenVnodes.push(h(NlyCalendarTime, {
        props: {
          update: this.onUpdateStartTime,
          miniuteIncrement: this.timePickerIncrement,
          hour24: this.timePicker24Hour,
          secondPicker: this.timePickerSeconds,
          currentTime: this.start,
          readonly: this.readonly
        },
        on: {
          update: this.onUpdateStartTime
        }
      }));
    }

    var drpCalendarLeftVnodes = h("div", {
      staticClass: "drp-calendar col left",
      class: {
        single: this.singleDatePicker
      }
    }, drpCalendarLeftChildrenVnodes);
    var drpCalendarRightChildrenVnodes = [h("div", {
      class: "calendar-table"
    }, [h(NlyCalendar, {
      props: {
        monthDate: this.nextMonthDate,
        localeData: this.locale,
        start: this.start,
        end: this.end,
        minDate: this.min,
        maxDate: this.max,
        showDropdowns: this.showDropdowns,
        dateFormat: this.dateFormatFn,
        showWeekNumbers: this.showWeekNumbers
      },
      on: {
        "change-month": this.changeRightMonth,
        dateClick: this.dateClick,
        hoverDate: this.hoverDate
      }
    })])];

    if (this.timePicker && this.start) {
      drpCalendarRightChildrenVnodes.push(h(NlyCalendarTime, {
        props: {
          miniuteIncrement: this.timePickerIncrement,
          hour24: this.timePicker24Hour,
          secondPicker: this.timePickerSeconds,
          currentTime: this.end,
          readonly: this.readonly
        },
        on: {
          update: this.onUpdateEndTime
        }
      }));
    }

    var drpCalendarRightVnodes = h("div", {
      class: "drp-calendar col right"
    }, drpCalendarRightChildrenVnodes);
    var calendarsContainerChildrenVnodes = [drpCalendarLeftVnodes];

    if (!this.singleDatePicker) {
      calendarsContainerChildrenVnodes.push(drpCalendarRightVnodes);
    }

    var calendarsContainerVnodes = h("div", {
      class: "calendars-container "
    }, calendarsContainerChildrenVnodes);
    var calendarsRowChildVnodes = [];

    if (this.showRanges) {
      if (normalize_slot_hasNormalizedSlot("ranges", this.$scopedSlots, this.$slots)) {
        calendarsRowChildVnodes.push(this.$scopedSlots.ranges({
          startDate: this.start,
          endDate: this.end,
          ranges: this.ranges,
          clickRange: this.clickRange
        }));
      } else {
        calendarsRowChildVnodes.push(h(NlyCalendarRangs, {
          class: "col-12 col-md-auto",
          props: {
            alwaysShowCalendars: this.alwaysShowCalendars,
            localeData: this.locale,
            ranges: this.ranges,
            selected: {
              startDate: this.start,
              endDate: this.end
            }
          },
          on: {
            clickRange: this.clickRange,
            showCustomRange: function showCustomRange() {
              _this2.showCustomRangeCalendars = true;
            }
          }
        }));
      }
    }

    if (this.showCalendars) {
      calendarsRowChildVnodes.push(calendarsContainerVnodes);
    }

    var calendarsRowVnodes = h("div", {
      class: "calendars row no-gutters"
    }, calendarsRowChildVnodes);
    var slotsFooterButtonsChildrenVnodes = [];

    if (this.showCalendars) {
      slotsFooterButtonsChildrenVnodes.push(h("span", {
        class: "drp-selected"
      }, this.rangeText));
    }

    if (!this.readonly) {
      slotsFooterButtonsChildrenVnodes.push(h("button", {
        class: "cancelBtn btn btn-sm btn-secondary",
        attrs: {
          type: "button"
        },
        on: {
          click: this.clickCancel
        }
      }, this.locale.cancelLabel));
    }

    if (!this.readonly) {
      slotsFooterButtonsChildrenVnodes.push(h("button", {
        class: "applyBtn btn btn-sm btn-success",
        attrs: {
          disabled: this.in_selection,
          type: "button"
        },
        on: {
          click: this.clickedApply
        }
      }, this.locale.applyLabel));
    }

    var scopedSlotsFooter = function scopedSlotsFooter() {
      if (normalize_slot_hasNormalizedSlot("footer", _this2.$scopedSlots, _this2.$slots)) {
        return _this2.$scopedSlots.footer({
          rangeText: _this2.rangeText,
          locale: _this2.locale,
          clickCancel: _this2.clickCancel,
          clickApply: _this2.clickedApply,
          in_selection: _this2.in_selection,
          autoApply: _this2.autoApply
        });
      } else {
        if (!_this2.autoApply) {
          return h("div", {
            class: "drp-buttons"
          }, slotsFooterButtonsChildrenVnodes);
        }
      }
    };

    var daterangePickerTransitionVnodes = function daterangePickerTransitionVnodes() {
      if (normalize_slot_hasNormalizedSlot("header", _this2.$scopedSlots, _this2.$slots)) {
        if (_this2.open || _this2.opens === "inline") {
          return h(NlyDaterangePickerTransition, [h("div", {
            staticClass: "daterangepicker dropdown-menu ltr",
            class: _this2.pickerStyles,
            directives: [{
              name: "v-nly-append-to-body"
            }],
            ref: "dropdown"
          }, [_this2.$scopedSlots.header({
            rangeText: _this2.rangeText,
            locale: _this2.locale,
            clickCancel: _this2.clickCancel,
            clickApply: _this2.clickedApply,
            in_selection: _this2.in_selection,
            autoApply: _this2.autoApply
          }), calendarsRowVnodes, scopedSlotsFooter()])]);
        }
      } else {
        if (_this2.open || _this2.opens === "inline") {
          return h(NlyDaterangePickerTransition, [h("div", {
            staticClass: "daterangepicker dropdown-menu ltr",
            class: _this2.pickerStyles,
            directives: [{
              name: "v-nly-append-to-body"
            }],
            ref: "dropdown"
          }, [calendarsRowVnodes, scopedSlotsFooter()])]);
        }
      }
    };

    var $prepend = h();
    var hasPrependSlot = normalize_slot_hasNormalizedSlot("prepend", this.$scopedSlots, this.$slots);

    if (hasPrependSlot || this.prepend || this.prependHtml) {
      $prepend = h(NlyInputGroupPrepend, [hasPrependSlot ? normalize_slot_normalizeSlot("prepend", this.slotScope, this.$scopedSlots, this.$slots) : h(NlyInputGroupText, {
        domProps: htmlOrText(this.prependHtml, this.prepend)
      })]);
    }

    var $append = h();
    var hasAppendSlot = normalize_slot_hasNormalizedSlot("append", this.$scopedSlots, this.$slots);

    if (hasAppendSlot || this.append || this.appendHtml) {
      $append = h(NlyInputGroupAppend, [hasAppendSlot ? normalize_slot_normalizeSlot("append", this.slotScope, this.$scopedSlots, this.$slots) : h(NlyInputGroupText, {
        domProps: htmlOrText(this.appendHtml, this.append)
      })]);
    } // const InputGroupVnodes = [
    //   prependVnodes,
    //   h(NlyFormInput, {
    //     props: {
    //       value: this.rangeText,
    //       valid: this.valid
    //     },
    //     on: {
    //       click: this.onClickPicker
    //     }
    //   })
    // ];


    var scopedSlotsInput = function scopedSlotsInput() {
      if (normalize_slot_hasNormalizedSlot("input", _this2.$scopedSlots, _this2.$slots)) {
        return _this2.$scopedSlots.input({
          startDate: _this2.start,
          endDate: _this2.end,
          ranges: _this2.ranges,
          clickPicker: _this2.onClickPicker
        });
      } else {
        return h(NlyInputGroup, {
          props: {
            size: _this2.size
          },
          class: _this2.validClass
        }, [$prepend, h(NlyFormInput, {
          props: {
            value: _this2.rangeText,
            valid: _this2.valid
          },
          on: {
            click: _this2.onClickPicker
          }
        }), $append]);
      }
    };

    var pickerVnodes = [scopedSlotsInput()];
    var feedback = {
      invalid: this.invalidFeedback,
      valid: this.validFeedback,
      warning: this.warningFeedback
    };
    var stateList = ["invalid", "valid", "warning"];
    stateList.forEach(function (item) {
      if (Object.keys(feedback).indexOf(item) !== -1) {
        if (feedback[item]) {
          pickerVnodes.push(h(NlyFormFeedback, {
            props: {
              state: item,
              text: feedback[item]
            }
          }));
        }
      }
    });

    if (this.description) {
      pickerVnodes.push(h(NlyFormText, {
        props: {
          id: this.safeId("__nly-form_group_description"),
          tag: this.textTag,
          inline: this.textInline,
          textVariant: this.textVariant
        }
      }, this.description));
    }

    pickerVnodes.push(daterangePickerTransitionVnodes());
    return h("div", {
      staticClass: "nly-daterange-picker",
      class: [this.opens === "inline" ? "inline" : null],
      ref: "toggle"
    }, pickerVnodes);
  }
});
// CONCATENATED MODULE: ./src/components/form-daterangepicker/index.js







var FormDaterangepickerPlugin = plugins_nlyPluginFactory({
  components: {
    NlyFormDaterangepicker: NlyFormDaterangepicker,
    NlyCalendar: NlyCalendar,
    NlyCalendarRangs: NlyCalendarRangs,
    NlyCalendarTime: NlyCalendarTime,
    NlyDaterangePickerTransition: NlyDaterangePickerTransition
  },
  plugins: {
    VNlyAppendToBody: VNlyAppendToBody
  }
});

// CONCATENATED MODULE: ./src/components/form/form-datalist.js





var form_datalist_name = "NlyFormDatalist";
var NlyFormDatalist = utils_vue.extend({
  name: form_datalist_name,
  mixins: [form_options, mixins_normalize_slot],
  props: {
    id: {
      type: String,
      required: true
    }
  },
  render: function render(h) {
    var $options = this.formOptions.map(function (option, index) {
      var value = option.value,
          text = option.text,
          html = option.html,
          disabled = option.disabled;
      return h("option", {
        attrs: {
          value: value,
          disabled: disabled
        },
        domProps: htmlOrText(html, text),
        key: "option_".concat(index)
      });
    });
    return h("datalist", {
      attrs: {
        id: this.id
      }
    }, [$options, this.normalizeSlot("default")]);
  }
});
// CONCATENATED MODULE: ./src/components/form/index.js





var FormPlugin = plugins_nlyPluginFactory({
  components: {
    NlyForm: NlyForm,
    NlyFormFeedback: NlyFormFeedback,
    NlyFormText: NlyFormText,
    NlyFormDatalist: NlyFormDatalist
  }
});

// CONCATENATED MODULE: ./src/mixins/form/form-group-grid.js



/* harmony default export */ var form_group_grid = ({
  props: {
    labelColsXs: {
      default: false,
      type: [String, Number, Boolean]
    },
    labelColsSm: {
      default: false,
      type: [String, Number, Boolean]
    },
    labelColsMd: {
      default: false,
      type: [String, Number, Boolean]
    },
    labelColsLg: {
      default: false,
      type: [String, Number, Boolean]
    },
    labelColsXl: {
      default: false,
      type: [String, Number, Boolean]
    },
    labelColsOffsetXs: {
      type: [String, Number]
    },
    labelColsOffsetSm: {
      type: [String, Number]
    },
    labelColsOffsetMd: {
      type: [String, Number]
    },
    labelColsOffsetLg: {
      type: [String, Number]
    },
    labelColsOffsetXl: {
      type: [String, Number]
    },
    labelColsOrderXs: {
      type: [String, Number]
    },
    labelColsOrderSm: {
      type: [String, Number]
    },
    labelColsOrderMd: {
      type: [String, Number]
    },
    labelColsOrderLg: {
      type: [String, Number]
    },
    labelColsOrderXl: {
      type: [String, Number]
    }
  },
  computed: {
    customGroupGridProps: function customGroupGridProps() {
      return [this.labelColsXs === true ? "col" : this.labelColsXs ? "col-".concat(this.labelColsXs) : null, this.labelColsSm === true ? "col-sm" : this.labelColsSm ? "col-sm-".concat(this.labelColsSm) : null, this.labelColsMd === true ? "col-md" : this.labelColsMd ? "col-md-".concat(this.labelColsMd) : null, this.labelColsLg === true ? "col-lg" : this.labelColsLg ? "col-lg-".concat(this.labelColsLg) : null, this.labelColsXl === true ? "col-xl" : this.labelColsXl ? "col-xl-".concat(this.labelColsXl) : null, this.labelColsOrderXs === 0 || this.labelColsOrderXs ? "order-".concat(this.labelColsOrderXs) : null, this.labelColsOrderSm === 0 || this.labelColsOrderSm ? "order-sm-".concat(this.labelColsOrderSm) : null, this.labelColsOrderMd === 0 || this.labelColsOrderMd ? "order-md-".concat(this.labelColsOrderMd) : null, this.labelColsOrderLg === 0 || this.labelColsOrderLg ? "order-lg-".concat(this.labelColsOrderLg) : null, this.labelColsOrderXl === 0 || this.labelColsOrderXl ? "order-xl-".concat(this.labelColsOrderXl) : null, this.labelColsOffsetXs === 0 || this.labelColsOffsetXs ? "offset-".concat(this.labelColsOffsetXs) : null, this.labelColsOffsetSm === 0 || this.labelColsOffsetSm ? "offset-sm-".concat(this.labelColsOffsetSm) : null, this.labelColsOffsetMd === 0 || this.labelColsOffsetMd ? "offset-md-".concat(this.labelColsOffsetMd) : null, this.labelColsOffsetLg === 0 || this.labelColsOffsetLg ? "offset-lg-".concat(this.labelColsOffsetLg) : null, this.labelColsOffsetXl === 0 || this.labelColsOffsetXl ? "offset-xl-".concat(this.labelColsOffsetXl) : null];
    },
    customGroupGridPropslen: function customGroupGridPropslen() {
      var customGroupGridPropsValues = [];
      this.customGroupGridProps.forEach(function (element) {
        if (element !== null) {
          customGroupGridPropsValues.push(element);
        }
      });
      return customGroupGridPropsValues.length;
    }
  }
});
// CONCATENATED MODULE: ./src/mixins/form/from-label-text-align.js
/* harmony default export */ var from_label_text_align = ({
  props: {
    labelAlignXs: {
      type: String
    },
    labelAlignSm: {
      type: String
    },
    labelAlignMd: {
      type: String
    },
    labelAlignLg: {
      type: String
    },
    labelAlignXl: {
      type: String
    },
    labelClass: {
      type: String
    }
  },
  computed: {
    customGroupLabelTextProps: function customGroupLabelTextProps() {
      return [this.labelAlignXs ? "text-".concat(this.labelAlignXs) : null, this.labelAlignSm ? "text-sm-".concat(this.labelAlignSm) : null, this.labelAlignMd ? "text-md-".concat(this.labelAlignMd) : null, this.labelAlignLg ? "text-lg-".concat(this.labelAlignLg) : null, this.labelAlignXl ? "text-xl-".concat(this.labelAlignXl) : null, this.labelClass ? this.labelClass : null];
    }
  }
});
// CONCATENATED MODULE: ./src/components/form-group/form-group.js


















var form_group_name = "NlyFormGroup";
var NlyFormGroup = utils_vue.extend({
  name: form_group_name,
  mixins: [form_valid, mixins_id, form_group_grid, from_label_text_align],
  props: {
    textTag: {
      type: String,
      default: "small"
    },
    textVariant: {
      type: String,
      default: function _default() {
        return getComponentConfig("NlyFormText", "textVariant");
      }
    },
    textInline: {
      type: Boolean,
      default: false
    },
    labelSize: {
      type: String,
      default: null,
      validator: function validator(type) {
        return nlyGetOptionInclusion(formGroupSize, type);
      }
    },
    label: {
      type: String
    },
    labelFor: {
      type: String
    },
    labelSrOnly: {
      type: Boolean,
      default: false
    },
    description: {
      type: String
    },
    invalidFeedback: {
      type: String
    },
    validFeedback: {
      type: String
    },
    warningFeedback: {
      type: String
    },
    tooltip: {
      type: Boolean,
      default: false
    },
    feedbackAriaLive: {
      type: String,
      default: "assertive"
    },
    validated: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    customProps: function customProps() {
      return {
        labelSizeClass: this.labelSize ? "col-form-label-".concat(this.labelSize) : null,
        label: this.label,
        labelFor: this.labelFor,
        labelSrOnly: this.labelSrOnly,
        description: this.description,
        invalidFeedback: this.invalidFeedback ? this.invalidFeedback : null,
        validFeedback: this.validFeedback ? this.validFeedback : null,
        warningFeedback: this.warningFeedback ? this.warningFeedback : null,
        tooltip: this.tooltip,
        feedbackAriaLive: this.feedbackAriaLive,
        validated: this.validated ? "was-validated" : null,
        disabled: this.disabled
      };
    },
    customGroupGridPropsClass: function customGroupGridPropsClass() {
      var result = [];
      this.customGroupGridProps.forEach(function (element) {
        if (element !== null) {
          result.push(element);
        }
      });
      return result;
    },
    customGroupLabelTextPropsClass: function customGroupLabelTextPropsClass() {
      var result = [];
      this.customGroupLabelTextProps.forEach(function (element) {
        if (element !== null) {
          result.push(element);
        }
      });
      return result;
    }
  },
  render: function render(h) {
    var _this = this;

    var labelSrOonlyVnodes = function labelSrOonlyVnodes() {
      if (_this.customGroupGridPropslen !== 0) {
        return h("div", {
          class: _this.customGroupGridPropsClass
        }, [h("label", {
          staticClass: "sr-only",
          attrs: {
            id: _this.safeId("__nly__label__"),
            for: _this.customProps.labelFor || null
          }
        }, [_this.customProps.label])]);
      } else {
        return h("label", {
          staticClass: "sr-only",
          attrs: {
            id: _this.safeId("__nly__label__"),
            for: _this.customProps.labelFor || null
          }
        }, _this.customProps.label);
      }
    };

    var labelVnodes = function labelVnodes() {
      if (_this.customProps.labelSrOnly) {
        return labelSrOonlyVnodes();
      } else {
        if (_this.customGroupGridPropslen === 0) {
          return h("label", {
            staticClass: "d-block",
            class: [].concat(_toConsumableArray(_this.customGroupLabelTextPropsClass), [_this.customProps.labelSizeClass]),
            attrs: {
              id: _this.safeId("__nly__label__"),
              for: _this.customProps.labelFor || null
            }
          }, _this.customProps.label);
        } else {
          return h("label", {
            staticClass: "d-block",
            class: [].concat(_toConsumableArray(_this.customGroupLabelTextPropsClass), _toConsumableArray(_this.customGroupGridPropsClass), [_this.customProps.labelSizeClass]),
            attrs: {
              id: _this.safeId("__nly__label__"),
              for: _this.customProps.labelFor || null
            }
          }, _this.customProps.label);
        }
      }
    };

    var childVnodes = function childVnodes() {
      var feedback = {
        invalid: _this.customProps.invalidFeedback,
        valid: _this.customProps.validFeedback,
        warning: _this.customProps.warningFeedback
      };
      var state = ["invalid", "valid", "warning"];
      var result = [_this.$slots.default];
      state.forEach(function (item) {
        if (Object.keys(feedback).indexOf(item) !== -1) {
          if (feedback[item]) {
            result.push(h(NlyFormFeedback, {
              props: {
                tooltip: _this.customProps.tooltip,
                ariaLive: _this.customProps.feedbackAriaLive,
                id: _this.safeId("__nly-form_group_feedback_".concat(item)),
                state: item,
                text: feedback[item]
              }
            }));
          }
        }
      });
      result.push(_this.$slots["invalid-feedback"]);
      result.push(_this.$slots["valid-feedback"]);
      result.push(_this.$slots["warning-feedback"]);
      result.push(_this.$slots["description"]);

      if (_this.customProps.description) {
        result.push(h(NlyFormText, {
          props: {
            id: _this.safeId("__nly-form_group_description"),
            tag: _this.textTag,
            inline: _this.textInline,
            textVariant: _this.textVariant
          }
        }, _this.customProps.description));
      }

      return result;
    };

    var formGroupVnodes = function formGroupVnodes() {
      if (_this.customProps.label) {
        if (_this.customGroupGridPropslen === 0) {
          return h("div", {
            staticClass: "form-group",
            class: [_this.disabled ? null : _this.customProps.validated, _this.validClass],
            attrs: {
              id: _this.safeId(),
              "aria-invalid": _this.computedValid === "invalid" || _this.computedValid === "warning" ? true : null,
              role: "group"
            }
          }, [labelVnodes(), _this.$slots.label, h("div", {}, childVnodes())]);
        } else {
          return h("div", {
            staticClass: "form-group form-row",
            class: [_this.disabled ? null : _this.customProps.validated, _this.validClass],
            attrs: {
              id: _this.safeId(),
              "aria-invalid": _this.computedValid === "invalid" || _this.computedValid === "warning" ? true : null,
              role: "group"
            }
          }, [labelVnodes(), _this.$slots.label, h("div", {
            staticClass: "col"
          }, childVnodes())]);
        }
      } else {
        if (_this.customGroupGridPropslen === 0) {
          return h("div", {
            staticClass: "form-group",
            class: [_this.disabled ? null : _this.customProps.validated, _this.validClass],
            attrs: {
              id: _this.safeId(),
              "aria-invalid": _this.computedValid === "invalid" || _this.computedValid === "warning" ? true : null,
              role: "group"
            }
          }, [_this.$slots.label, h("div", {}, childVnodes())]);
        } else {
          return h("div", {
            staticClass: "form-group form-row",
            class: [_this.disabled ? null : _this.customProps.validated, _this.validClass],
            attrs: {
              id: _this.safeId(),
              "aria-invalid": _this.computedValid === "invalid" || _this.computedValid === "warning" ? true : null,
              role: "group"
            }
          }, [_this.$slots.label, h("div", {
            staticClass: "col"
          }, childVnodes())]);
        }
      }
    };

    return formGroupVnodes();
  }
});
// CONCATENATED MODULE: ./src/components/form-group/index.js


var FormGroupPlugin = plugins_nlyPluginFactory({
  components: {
    NlyFormGroup: NlyFormGroup
  }
});

// CONCATENATED MODULE: ./src/components/form-input/index.js


var FormInputPlugin = plugins_nlyPluginFactory({
  components: {
    NlyFormInput: NlyFormInput,
    NlyInput: NlyFormInput
  }
});

// CONCATENATED MODULE: ./src/components/form-radio/form-radio-group.js







var form_radio_group_props = {
  checked: {
    default: null
  }
};
var form_radio_group_name = "NlyFormRadioGroup";
var NlyFormRadioGroup = utils_vue.extend({
  name: form_radio_group_name,
  mixins: [mixins_id, form_form, form_radio_check_group, // Includes render function
  form_options, form_size, form_valid],
  provide: function provide() {
    return {
      nlyaRadioGroup: this
    };
  },
  props: form_radio_group_props,
  data: function data() {
    return {
      localChecked: this.checked
    };
  },
  computed: {
    isRadioGroup: function isRadioGroup() {
      return true;
    }
  }
});
// CONCATENATED MODULE: ./src/components/form-radio/index.js



var FormRadioPlugin = plugins_nlyPluginFactory({
  components: {
    NlyFormRadio: NlyFormRadio,
    NlyRadio: NlyFormRadio,
    NlyFormRadioGroup: NlyFormRadioGroup,
    NlyRadioGroup: NlyFormRadioGroup
  }
});

// CONCATENATED MODULE: ./src/mixins/form/form-custom.js
// @vue/component
/* harmony default export */ var form_custom = ({
  props: {
    plain: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    custom: function custom() {
      return !this.plain;
    }
  }
});
// CONCATENATED MODULE: ./src/components/form-select/helpers/mixin-options.js


 // @vue/component

/* harmony default export */ var mixin_options = ({
  mixins: [form_options],
  props: {
    labelField: {
      type: String,
      default: "label"
    },
    optionsField: {
      type: String,
      default: "options"
    }
  },
  methods: {
    normalizeOption: function normalizeOption(option) {
      var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (isPlainObject(option)) {
        var value = utils_get(option, this.valueField);
        var text = utils_get(option, this.textField);
        var options = utils_get(option, this.optionsField, null);

        if (!isNull(options)) {
          return {
            label: String(utils_get(option, this.labelField) || text),
            options: this.normalizeOptions(options)
          };
        }

        return {
          value: isUndefined(value) ? key || text : value,
          text: String(isUndefined(text) ? key : text),
          html: utils_get(option, this.htmlField),
          disabled: Boolean(utils_get(option, this.disabledField))
        };
      }

      return {
        value: key || option,
        text: String(option),
        disabled: false
      };
    }
  }
});
// CONCATENATED MODULE: ./src/components/form-select/form-select-option.js


var form_select_option_NAME = "NlyFormSelectOption";
var form_select_option_props = {
  value: {
    // type: [String, Number, Boolean, Object],
    required: true
  },
  disabled: {
    type: Boolean,
    default: false
  }
}; // @vue/component

var NlyFormSelectOption = /*#__PURE__*/utils_vue.extend({
  name: form_select_option_NAME,
  functional: true,
  props: form_select_option_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    var value = props.value,
        disabled = props.disabled;
    return h("option", lib_esm_a(data, {
      attrs: {
        disabled: disabled
      },
      domProps: {
        value: value
      }
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/form-select/form-select-option-group.js





 // @vue/component

var NlyFormSelectOptionGroup = /*#__PURE__*/utils_vue.extend({
  name: "NlyFormSelectOptionGroup",
  mixins: [mixins_normalize_slot, form_options],
  props: {
    label: {
      type: String,
      required: true
    }
  },
  render: function render(h) {
    var $options = this.formOptions.map(function (option, index) {
      var value = option.value,
          text = option.text,
          html = option.html,
          disabled = option.disabled;
      return h(NlyFormSelectOption, {
        attrs: {
          value: value,
          disabled: disabled
        },
        domProps: htmlOrText(html, text),
        key: "option_".concat(index)
      });
    });
    return h("optgroup", {
      attrs: {
        label: this.label
      }
    }, [this.normalizeSlot("first"), $options, this.normalizeSlot("default")]);
  }
});

// CONCATENATED MODULE: ./src/components/form-select/form-select.js

















var NlyFormSelect = utils_vue.extend({
  name: "NlyFormSelect",
  mixins: [mixins_id, mixins_normalize_slot, form_form, form_size, form_valid, form_custom, mixin_options],
  model: {
    prop: "value",
    event: "input"
  },
  props: {
    value: {// type: [Object, Array, String, Number, Boolean],
      // default: undefined
    },
    multiple: {
      type: Boolean,
      default: false
    },
    selectSize: {
      type: Number,
      default: 0
    },
    ariaInvalid: {
      type: [Boolean, String],
      default: false
    }
  },
  data: function data() {
    return {
      localValue: this.value
    };
  },
  computed: {
    computedSelectSize: function computedSelectSize() {
      // Custom selects with a size of zero causes the arrows to be hidden,
      // so dont render the size attribute in this case
      return !this.plain && this.selectSize === 0 ? null : this.selectSize;
    },
    inputClass: function inputClass() {
      return [this.plain ? "form-control" : "custom-select", this.size && this.plain ? "form-control-".concat(this.size) : null, this.size && !this.plain ? "custom-select-".concat(this.size) : null, this.validClass];
    },
    computedAriaInvalid: function computedAriaInvalid() {
      if (this.ariaInvalid === true || this.ariaInvalid === "true") {
        return "true";
      }

      return this.validClass === "is-invalid" ? "true" : null;
    }
  },
  watch: {
    value: function value(newVal) {
      this.localValue = newVal;
    },
    localValue: function localValue() {
      this.$emit("input", this.localValue);
    }
  },
  methods: {
    focus: function focus() {
      dom_attemptFocus(this.$refs.input);
    },
    blur: function blur() {
      attemptBlur(this.$refs.input);
    },
    onChange: function onChange(evt) {
      var _this = this;

      var target = evt.target;
      var selectedVal = from(target.options).filter(function (o) {
        return o.selected;
      }).map(function (o) {
        return "_value" in o ? o._value : o.value;
      });
      this.localValue = target.multiple ? selectedVal : selectedVal[0];
      this.$nextTick(function () {
        _this.$emit("change", _this.localValue);
      });
    }
  },
  render: function render(h) {
    var name = this.name,
        disabled = this.disabled,
        required = this.required,
        size = this.computedSelectSize,
        value = this.localValue;
    var $options = this.formOptions.map(function (option, index) {
      var value = option.value,
          label = option.label,
          options = option.options,
          disabled = option.disabled;
      var key = "option_".concat(index);
      return isArray(options) ? h(NlyFormSelectOptionGroup, {
        props: {
          label: label,
          options: options
        },
        key: key
      }) : h(NlyFormSelectOption, {
        props: {
          value: value,
          disabled: disabled
        },
        domProps: htmlOrText(option.html, option.text),
        key: key
      });
    });
    return h("select", {
      class: this.inputClass,
      attrs: {
        id: this.safeId(),
        name: name,
        form: this.form || null,
        multiple: this.multiple || null,
        size: size,
        disabled: disabled,
        required: required,
        "aria-required": required ? "true" : null,
        "aria-invalid": this.computedAriaInvalid
      },
      on: {
        change: this.onChange
      },
      directives: [{
        name: "model",
        value: value
      }],
      ref: "input"
    }, [this.normalizeSlot("first"), $options, this.normalizeSlot("default")]);
  }
});
// CONCATENATED MODULE: ./src/components/form-select/index.js




var FormSelectPlugin = plugins_nlyPluginFactory({
  components: {
    NlyFormSelect: NlyFormSelect,
    NlyFormSelectOption: NlyFormSelectOption,
    NlyFormSelectOptionGroup: NlyFormSelectOptionGroup,
    NlySelect: NlyFormSelect,
    NlySelectOption: NlyFormSelectOption,
    NlySelectOptionGroup: NlyFormSelectOptionGroup
  }
});

// CONCATENATED MODULE: ./src/components/grid/row.js





var row_props = {
  tag: {
    type: String,
    default: "div"
  },
  noGutters: {
    type: Boolean,
    default: false
  },
  alignH: {
    type: String,
    default: null,
    validator: function validator(alignH) {
      return nlyGetOptionInclusion(rowAlignHOptions, alignH);
    }
  },
  alignV: {
    type: String,
    default: null,
    validator: function validator(alignV) {
      return nlyGetOptionInclusion(rowAlignVOptions, alignV);
    }
  },
  colsXs: {
    type: [String, Number]
  },
  colsSm: {
    type: [String, Number]
  },
  colsMd: {
    type: [String, Number]
  },
  colsLg: {
    type: [String, Number]
  },
  colsXl: {
    type: [String, Number]
  },
  rowClass: {
    type: String
  }
};

var row_customClass = function customClass(props) {
  var customNoGutters = props.noGutters ? "no-gutters" : "";
  var customColsXs = props.colsXs ? "row-cols-".concat(props.colsXs) : "";
  var customColsSm = props.colsSm ? "row-cols-sm-".concat(props.colsSm) : "";
  var customColsMd = props.colsMd ? "row-cols-md-".concat(props.colsMd) : "";
  var customColsLg = props.colsLg ? "row-cols-lg-".concat(props.colsLg) : "";
  var customColsXl = props.colsXl ? "row-cols-lx-".concat(props.colsXl) : "";
  var customRowClass = props.rowClass;
  var rowAlignHClass = props.alignH != null ? "justify-content-".concat(props.alignH) : null;
  var rowalignVClass = props.alignV != null ? "align-items-".concat(props.alignV) : null;
  return [customNoGutters, rowAlignHClass, rowalignVClass, customColsXs, customColsSm, customColsMd, customColsLg, customColsXl, customRowClass];
};

var row_name = "NlyRow";
var NlyRow = utils_vue.extend({
  name: row_name,
  functional: true,
  props: row_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "row",
      class: row_customClass(props)
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/grid/col.js





var col_props = {
  tag: {
    type: String,
    default: "div"
  },
  col: {
    type: Boolean,
    default: false
  },
  xs: {
    type: [String, Number]
  },
  sm: {
    default: false,
    type: [String, Boolean, Number]
  },
  md: {
    default: false,
    type: [String, Boolean, Number]
  },
  lg: {
    default: false,
    type: [String, Boolean, Number]
  },
  xl: {
    default: false,
    type: [String, Boolean, Number]
  },
  alignSelf: {
    type: String,
    default: null,
    validator: function validator(alignSelf) {
      return nlyGetOptionInclusion(colAlignSelfOptions, alignSelf);
    }
  },
  offsetXs: {
    type: [String, Number]
  },
  offsetSm: {
    type: [String, Number]
  },
  offsetMd: {
    type: [String, Number]
  },
  offsetLg: {
    type: [String, Number]
  },
  offsetXl: {
    type: [String, Number]
  },
  orderXs: {
    type: [String, Number]
  },
  orderSm: {
    type: [String, Number]
  },
  orderMd: {
    type: [String, Number]
  },
  orderLg: {
    type: [String, Number]
  },
  orderXl: {
    type: [String, Number]
  },
  colClass: {
    type: String
  }
};

var col_customClass = function customClass(props) {
  var customCol = props.xs || props.sm === "" || props.md === "" || props.lg === "" || props.xl === "" || props.sm || props.md || props.lg || props.xl ? "" : props.col ? "col" : "";
  var customXs = props.xs ? "col-".concat(props.xs) : "";
  var customSm = props.sm === "" ? "col-sm" : props.sm === true ? "col-sm" : props.sm ? "col-sm-".concat(props.sm) : "";
  var customMd = props.md === "" ? "col-md" : props.md === true ? "col-md" : props.md ? "col-md-".concat(props.md) : "";
  var customLg = props.lg === "" ? "col-lg" : props.lg === true ? "col-lg" : props.lg ? "col-lg-".concat(props.lg) : "";
  var customXl = props.xl === "" ? "col-lg" : props.xl === true ? "col-xl" : props.xl ? "col-xl-".concat(props.xl) : "";
  var customOffsetXs = props.offsetXs === 0 || props.offsetXs ? "offset-".concat(props.offsetXs) : "";
  var customOffsetSm = props.offsetSm === 0 || props.offsetSm ? "offset-sm-".concat(props.offsetSm) : "";
  var customOffsetMd = props.offsetMd === 0 || props.offsetMd ? "offset-md-".concat(props.offsetMd) : "";
  var customOffsetLg = props.offsetLg === 0 || props.offsetLg ? "offset-lg-".concat(props.offsetLg) : "";
  var customOffsetXl = props.offsetXl === 0 || props.offsetXl ? "offset-xl-".concat(props.offsetXl) : "";
  var customOrderXs = props.orderXs === 0 || props.orderXs ? "order-".concat(props.orderXs) : "";
  var customOrderSm = props.orderSm === 0 || props.orderSm ? "order-sm-".concat(props.orderSm) : "";
  var customOrderMd = props.orderMd === 0 || props.orderMd ? "order-md-".concat(props.orderMd) : "";
  var customOrderLg = props.orderLg === 0 || props.orderLg ? "order-lg-".concat(props.orderLg) : "";
  var customOrderXl = props.orderXl === 0 || props.orderXl ? "order-xl-".concat(props.orderXl) : "";
  var customColClass = props.colClass;
  var colAlignSelfClass = props.alignSelf != null ? "align-self-".concat(props.alignSelf) : null;
  return [customCol, customXs, customSm, customMd, customLg, customXl, colAlignSelfClass, customOffsetXs, customOffsetSm, customOffsetMd, customOffsetLg, customOffsetXl, customOrderXs, customOrderSm, customOrderMd, customOrderLg, customOrderXl, customColClass];
};

var col_name = "NlyCol";
var NlyCol = utils_vue.extend({
  name: col_name,
  props: col_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: props.col || props.xs || props.sm || props.md || props.lg || props.xl || props.sm === "" || props.md === "" || props.lg === "" || props.xl === "" ? "" : "col",
      class: col_customClass(props)
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/grid/index.js



var GridPlugin = plugins_nlyPluginFactory({
  components: {
    NlyRow: NlyRow,
    NlyCol: NlyCol
  }
});

// CONCATENATED MODULE: ./src/components/info-box/infobox.js






var infobox_props = {
  bgVariant: {
    type: String
  },
  bgGradientVariant: {
    type: String
  },
  tag: {
    type: String,
    default: "div"
  },
  loading: {
    type: Boolean,
    default: false
  },
  loadingContent: {
    type: String
  },
  loadingContentTag: {
    type: String,
    default: "p"
  },
  loadingContentClass: {
    type: String
  },
  loadingIcon: {
    type: String,
    default: "fas fa-2x fa-sync-alt fa-spin"
  },
  loadingImgSrc: {
    type: String
  },
  loadingImgClass: {
    type: String
  },
  dark: {
    type: Boolean,
    default: false
  }
};

var infobox_customBgVariant = function customBgVariant(props) {
  return nlyGetOptionsByKeyEqual(bgVariantOptions, props.bgVariant);
};

var infobox_customBgGradientVariant = function customBgGradientVariant(props) {
  return nlyGetOptionsByKeyEqual(bgGradientOptions, props.bgGradientVariant);
};

var infobox_name = "NlyInfobox";
var NlyInfobox = utils_vue.extend({
  name: infobox_name,
  functional: true,
  props: infobox_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;

    var overlayArray = function overlayArray() {
      if (props.loadingContent) {
        return h(NlyOverlay, {
          props: {
            custom: true,
            dark: props.dark
          }
        }, [loadingContentArray()]);
      } else {
        return h(NlyOverlay, {
          props: {
            custom: true,
            dark: props.dark
          }
        }, [loadingIcon()]);
      }
    };

    var loadingContentArray = function loadingContentArray() {
      return h(props.loadingContentTag, {
        class: [props.loadingContentClass]
      }, props.loadingContent);
    };

    var loadingIcon = function loadingIcon() {
      return h(NlyIcon, {
        props: {
          icon: props.loadingIcon
        }
      });
    };

    var loadingImgArray = function loadingImgArray() {
      return h("img", {
        attrs: {
          alt: "loading-img",
          src: props.loadingImgSrc
        },
        staticClass: "loading-img",
        class: [props.loadingImgClass]
      });
    };

    var loadingArray = function loadingArray() {
      if (props.loading && !props.loadingImgSrc) {
        return [children, overlayArray()];
      } else if (props.loading && props.loadingImgSrc) {
        return [children, loadingImgArray()];
      } else {
        return children;
      }
    };

    return h(props.tag, lib_esm_a(data, {
      staticClass: "info-box",
      class: [infobox_customBgVariant(props), infobox_customBgGradientVariant(props)]
    }), loadingArray());
  }
});
// CONCATENATED MODULE: ./src/components/info-box/infobox-icon.js





var infobox_icon_props = {
  icon: {
    type: String,
    required: true
  },
  bgVariant: {
    type: String
  },
  bgGradientVariant: {
    type: String
  },
  infoboxIconClass: {
    type: String
  },
  tag: {
    type: String,
    default: "span"
  }
};

var infobox_icon_customClass = function customClass(props) {
  var bgVariant = function bgVariant() {
    return nlyGetOptionsByKeyEqual(bgVariantOptions, props.bgVariant);
  };

  var bgGradientVariant = function bgGradientVariant() {
    return nlyGetOptionsByKeyEqual(bgGradientOptions, props.bgGradientVariant);
  };

  return [bgVariant(), bgGradientVariant(), props.infoboxIconClass];
};

var infobox_icon_name = "NlyInfoboxIcon";
var NlyInfoboxIcon = utils_vue.extend({
  name: infobox_icon_name,
  functional: true,
  props: infobox_icon_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "info-box-icon",
      class: infobox_icon_customClass(props)
    }), [h(NlyIcon, {
      props: {
        icon: props.icon
      }
    })]);
  }
});
// CONCATENATED MODULE: ./src/components/info-box/infobox-text.js


var infobox_text_props = {
  textClass: {
    type: String
  },
  text: {
    type: String
  },
  tag: {
    type: String,
    default: "span"
  }
};
var infobox_text_name = "NlyInfoboxText";
var NlyInfoboxText = utils_vue.extend({
  name: infobox_text_name,
  functional: true,
  props: infobox_text_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "info-box-text",
      class: [props.textClass]
    }), [props.text, children]);
  }
});
// CONCATENATED MODULE: ./src/components/info-box/infobox-number.js




var infobox_number_props = {
  number: {
    type: [String, Number]
  },
  numberClass: {
    type: String
  },
  tag: {
    type: String,
    default: "span"
  }
};
var infobox_number_name = "NlyInfoboxNumber";
var NlyInfoboxNumber = utils_vue.extend({
  name: infobox_number_name,
  functional: true,
  props: infobox_number_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "info-box-number",
      class: [props.numberClass]
    }), [props.number ? number_toCurrency(props.number) : null, children]);
  }
});
// CONCATENATED MODULE: ./src/components/progress/progress-bar.js








var progress_bar_NAME = "NlyProgressBar";
var NlyProgressBar = utils_vue.extend({
  name: progress_bar_NAME,
  mixins: [mixins_normalize_slot],
  inject: {
    NlyyProgress: {
      default: function _default() {
        return {};
      }
    }
  },
  props: {
    value: {
      type: [Number, String],
      default: 0
    },
    label: {
      type: String,
      default: null
    },
    labelHtml: {
      type: String
    },
    max: {
      type: [Number, String],
      default: null
    },
    precision: {
      type: [Number, String],
      default: null
    },
    variant: {
      type: String,
      default: function _default() {
        return getComponentConfig(progress_bar_NAME, "variant");
      }
    },
    striped: {
      type: Boolean,
      default: null
    },
    animated: {
      type: Boolean,
      default: null
    },
    labelValuePercent: {
      type: Boolean,
      default: null
    },
    labelValue: {
      type: Boolean,
      default: null
    },
    progressBarClass: {
      type: String
    }
  },
  computed: {
    customProgressBarClass: function customProgressBarClass() {
      return [this.customVariant ? "bg-".concat(this.customVariant) : "", this.customStriped || this.customAnimated ? "progress-bar-striped" : "", this.customAnimated ? "progress-bar-animated" : "", this.progressBarClass];
    },
    customProgressBarStyle: function customProgressBarStyle() {
      if (this.NlyyProgress.customProps.vertical) {
        return {
          height: 100 * (this.customValue / this.customMax) + "%"
        };
      } else {
        return {
          width: 100 * (this.customValue / this.customMax) + "%"
        };
      }
    },
    customValue: function customValue() {
      return toFloat(this.value) || 0;
    },
    customMax: function customMax() {
      var max = toFloat(this.max);
      return isNaN(max) ? toFloat(this.NlyyProgress.customProps.max) || 100 : max;
    },
    customPrecision: function customPrecision() {
      var precision = toInteger(this.precision);
      return isNaN(precision) ? toInteger(this.NlyyProgress.customProps.precision) || 0 : precision;
    },
    customProgress: function customProgress() {
      var precision = this.customPrecision;
      var p = Math.pow(10, precision);
      return toFixed(100 * p * this.customValue / this.customMax / p, precision);
    },
    customVariant: function customVariant() {
      return this.variant || this.NlyyProgress.customProps.variant;
    },
    customStriped: function customStriped() {
      return isBoolean(this.striped) ? this.striped : this.NlyyProgress.customProps.striped || false;
    },
    customAnimated: function customAnimated() {
      return isBoolean(this.animated) ? this.animated : this.NlyyProgress.customProps.animated || false;
    },
    customLabelValuePercent: function customLabelValuePercent() {
      return isBoolean(this.labelValuePercent) ? this.labelValuePercent : this.NlyyProgress.customProps.labelValuePercent || false;
    },
    customLabelValue: function customLabelValue() {
      return isBoolean(this.labelValue) ? this.labelValue : this.NlyyProgress.customProps.labelValue || false;
    }
  },
  render: function render(h) {
    var childNodes = h();

    if (this.hasNormalizedSlot("default")) {
      childNodes = this.normalizeSlot("default");
    } else if (this.label || this.labelHtml) {
      childNodes = h("span", {
        domProps: htmlOrText(this.labelHtml, this.label)
      });
    } else if (this.customLabelValuePercent) {
      childNodes = "".concat(this.customProgress, "%");
    } else if (this.customLabelValue) {
      childNodes = toFixed(this.customValue, this.customPrecision);
    }

    return h("div", {
      staticClass: "progress-bar",
      class: this.customProgressBarClass,
      style: this.customProgressBarStyle,
      attrs: {
        role: "progressbar",
        "aria-valuemin": "0",
        "aria-valuemax": string_toString(this.customMax),
        "aria-valuenow": toFixed(this.customValue, this.customPrecision)
      }
    }, [childNodes]);
  }
});
// CONCATENATED MODULE: ./src/components/progress/progress.js





var progress_NAME = "NlyProgress";
var NlyProgress = utils_vue.extend({
  name: progress_NAME,
  mixins: [mixins_normalize_slot],
  provide: function provide() {
    return {
      NlyyProgress: this
    };
  },
  props: {
    variant: {
      type: String,
      default: function _default() {
        return getComponentConfig(progress_NAME, "variant");
      }
    },
    vertical: {
      type: Boolean,
      default: false
    },
    size: {
      type: String
    },
    striped: {
      type: Boolean,
      default: false
    },
    height: {
      type: String // default: null

    },
    animated: {
      type: Boolean,
      default: false
    },
    precision: {
      type: [Number, String],
      default: 0
    },
    labelValuePercent: {
      type: Boolean,
      default: false
    },
    labelValue: {
      type: Boolean,
      default: false
    },
    max: {
      type: [Number, String],
      default: 100
    },
    value: {
      type: [Number, String],
      default: 0
    },
    progressClass: {
      type: String
    },
    progressBarClass: {
      type: String
    }
  },
  computed: {
    customProps: function customProps() {
      return {
        variant: this.variant,
        vertical: this.vertical ? "vertical" : "",
        size: this.size ? "progress-".concat(this.size) : "",
        striped: this.striped,
        animated: this.animated,
        precision: this.precision,
        labelValuePercent: this.labelValuePercent,
        labelValue: this.labelValue,
        max: this.max,
        value: this.value,
        progressClass: this.progressClass,
        progressBarClass: this.progressBarClass,
        height: this.height
      };
    }
  },
  render: function render(h) {
    var progressBarArray = this.normalizeSlot("default");

    if (!progressBarArray) {
      progressBarArray = h(NlyProgressBar, {
        props: {
          variant: this.customProps.variant,
          striped: this.customProps.striped,
          animated: this.customProps.animated,
          precision: this.customProps.precision,
          labelValuePercent: this.customProps.labelValuePercent,
          labelValue: this.customProps.labelValue,
          max: this.customProps.max,
          value: this.customProps.value
        },
        class: [this.customProps.progressBarClass]
      });
    }

    return h("div", {
      staticClass: ["progress"],
      class: [this.customProps.vertical, this.customProps.size, this.customProps.progressClass],
      style: {
        height: this.customProps.vertical ? null : this.customProps.height
      }
    }, [progressBarArray]);
  }
});
// CONCATENATED MODULE: ./src/components/progress/progress-description.js

var progress_description_name = "NlyProgressDescription";
var NlyProgressDescription = utils_vue.extend({
  name: progress_description_name,
  props: {
    text: {
      type: String
    }
  },
  computed: {
    customProps: function customProps() {
      return {
        text: this.text
      };
    }
  },
  render: function render(h) {
    var _this = this;

    var textArray = function textArray() {
      if (_this.customProps.text) {
        return [_this.customProps.text, _this.$slots.default];
      } else {
        return [_this.$slots.default];
      }
    };

    return h("span", {
      staticClass: "progress-description"
    }, textArray());
  }
});
// CONCATENATED MODULE: ./src/components/info-box/infobox-body.js










var infobox_body_props = {
  bgVariant: {
    type: String
  },
  bgGradientVariant: {
    type: String
  },
  infoboxBodyClass: {
    type: String
  },
  text: {
    type: String
  },
  textClass: {
    type: String
  },
  number: {
    type: [String, Number]
  },
  numberClass: {
    type: String
  },
  progressValue: {
    type: [String, Number]
  },
  progressDescription: {
    type: String
  },
  tag: {
    type: String,
    default: "div"
  }
};

var infobox_body_customClass = function customClass(props) {
  var bgVariant = function bgVariant() {
    return nlyGetOptionsByKeyEqual(bgVariantOptions, props.bgVariant);
  };

  var bgGradientVariant = function bgGradientVariant() {
    return nlyGetOptionsByKeyEqual(bgGradientOptions, props.bgGradientVariant);
  };

  var infoboxBodyClass = props.infoboxBodyClass;
  return [bgVariant(), bgGradientVariant(), infoboxBodyClass];
};

var infobox_body_name = "NlyInfoboxBody";
var NlyInfoboxBody = utils_vue.extend({
  name: infobox_body_name,
  props: infobox_body_props,
  functional: true,
  computed: {
    customProps: function customProps() {
      return {
        bgVariant: nlyGetOptionsByKeyEqual(bgVariantOptions, this.bgVariant),
        bgGradientVariant: nlyGetOptionsByKeyEqual(bgGradientOptions, this.bgGradientVariant),
        infoboxBodyClass: this.infoboxBodyClass,
        text: this.text,
        textClass: this.textClass,
        number: this.number ? number_toCurrency(this.number) : "",
        numberClass: this.numberClass,
        progressValue: this.progressValue,
        progressDescription: this.progressDescription
      };
    }
  },
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;

    var textArray = function textArray() {
      if (props.text) {
        return h(NlyInfoboxText, {
          props: {
            textClass: props.textClass,
            text: props.text
          }
        });
      }
    };

    var numberArray = function numberArray() {
      if (props.number) {
        return h(NlyInfoboxNumber, {
          props: {
            numberClass: props.numberClass,
            number: props.number
          }
        });
      }
    };

    var progressArray = function progressArray() {
      if (props.progressValue) {
        return h(NlyProgress, {
          props: {
            value: props.progressValue
          }
        });
      }
    };

    var progressDescriptionArray = function progressDescriptionArray() {
      if (props.progressDescription) {
        return h(NlyProgressDescription, {
          props: {
            text: props.progressDescription
          }
        });
      }
    };

    return h(props.tag, lib_esm_a(data, {
      staticClass: "info-box-content",
      class: infobox_body_customClass(props)
    }), [textArray(), numberArray(), progressArray(), progressDescriptionArray(), children]);
  }
});
// CONCATENATED MODULE: ./src/components/info-box/index.js






var InfoboxPlugin = plugins_nlyPluginFactory({
  components: {
    NlyInfobox: NlyInfobox,
    NlyInfoboxIcon: NlyInfoboxIcon,
    NlyInfoboxBody: NlyInfoboxBody,
    NlyInfoboxText: NlyInfoboxText,
    NlyInfoboxNumber: NlyInfoboxNumber
  }
});

// CONCATENATED MODULE: ./src/components/input-group/input-group-add.js



var input_group_add_name = "NlyInputGroupAdd";
var input_group_add_props = {
  tag: {
    type: String,
    default: "div"
  },
  id: {
    type: String,
    default: null
  },
  isText: {
    type: Boolean,
    default: false
  },
  addClass: {
    type: String,
    default: null
  },
  textTag: {
    type: String,
    default: "span"
  },
  textClass: {
    type: String,
    default: null
  },
  append: {
    type: Boolean,
    default: false
  }
};
var NlyInputGroupAdd = utils_vue.extend({
  name: input_group_add_name,
  props: input_group_add_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;

    if (props.isText) {
      return h(props.tag, lib_esm_a(data, {
        staticClass: props.append ? "input-group-append" : "input-group-prepend",
        class: [props.addClass],
        attrs: {
          id: props.id
        }
      }), [h(NlyInputGroupText, {
        props: {
          tag: props.textTag,
          textClass: props.textClass
        }
      }, children)]);
    } else {
      return h(props.tag, lib_esm_a(data, {
        staticClass: props.append ? "input-group-append" : "input-group-prepend",
        class: [props.addClass],
        attrs: {
          id: props.id
        }
      }), children);
    }
  }
});
// CONCATENATED MODULE: ./src/components/input-group/index.js






var InputGroupoPlugin = plugins_nlyPluginFactory({
  components: {
    NlyInputGroupText: NlyInputGroupText,
    NlyInputGroupAdd: NlyInputGroupAdd,
    NlyInputGroup: NlyInputGroup,
    NlyInputGroupAppend: NlyInputGroupAppend,
    NlyInputGroupPrepend: NlyInputGroupPrepend
  }
});

// CONCATENATED MODULE: ./src/components/link/index.js


var LinkPlugin = plugins_nlyPluginFactory({
  components: {
    NlyLink: NlyLink
  }
});

// CONCATENATED MODULE: ./src/components/list-group/list-group.js




var list_group_props = {
  tag: {
    type: String,
    default: "div"
  },
  flush: {
    type: Boolean,
    default: false
  },
  horizontal: {
    type: [Boolean, String],
    default: false
  }
};
var list_group_name = "NlyListGroup";
var NlyListGroup = utils_vue.extend({
  name: list_group_name,
  functional: true,
  props: list_group_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    var horizontal = props.horizontal === "" ? true : props.horizontal;
    horizontal = props.flush ? false : horizontal;
    var componentData = {
      staticClass: "list-group",
      class: Object(defineProperty["a" /* default */])({
        "list-group-flush": props.flush,
        "list-group-horizontal": horizontal === true
      }, "list-group-horizontal-".concat(horizontal), isString(horizontal))
    };
    return h(props.tag, lib_esm_a(data, componentData), children);
  }
});
// CONCATENATED MODULE: ./src/components/list-group/list-group-item.js








var list_group_item_NAME = "NlyListGroupItem";
var actionTags = ["a", "router-link", "button", "nly-link"];
var list_group_item_linkProps = propsFactory();
delete list_group_item_linkProps.href.default;
delete list_group_item_linkProps.to.default;
var list_group_item_props = Object(objectSpread2["a" /* default */])({
  tag: {
    type: String,
    default: "div"
  },
  action: {
    type: Boolean,
    default: null
  },
  button: {
    type: Boolean,
    default: null
  },
  variant: {
    type: String,
    default: function _default() {
      return getComponentConfig(list_group_item_NAME, "variant");
    }
  },
  bgGradientVariant: {
    type: String
  }
}, list_group_item_linkProps);
var NlyListGroupItem = utils_vue.extend({
  name: list_group_item_NAME,
  functional: true,
  props: list_group_item_props,
  render: function render(h, _ref) {
    var _class;

    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    var tag = props.button ? "button" : !props.href && !props.to ? props.tag : NlyLink;
    var isAction = Boolean(props.href || props.to || props.action || props.button || arrayIncludes(actionTags, props.tag));
    var attrs = {};
    var itemProps = {};

    if (tag === "button") {
      if (!data.attrs || !data.attrs.type) {
        // Add a type for button is one not provided in passed attributes
        attrs.type = "button";
      }

      if (props.disabled) {
        // Set disabled attribute if button and disabled
        attrs.disabled = true;
      }
    } else {
      itemProps = pluck_props(list_group_item_linkProps, props);
    }

    var componentData = {
      attrs: attrs,
      props: itemProps,
      staticClass: "list-group-item",
      class: (_class = {}, Object(defineProperty["a" /* default */])(_class, "list-group-item-".concat(props.variant), props.variant), Object(defineProperty["a" /* default */])(_class, "list-group-item-action", isAction), Object(defineProperty["a" /* default */])(_class, "bg-gradient-".concat(props.bgGradientVariant), props.bgGradientVariant), Object(defineProperty["a" /* default */])(_class, "active", props.active), Object(defineProperty["a" /* default */])(_class, "disabled", props.disabled), _class)
    };
    return h(tag, lib_esm_a(data, componentData), children);
  }
});
// CONCATENATED MODULE: ./src/components/list-group/index.js



var ListGroupPlugin = plugins_nlyPluginFactory({
  components: {
    NlyListGroup: NlyListGroup,
    NlyListGroupItem: NlyListGroupItem
  }
});

// CONCATENATED MODULE: ./src/components/log/log-line.js



var log_line_name = "NlyLogLine";
var log_line_props = {
  duration: {
    type: String
  },
  durationClass: {
    type: String
  },
  line: {
    type: [String, Number]
  },
  lineClass: {
    type: String
  },
  text: {
    type: String
  },
  textClass: {
    type: String
  },
  title: {
    type: String
  },
  titleClass: {
    type: String
  },
  icon: {
    type: String
  },
  iconClass: {
    type: String
  },
  logLineClass: {
    type: String
  },
  highLight: {
    type: Boolean,
    default: false
  },
  tag: {
    type: String,
    default: "div"
  }
};
var NlyLogLine = utils_vue.extend({
  name: log_line_name,
  props: log_line_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;

    var durationVnodes = function durationVnodes() {
      if (props.duration) {
        return h("span", {
          staticClass: "duration",
          class: [props.durationClass]
        }, props.duration);
      }
    };

    var lineVnodes = function lineVnodes() {
      if (props.line || props.line === 0) {
        return h("span", {
          staticClass: "index",
          class: [props.lineClass]
        }, props.line);
      }
    };

    var textVnodes = function textVnodes() {
      if (props.text) {
        return h("span", {
          staticClass: "text",
          class: [props.textClass]
        }, props.text);
      } else {
        return h("span", {
          class: [props.textClass]
        }, children);
      }
    };

    var titleVnodes = function titleVnodes() {
      if (props.title) {
        return h("span", {
          staticClass: "title",
          class: [props.titleClass]
        }, props.title);
      }
    };

    var iconVnode = function iconVnode() {
      if (props.icon) {
        return h("span", {
          staticClass: "left",
          class: [props.icon, props.iconClass]
        });
      }
    };

    return h(props.tag, lib_esm_a(data, {
      staticClass: "nly-log-line",
      class: [props.logLineClass, props.highLight ? "nly-log-line-highlight" : ""]
    }), [iconVnode(), lineVnodes(), durationVnodes(), titleVnodes(), textVnodes()]);
  }
});
// CONCATENATED MODULE: ./src/components/log/log-line-tree.js






var log_line_tree_EVENT_TOGGLE = "nlya::toggle::collapse";
var log_line_tree_EVENT_STATE = "nlya::collapse::state";
var log_line_tree_EVENT_STATE_SYNC = "nlya::collapse::sync::state";
var log_line_tree_name = "NlyLogLineTree";
var NlyLogLineTree = utils_vue.extend({
  name: log_line_tree_name,
  model: {
    prop: "visible",
    event: "input"
  },
  mixins: [listen_on_root, mixins_id],
  data: function data() {
    return {
      toggleState: this.visible
    };
  },
  props: {
    duration: {
      type: String
    },
    durationClass: {
      type: String
    },
    line: {
      type: String
    },
    lineClass: {
      type: String
    },
    text: {
      type: String
    },
    textClass: {
      type: String
    },
    title: {
      type: String
    },
    titleClass: {
      type: String
    },
    icon: {
      type: String,
      default: "nlyfont nly-icon-arrow-bottom"
    },
    iconClass: {
      type: String
    },
    visible: {
      type: Boolean,
      default: false
    },
    logLineClass: {
      type: String
    },
    highLight: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    customLogLineProps: function customLogLineProps() {
      return {
        duration: this.duration,
        durationClass: this.durationClass,
        line: this.line,
        lineClass: this.lineClass,
        text: this.text,
        textClass: this.textClass,
        title: this.title,
        titleClass: this.titleClass,
        icon: this.icon,
        iconClass: this.iconClass,
        logLineClass: this.logLineClass,
        highLight: this.highLight
      };
    },
    customVisible: function customVisible() {
      return this.visible;
    }
  },
  created: function created() {
    // 监听root 事件，获取初始toggleState值
    this.listenOnRoot(log_line_tree_EVENT_STATE, this.handleStateEvt);
    this.listenOnRoot(log_line_tree_EVENT_STATE_SYNC, this.handleStateEvt);
  },
  methods: {
    onClick: function onClick(evt) {
      this.$emit("click", evt);

      if (!evt.defaultPrevented) {
        this.$root.$emit(log_line_tree_EVENT_TOGGLE, this.safeId());
      }
    },
    handleStateEvt: function handleStateEvt(id, state) {
      if (id === this.safeId()) {
        this.toggleState = state;
      }
    }
  },
  render: function render(h) {
    var treeVnodes = h(NlyCollapse, {
      attrs: {
        id: this.safeId()
      },
      style: {
        display: this.customVisible ? "block" : "none"
      }
    }, this.$slots.default);
    var logLineVnodes = h(NlyLink, {
      staticClass: "tree",
      on: {
        click: this.onClick
      }
    }, [h(NlyLogLine, {
      props: this.customLogLineProps
    })]);
    return h("div", {
      staticClass: "nly-log-line-tree",
      class: this.toggleState ? "open" : "collapsed",
      style: {
        cursor: "pointer"
      }
    }, [logLineVnodes, treeVnodes]);
  }
});
// CONCATENATED MODULE: ./src/components/log/log-header.js


var log_header_name = "NlyLogHeader";
var log_header_props = {
  title: {
    type: String
  },
  titleClass: {
    type: String
  },
  logHeaderClass: {
    type: String
  },
  tag: {
    type: String,
    default: "div"
  },
  titleTag: {
    type: String,
    default: "div"
  }
};
var NlyLogHeader = utils_vue.extend({
  name: log_header_name,
  props: log_header_props,
  functional: true,
  computed: {
    customTitle: function customTitle() {
      return this.title;
    },
    customTitleClass: function customTitleClass() {
      return this.titleClass;
    },
    customHeaderClass: function customHeaderClass() {
      return this.logHeaderClass;
    }
  },
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;

    var headerVnodes = function headerVnodes() {
      if (props.title) {
        return h(props.tag, lib_esm_a(data, {
          staticClass: "nly-log-header",
          class: [props.logHeaderClass]
        }), [h(props.titleTag, {
          staticClass: "nly-log-header-title",
          class: [props.titleClass]
        }, props.title), children]);
      } else {
        return h(props.tag, {
          staticClass: "nly-log-header",
          class: [props.logHeaderClass]
        }, children);
      }
    };

    return headerVnodes();
  }
});
// CONCATENATED MODULE: ./src/components/log/log-tools.js


var log_tools_name = "NlyLogTools";
var log_tools_props = {
  tag: {
    type: String,
    default: "div"
  },
  logToolsClass: {
    type: String
  }
};
var NlyLogTools = utils_vue.extend({
  name: log_tools_name,
  props: log_tools_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "nly-log-tools",
      class: [props.logToolsClass]
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/log/log-body.js



 // import { NlyLogAddTransitionGroup } from "../../utils/log-add-transition-group";


 // import { OverlayScrollbarsComponent } from "overlayscrollbars-vue";

var log_body_name = "NlyLogBody";
var NlyLogBody = utils_vue.extend({
  name: log_body_name,
  mixins: [mixins_id],
  data: function data() {
    return {
      lockBottom: false
    };
  },
  props: {
    scrollBottom: {
      type: Boolean,
      default: true
    },
    scrollTop: {
      type: Boolean,
      default: true
    },
    logBodyClass: {
      type: String
    },
    preClass: {
      type: String
    },
    bottomIcon: {
      type: String,
      default: "nlyfont nly-icon-logo-ionic"
    },
    bottomText: {
      type: String,
      default: "滚动到底部"
    },
    lockScrollBottom: {
      type: Boolean,
      default: true
    },
    lockBottomIcon: {
      type: String,
      default: "nlyfont nly-icon-logo-ionic"
    },
    lockBottomText: {
      type: String,
      default: "锁定底部"
    },
    topIcon: {
      type: String,
      default: "nlyfont nly-icon-logo-aperture"
    },
    topText: {
      type: String,
      default: "Top"
    }
  },
  computed: {
    customProps: function customProps() {
      return {
        scrollBottom: this.scrollBottom,
        scrollTop: this.scrollTop,
        logBodyClass: this.logBodyClass,
        preClass: this.preClass,
        topIcon: this.topIcon,
        topText: this.topText,
        bottomIcon: this.bottomIcon,
        bottomText: this.bottomText,
        lockScrollBottom: this.lockScrollBottom,
        lockBottomIcon: this.lockBottomIcon,
        lockBottomText: this.lockBottomText
      };
    }
  },
  mounted: function mounted() {},
  methods: {
    scrollBottomFunction: function scrollBottomFunction() {
      var preRef = "".concat(this.safeId(), "_pre");
      this.$refs[preRef].osInstance().scroll({
        y: "100%"
      }, 1000);
    },
    scrollTopFunction: function scrollTopFunction() {
      var preRef = "".concat(this.safeId(), "_pre");
      this.$refs[preRef].osInstance().scroll({
        y: "0%"
      }, 1000);
      this.lockBottom = false;
    },
    lockscrollBar: function lockscrollBar() {
      var _this = this;

      if (this.lockBottom === true) {
        this.$nextTick(function () {
          var preRef = "".concat(_this.safeId(), "_pre");

          _this.$refs[preRef].osInstance().scroll({
            y: "100%"
          }, 500);
        });
      }
    },
    lockScrollBottomFunction: function lockScrollBottomFunction() {
      this.lockBottom = this.lockBottom ? false : true;
    }
  },
  render: function render(h) {
    var _this2 = this;

    var bottomVnodes = function bottomVnodes() {
      if (_this2.customProps.scrollBottom) {
        return h(NlyLink, {
          staticClass: "nly-log-tail",
          on: {
            click: _this2.scrollBottomFunction
          }
        }, [h(NlyIcon, {
          staticClass: "tail-status",
          props: {
            icon: _this2.customProps.bottomIcon
          }
        }), h("span", {
          staticClass: "tail-label"
        }, [h("svg", {
          staticClass: "icon-arrow",
          attrs: {
            viewBox: "0 0 15 15"
          }
        }, [h("path", {
          attrs: {
            d: "M7.549.5v12.924m5.549-4.473L7.549 14.5 2 8.951"
          }
        })]), _this2.customProps.bottomText])]);
      }
    };

    var lockBottomVnodes = function lockBottomVnodes() {
      if (_this2.customProps.lockScrollBottom) {
        return h(NlyLink, {
          staticClass: "nly-log-tail",
          on: {
            click: _this2.lockScrollBottomFunction
          }
        }, [h(NlyIcon, {
          staticClass: "tail-status",
          props: {
            icon: _this2.customProps.lockBottomIcon
          }
        }), h("span", {
          staticClass: "tail-label"
        }, [h("svg", {
          staticClass: "icon-arrow",
          attrs: {
            viewBox: "0 0 15 15"
          }
        }, [h("path", {
          attrs: {
            d: "M7.549.5v12.924m5.549-4.473L7.549 14.5 2 8.951"
          }
        })]), _this2.customProps.lockBottomText])]);
      }
    };

    var preVnodes = function preVnodes() {
      return h(__vue_component__, {
        ref: "".concat(_this2.safeId(), "_pre"),
        staticClass: "nly-log-body-pre",
        props: {
          options: {
            className: "os-theme-light",
            scrollbars: {
              autoHide: "scroll"
            },
            callbacks: {
              onOverflowAmountChanged: _this2.lockscrollBar()
            }
          }
        }
      }, _this2.$slots.default);
    };

    var topVnodes = function topVnodes() {
      if (_this2.customProps.scrollTop) {
        return h(NlyLink, {
          staticClass: "to-top",
          on: {
            click: _this2.scrollTopFunction
          }
        }, [_this2.customProps.topText, h(NlyIcon, {
          class: [_this2.customProps.topIcon]
        })]);
      }
    };

    return h("div", {
      staticClass: "nly-log-body",
      ref: this.safeId()
    }, [bottomVnodes(), lockBottomVnodes(), preVnodes(), topVnodes()]);
  }
});
// CONCATENATED MODULE: ./src/components/log/log.js


var log_name = "NlyLog";
var log_props = {
  tag: {
    type: String,
    default: "div"
  },
  logClass: {
    type: String
  },
  containerClass: {
    type: String
  },
  containerTag: {
    type: String,
    default: "div"
  }
};
var NlyLog = utils_vue.extend({
  name: log_name,
  props: log_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "nly-log",
      class: [props.logClass]
    }), [h(props.containerTag, {
      staticClass: "nly-log-container",
      class: [props.containerClass]
    }, children)]);
  }
});
// CONCATENATED MODULE: ./src/components/log/index.js







var LogPlugin = plugins_nlyPluginFactory({
  components: {
    NlyLogLine: NlyLogLine,
    NlyLogLineTree: NlyLogLineTree,
    NlyLogHeader: NlyLogHeader,
    NlyLogTools: NlyLogTools,
    NlyLogBody: NlyLogBody,
    NlyLog: NlyLog
  }
});

// CONCATENATED MODULE: ./src/utils/observe-dom.js



/**
 * Observe a DOM element changes, falls back to eventListener mode
 * @param {Element} el The DOM element to observe
 * @param {Function} callback callback to be called on change
 * @param {object} [options={childList: true, subtree: true}] observe options
 * @see https://stackoverflow.com/questions/3219758
 */

var observe_dom_observeDom = function observeDom(el, callback, options)
/* istanbul ignore next: difficult to test in JSDOM */
{
  // Handle cases where we might be passed a Vue instance
  el = el ? el.$el || el : null; // Early exit when we have no element

  /* istanbul ignore next: difficult to test in JSDOM */

  if (!isElement(el)) {
    return null;
  } // Exit and throw a warning when `MutationObserver` isn't available


  if (warn_warnNoMutationObserverSupport("observeDom")) {
    return null;
  } // Define a new observer


  var obs = new MutationObs(function (mutations) {
    var changed = false; // A mutation can contain several change records, so we loop
    // through them to see what has changed
    // We break out of the loop early if any "significant" change
    // has been detected

    for (var i = 0; i < mutations.length && !changed; i++) {
      // The mutation record
      var mutation = mutations[i]; // Mutation type

      var type = mutation.type; // DOM node (could be any DOM node type - HTMLElement, Text, comment, etc.)

      var target = mutation.target; // Detect whether a change happened based on type and target

      if (type === "characterData" && target.nodeType === Node.TEXT_NODE) {
        // We ignore nodes that are not TEXT (i.e. comments, etc)
        // as they don't change layout
        changed = true;
      } else if (type === "attributes") {
        changed = true;
      } else if (type === "childList" && (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0)) {
        // This includes HTMLElement and text nodes being
        // added/removed/re-arranged
        changed = true;
      }
    } // We only call the callback if a change that could affect
    // layout/size truely happened


    if (changed) {
      callback();
    }
  }); // Have the observer observe foo for changes in children, etc

  obs.observe(el, Object(objectSpread2["a" /* default */])({
    childList: true,
    subtree: true
  }, options)); // We return a reference to the observer so that `obs.disconnect()`
  // can be called if necessary
  // To reduce overhead when the root element is hidden

  return obs;
};

/* harmony default export */ var observe_dom = (observe_dom_observeDom);
// CONCATENATED MODULE: ./src/utils/transporter.js









var NlyTransporterTargetSingle = utils_vue.extend({
  abstract: true,
  name: "NlyTransporterTargetSingle",
  props: {
    nodes: {
      type: [Array, Function]
    }
  },
  data: function data(vm) {
    return {
      updatedNodes: vm.nodes
    };
  },
  destroyed: function destroyed() {
    removeNode(this.$el);
  },
  render: function render(h) {
    var nodes = isFunction(this.updatedNodes) ? this.updatedNodes({}) : this.updatedNodes;
    nodes = concat(nodes).filter(Boolean);

    if (nodes && nodes.length > 0 && !nodes[0].text) {
      return nodes[0];
    } else {
      return h();
    }
  }
});
var NlyTransporterSingle = utils_vue.extend({
  name: "NlyTransporterSingle",
  mixins: [mixins_normalize_slot],
  props: {
    disabled: {
      type: Boolean,
      default: false
    },
    container: {
      type: [String, safe_types_HTMLElement],
      default: "body"
    },
    tag: {
      type: String,
      default: "div"
    }
  },
  watch: {
    disabled: {
      immediate: true,
      handler: function handler(disabled) {
        disabled ? this.unmountTarget() : this.$nextTick(this.mountTarget);
      }
    }
  },
  created: function created() {
    this._nlya_defaultFn = null;
    this._nlya_target = null;
  },
  beforeMount: function beforeMount() {
    this.mountTarget();
  },
  updated: function updated() {
    this.updateTarget();
  },
  beforeDestroy: function beforeDestroy() {
    this.unmountTarget();
    this._nlya_defaultFn = null;
  },
  methods: {
    getContainer: function getContainer() {
      if (env["g" /* isBrowser */]) {
        var container = this.container;
        return isString(container) ? dom_select(container) : container;
      } else {
        return null;
      }
    },
    mountTarget: function mountTarget() {
      if (!this._nlya_target) {
        var container = this.getContainer();

        if (container) {
          var el = document.createElement("div");
          container.appendChild(el);
          this._nlya_target = new NlyTransporterTargetSingle({
            el: el,
            parent: this,
            propsData: {
              nodes: concat(this.normalizeSlot("default"))
            }
          });
        }
      }
    },
    // Update the content of the target
    updateTarget: function updateTarget() {
      if (env["g" /* isBrowser */] && this._nlya_target) {
        var defaultFn = this.$scopedSlots.default;

        if (!this.disabled) {
          if (defaultFn && this._nlya_defaultFn !== defaultFn) {
            this._nlya_target.updatedNodes = defaultFn;
          } else if (!defaultFn) {
            this._nlya_target.updatedNodes = this.$slots.default;
          }
        }

        this._nlya_defaultFn = defaultFn;
      }
    },
    // Unmount the target
    unmountTarget: function unmountTarget() {
      if (this._nlya_target) {
        this._nlya_target.$destroy();

        this._nlya_target = null;
      }
    }
  },
  render: function render(h) {
    if (this.disabled) {
      var nodes = concat(this.normalizeSlot("default")).filter(utils_identity);

      if (nodes.length > 0 && !nodes[0].text) {
        return nodes[0];
      }
    }

    return h();
  }
});
// CONCATENATED MODULE: ./src/mixins/listen-on-document.js








var PROP = "$_nlya_documentHandlers_";
/* harmony default export */ var listen_on_document = ({
  created: function created() {
    var _this = this;

    if (!env["g" /* isBrowser */]) {
      return;
    }

    this[PROP] = {};
    this.$once("hook:beforeDestroy", function () {
      var items = _this[PROP] || {};
      delete _this[PROP];
      keys(items).forEach(function (evtName) {
        var handlers = items[evtName] || [];
        handlers.forEach(function (handler) {
          return eventOff(document, evtName, handler, EVENT_OPTIONS_NO_CAPTURE);
        });
      });
    });
  },
  methods: {
    listenDocument: function listenDocument(on, evtName, handler) {
      on ? this.listenOnDocument(evtName, handler) : this.listenOffDocument(evtName, handler);
    },
    listenOnDocument: function listenOnDocument(evtName, handler) {
      if (this[PROP] && isString(evtName) && isFunction(handler)) {
        this[PROP][evtName] = this[PROP][evtName] || [];

        if (!arrayIncludes(this[PROP][evtName], handler)) {
          this[PROP][evtName].push(handler);
          eventOn(document, evtName, handler, EVENT_OPTIONS_NO_CAPTURE);
        }
      }
    },
    listenOffDocument: function listenOffDocument(evtName, handler) {
      if (this[PROP] && isString(evtName) && isFunction(handler)) {
        eventOff(document, evtName, handler, EVENT_OPTIONS_NO_CAPTURE);
        this[PROP][evtName] = (this[PROP][evtName] || []).filter(function (h) {
          return h !== handler;
        });
      }
    }
  }
});
// CONCATENATED MODULE: ./src/mixins/listen-on-window.js








var listen_on_window_PROP = "$_nlya_windowHandlers_"; // @vue/component

/* harmony default export */ var listen_on_window = ({
  beforeCreate: function beforeCreate() {
    // Declare non-reactive property
    // Object of arrays, keyed by event name,
    // where value is an array of handlers
    this[listen_on_window_PROP] = {};
  },
  beforeDestroy: function beforeDestroy() {
    if (env["g" /* isBrowser */]) {
      var items = this[listen_on_window_PROP]; // Immediately delete this[PROP] to prevent the
      // listenOn/Off methods from running (which may occur
      // due to requestAnimationFrame delays)

      delete this[listen_on_window_PROP]; // Remove all registered event handlers

      keys(items).forEach(function (evtName) {
        var handlers = items[evtName] || [];
        handlers.forEach(function (handler) {
          return eventOff(window, evtName, handler, EVENT_OPTIONS_NO_CAPTURE);
        });
      });
    }
  },
  methods: {
    listenWindow: function listenWindow(on, evtName, handler) {
      on ? this.listenOnWindow(evtName, handler) : this.listenOffWindow(evtName, handler);
    },
    listenOnWindow: function listenOnWindow(evtName, handler) {
      if (env["g" /* isBrowser */] && this[listen_on_window_PROP] && isString(evtName) && isFunction(handler)) {
        this[listen_on_window_PROP][evtName] = this[listen_on_window_PROP][evtName] || [];

        if (!arrayIncludes(this[listen_on_window_PROP][evtName], handler)) {
          this[listen_on_window_PROP][evtName].push(handler);
          eventOn(window, evtName, handler, EVENT_OPTIONS_NO_CAPTURE);
        }
      }
    },
    listenOffWindow: function listenOffWindow(evtName, handler) {
      if (env["g" /* isBrowser */] && this[listen_on_window_PROP] && isString(evtName) && isFunction(handler)) {
        eventOff(window, evtName, handler, EVENT_OPTIONS_NO_CAPTURE);
        this[listen_on_window_PROP][evtName] = (this[listen_on_window_PROP][evtName] || []).filter(function (h) {
          return h !== handler;
        });
      }
    }
  }
});
// CONCATENATED MODULE: ./src/utils/get-scope-id.js
var getScopeId = function getScopeId(vm) {
  var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return vm ? vm.$options._scopeId || defaultValue : defaultValue;
};

/* harmony default export */ var get_scope_id = (getScopeId);
// CONCATENATED MODULE: ./src/mixins/scoped-style-attrs.js


/* harmony default export */ var scoped_style_attrs = ({
  computed: {
    scopedStyleAttrs: function scopedStyleAttrs() {
      var scopeId = get_scope_id(this.$parent);
      return scopeId ? Object(defineProperty["a" /* default */])({}, scopeId, "") : {};
    }
  }
});
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.splice.js
var es_array_splice = __webpack_require__("a434");

// CONCATENATED MODULE: ./src/components/modal/helpers/modal-manager.js









var DEFAULT_ZINDEX = 1040;
var modal_manager_Selector = {
  FIXED_CONTENT: ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
  STICKY_CONTENT: ".sticky-top",
  NAVBAR_TOGGLER: ".navbar-toggler"
};
var ModalManager = utils_vue.extend({
  data: function data() {
    return {
      modals: [],
      baseZIndex: null,
      scrollbarWidth: null,
      isBodyOverflowing: false
    };
  },
  computed: {
    modalCount: function modalCount() {
      return this.modals.length;
    },
    modalsAreOpen: function modalsAreOpen() {
      return this.modalCount > 0;
    }
  },
  watch: {
    modalCount: function modalCount(newCount, oldCount) {
      if (env["g" /* isBrowser */]) {
        this.getScrollbarWidth();

        if (newCount > 0 && oldCount === 0) {
          // Transitioning to modal(s) open
          this.checkScrollbar();
          this.setScrollbar();
          addClass(document.body, "modal-open");
        } else if (newCount === 0 && oldCount > 0) {
          // Transitioning to modal(s) closed
          this.resetScrollbar();
          removeClass(document.body, "modal-open");
        }

        setAttr(document.body, "data-modal-open-count", String(newCount));
      }
    },
    modals: function modals(newVal) {
      var _this = this;

      this.checkScrollbar();
      requestAF(function () {
        _this.updateModals(newVal || []);
      });
    }
  },
  methods: {
    // Public methods
    registerModal: function registerModal(modal) {
      var _this2 = this;

      // Register the modal if not already registered
      if (modal && this.modals.indexOf(modal) === -1) {
        // Add modal to modals array
        this.modals.push(modal);
        modal.$once("hook:beforeDestroy", function () {
          _this2.unregisterModal(modal);
        });
      }
    },
    unregisterModal: function unregisterModal(modal) {
      var index = this.modals.indexOf(modal);

      if (index > -1) {
        // Remove modal from modals array
        this.modals.splice(index, 1); // Reset the modal's data

        if (!(modal._isBeingDestroyed || modal._isDestroyed)) {
          this.resetModal(modal);
        }
      }
    },
    getBaseZIndex: function getBaseZIndex() {
      if (isNull(this.baseZIndex) && env["g" /* isBrowser */]) {
        // Create a temporary `div.modal-backdrop` to get computed z-index
        var div = document.createElement("div");
        div.className = "modal-backdrop d-none";
        div.style.display = "none";
        document.body.appendChild(div);
        this.baseZIndex = toInteger(dom_getCS(div).zIndex, DEFAULT_ZINDEX);
        document.body.removeChild(div);
      }

      return this.baseZIndex || DEFAULT_ZINDEX;
    },
    getScrollbarWidth: function getScrollbarWidth() {
      if (isNull(this.scrollbarWidth) && env["g" /* isBrowser */]) {
        // Create a temporary `div.measure-scrollbar` to get computed z-index
        var div = document.createElement("div");
        div.className = "modal-scrollbar-measure";
        document.body.appendChild(div);
        this.scrollbarWidth = getBCR(div).width - div.clientWidth;
        document.body.removeChild(div);
      }

      return this.scrollbarWidth || 0;
    },
    // Private methods
    updateModals: function updateModals(modals) {
      var _this3 = this;

      var baseZIndex = this.getBaseZIndex();
      var scrollbarWidth = this.getScrollbarWidth();
      modals.forEach(function (modal, index) {
        // We update data values on each modal
        modal.zIndex = baseZIndex + index;
        modal.scrollbarWidth = scrollbarWidth;
        modal.isTop = index === _this3.modals.length - 1;
        modal.isBodyOverflowing = _this3.isBodyOverflowing;
      });
    },
    resetModal: function resetModal(modal) {
      if (modal) {
        modal.zIndex = this.getBaseZIndex();
        modal.isTop = true;
        modal.isBodyOverflowing = false;
      }
    },
    checkScrollbar: function checkScrollbar() {
      // Determine if the body element is overflowing
      var _getBCR = getBCR(document.body),
          left = _getBCR.left,
          right = _getBCR.right;

      this.isBodyOverflowing = left + right < window.innerWidth;
    },
    setScrollbar: function setScrollbar() {
      var body = document.body; // Storage place to cache changes to margins and padding
      // Note: This assumes the following element types are not added to the
      // document after the modal has opened.

      body._paddingChangedForModal = body._paddingChangedForModal || [];
      body._marginChangedForModal = body._marginChangedForModal || [];

      if (this.isBodyOverflowing) {
        var scrollbarWidth = this.scrollbarWidth; // Adjust fixed content padding

        /* istanbul ignore next: difficult to test in JSDOM */

        dom_selectAll(modal_manager_Selector.FIXED_CONTENT).forEach(function (el) {
          var actualPadding = el.style.paddingRight;
          setAttr(el, "data-padding-right", actualPadding);
          el.style.paddingRight = "".concat(toFloat(dom_getCS(el).paddingRight, 0) + scrollbarWidth, "px");

          body._paddingChangedForModal.push(el);
        }); // Adjust sticky content margin

        /* istanbul ignore next: difficult to test in JSDOM */

        dom_selectAll(modal_manager_Selector.STICKY_CONTENT).forEach(function (el)
        /* istanbul ignore next */
        {
          var actualMargin = el.style.marginRight;
          setAttr(el, "data-margin-right", actualMargin);
          el.style.marginRight = "".concat(toFloat(dom_getCS(el).marginRight, 0) - scrollbarWidth, "px");

          body._marginChangedForModal.push(el);
        }); // Adjust <b-navbar-toggler> margin

        /* istanbul ignore next: difficult to test in JSDOM */

        dom_selectAll(modal_manager_Selector.NAVBAR_TOGGLER).forEach(function (el)
        /* istanbul ignore next */
        {
          var actualMargin = el.style.marginRight;
          setAttr(el, "data-margin-right", actualMargin);
          el.style.marginRight = "".concat(toFloat(dom_getCS(el).marginRight, 0) + scrollbarWidth, "px");

          body._marginChangedForModal.push(el);
        }); // Adjust body padding

        var actualPadding = body.style.paddingRight;
        setAttr(body, "data-padding-right", actualPadding);
        body.style.paddingRight = "".concat(toFloat(dom_getCS(body).paddingRight, 0) + scrollbarWidth, "px");
      }
    },
    resetScrollbar: function resetScrollbar() {
      var body = document.body;

      if (body._paddingChangedForModal) {
        // Restore fixed content padding
        body._paddingChangedForModal.forEach(function (el) {
          /* istanbul ignore next: difficult to test in JSDOM */
          if (hasAttr(el, "data-padding-right")) {
            el.style.paddingRight = getAttr(el, "data-padding-right") || "";
            removeAttr(el, "data-padding-right");
          }
        });
      }

      if (body._marginChangedForModal) {
        // Restore sticky content and navbar-toggler margin
        body._marginChangedForModal.forEach(function (el) {
          /* istanbul ignore next: difficult to test in JSDOM */
          if (hasAttr(el, "data-margin-right")) {
            el.style.marginRight = getAttr(el, "data-margin-right") || "";
            removeAttr(el, "data-margin-right");
          }
        });
      }

      body._paddingChangedForModal = null;
      body._marginChangedForModal = null; // Restore body padding

      if (hasAttr(body, "data-padding-right")) {
        body.style.paddingRight = getAttr(body, "data-padding-right") || "";
        removeAttr(body, "data-padding-right");
      }
    }
  }
}); // Create and export our modal manager instance

var modalManager = new ModalManager();
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.reflect.get.js
var es_reflect_get = __webpack_require__("5d41");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/superPropBase.js

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/get.js



function esm_get_get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    esm_get_get = Reflect.get;
  } else {
    esm_get_get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return esm_get_get(target, property, receiver || target);
}
// CONCATENATED MODULE: ./src/components/modal/helpers/nly-modal-event.class.js











var nly_modal_event_class_NlyaModalEvent = /*#__PURE__*/function (_NlyEvent) {
  _inherits(NlyaModalEvent, _NlyEvent);

  var _super = _createSuper(NlyaModalEvent);

  function NlyaModalEvent(type) {
    var _this;

    var eventInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, NlyaModalEvent);

    _this = _super.call(this, type, eventInit); // Freeze our new props as readonly, but leave them enumerable

    defineProperties(_assertThisInitialized(_this), {
      trigger: readonlyDescriptor()
    });
    return _this;
  }

  _createClass(NlyaModalEvent, null, [{
    key: "Defaults",
    get: function get() {
      return Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, esm_get_get(_getPrototypeOf(NlyaModalEvent), "Defaults", this)), {}, {
        trigger: null
      });
    }
  }]);

  return NlyaModalEvent;
}(nly_event_class_NlyEvent); // Named exports



// CONCATENATED MODULE: ./src/components/modal/modal.js





























 // --- Constants ---

var modal_NAME = "NlyModal";
var OBSERVER_CONFIG = {
  subtree: true,
  childList: true,
  characterData: true,
  attributes: true,
  attributeFilter: ["style", "class"]
}; // Query selector to find all tabbable elements
// (includes tabindex="-1", which we filter out after)

var modal_TABABLE_SELECTOR = ["button", "[href]:not(.disabled)", "input", "select", "textarea", "[tabindex]", "[contenteditable]"].map(function (s) {
  return "".concat(s, ":not(:disabled):not([disabled])");
}).join(", "); // --- Utility methods ---
// Attempt to focus an element, and return true if successful

var modal_attemptFocus = function attemptFocus(el) {
  if (el && isVisible(el) && el.focus) {
    try {
      el.focus(); // eslint-disable-next-line no-empty
    } catch (_unused) {}
  } // If the element has focus, then return true


  return document.activeElement === el;
}; // --- Props ---


var modal_props = {
  size: {
    type: String,
    default: function _default() {
      return getComponentConfig(modal_NAME, "size");
    }
  },
  centered: {
    type: Boolean,
    default: false
  },
  scrollable: {
    type: Boolean,
    default: false
  },
  buttonSize: {
    type: String // default: ''

  },
  noStacking: {
    type: Boolean,
    default: false
  },
  noFade: {
    type: Boolean,
    default: false
  },
  noCloseOnBackdrop: {
    type: Boolean,
    default: false
  },
  noCloseOnEsc: {
    type: Boolean,
    default: false
  },
  noEnforceFocus: {
    type: Boolean,
    default: false
  },
  ignoreEnforceFocusSelector: {
    type: [Array, String],
    default: ""
  },
  title: {
    type: String,
    default: ""
  },
  titleHtml: {
    type: String
  },
  titleTag: {
    type: String,
    default: function _default() {
      return getComponentConfig(modal_NAME, "titleTag");
    }
  },
  titleClass: {
    type: [String, Array, Object] // default: null

  },
  titleSrOnly: {
    type: Boolean,
    default: false
  },
  ariaLabel: {
    type: String // default: null

  },
  headerBgVariant: {
    type: String,
    default: function _default() {
      return getComponentConfig(modal_NAME, "headerBgVariant");
    }
  },
  headerBorderVariant: {
    type: String,
    default: function _default() {
      return getComponentConfig(modal_NAME, "headerBorderVariant");
    }
  },
  headerTextVariant: {
    type: String,
    default: function _default() {
      return getComponentConfig(modal_NAME, "headerTextVariant");
    }
  },
  headerCloseVariant: {
    type: String,
    default: function _default() {
      return getComponentConfig(modal_NAME, "headerCloseVariant");
    }
  },
  headerClass: {
    type: [String, Array, Object] // default: null

  },
  bodyBgVariant: {
    type: String,
    default: function _default() {
      return getComponentConfig(modal_NAME, "bodyBgVariant");
    }
  },
  bodyTextVariant: {
    type: String,
    default: function _default() {
      return getComponentConfig(modal_NAME, "bodyTextVariant");
    }
  },
  modalClass: {
    type: [String, Array, Object] // default: null

  },
  dialogClass: {
    type: [String, Array, Object] // default: null

  },
  contentClass: {
    type: [String, Array, Object] // default: null

  },
  bodyClass: {
    type: [String, Array, Object] // default: null

  },
  footerBgVariant: {
    type: String,
    default: function _default() {
      return getComponentConfig(modal_NAME, "footerBgVariant");
    }
  },
  footerBorderVariant: {
    type: String,
    default: function _default() {
      return getComponentConfig(modal_NAME, "footerBorderVariant");
    }
  },
  footerTextVariant: {
    type: String,
    default: function _default() {
      return getComponentConfig(modal_NAME, "footerTextVariant");
    }
  },
  footerClass: {
    type: [String, Array, Object] // default: null

  },
  // TODO: Rename to `noHeader` and deprecate `hideHeader`
  hideHeader: {
    type: Boolean,
    default: false
  },
  // TODO: Rename to `noFooter` and deprecate `hideFooter`
  hideFooter: {
    type: Boolean,
    default: false
  },
  // TODO: Rename to `noHeaderClose` and deprecate `hideHeaderClose`
  hideHeaderClose: {
    type: Boolean,
    default: false
  },
  // TODO: Rename to `noBackdrop` and deprecate `hideBackdrop`
  hideBackdrop: {
    type: Boolean,
    default: false
  },
  okOnly: {
    type: Boolean,
    default: false
  },
  okDisabled: {
    type: Boolean,
    default: false
  },
  cancelDisabled: {
    type: Boolean,
    default: false
  },
  visible: {
    type: Boolean,
    default: false
  },
  returnFocus: {
    // HTML Element, CSS selector string or Vue component instance
    type: [safe_types_HTMLElement, String, Object],
    default: null
  },
  headerCloseContent: {
    type: String,
    default: function _default() {
      return getComponentConfig(modal_NAME, "headerCloseContent");
    }
  },
  headerCloseLabel: {
    type: String,
    default: function _default() {
      return getComponentConfig(modal_NAME, "headerCloseLabel");
    }
  },
  cancelTitle: {
    type: String,
    default: function _default() {
      return getComponentConfig(modal_NAME, "cancelTitle");
    }
  },
  cancelTitleHtml: {
    type: String
  },
  okTitle: {
    type: String,
    default: function _default() {
      return getComponentConfig(modal_NAME, "okTitle");
    }
  },
  okTitleHtml: {
    type: String
  },
  cancelVariant: {
    type: String,
    default: function _default() {
      return getComponentConfig(modal_NAME, "cancelVariant");
    }
  },
  okVariant: {
    type: String,
    default: function _default() {
      return getComponentConfig(modal_NAME, "okVariant");
    }
  },
  lazy: {
    type: Boolean,
    default: false
  },
  busy: {
    type: Boolean,
    default: false
  },
  static: {
    type: Boolean,
    default: false
  },
  autoFocusButton: {
    type: String,
    default: null,
    validator: function validator(val) {
      /* istanbul ignore next */
      return isUndefinedOrNull(val) || arrayIncludes(["ok", "cancel", "close"], val);
    }
  }
}; // @vue/component

var NlyModal = /*#__PURE__*/utils_vue.extend({
  name: modal_NAME,
  mixins: [mixins_id, listen_on_document, listen_on_root, listen_on_window, mixins_normalize_slot, scoped_style_attrs],
  inheritAttrs: false,
  model: {
    prop: "visible",
    event: "change"
  },
  props: modal_props,
  data: function data() {
    return {
      isHidden: true,
      // If modal should not be in document
      isVisible: false,
      // Controls modal visible state
      isTransitioning: false,
      // Used for style control
      isShow: false,
      // Used for style control
      isBlock: false,
      // Used for style control
      isOpening: false,
      // To signal that the modal is in the process of opening
      isClosing: false,
      // To signal that the modal is in the process of closing
      ignoreBackdropClick: false,
      // Used to signify if click out listener should ignore the click
      isModalOverflowing: false,
      return_focus: this.returnFocus || null,
      // The following items are controlled by the modalManager instance
      scrollbarWidth: 0,
      zIndex: modalManager.getBaseZIndex(),
      isTop: true,
      isBodyOverflowing: false
    };
  },
  computed: {
    modalClasses: function modalClasses() {
      return [{
        fade: !this.noFade,
        show: this.isShow
      }, this.modalClass];
    },
    modalStyles: function modalStyles() {
      var sbWidth = "".concat(this.scrollbarWidth, "px");
      return {
        paddingLeft: !this.isBodyOverflowing && this.isModalOverflowing ? sbWidth : "",
        paddingRight: this.isBodyOverflowing && !this.isModalOverflowing ? sbWidth : "",
        // Needed to fix issue https://github.com/bootstrap-vue/bootstrap-vue/issues/3457
        // Even though we are using v-show, we must ensure 'none' is restored in the styles
        display: this.isBlock ? "block" : "none"
      };
    },
    dialogClasses: function dialogClasses() {
      var _ref;

      return [(_ref = {}, Object(defineProperty["a" /* default */])(_ref, "modal-".concat(this.size), this.size), Object(defineProperty["a" /* default */])(_ref, "modal-dialog-centered", this.centered), Object(defineProperty["a" /* default */])(_ref, "modal-dialog-scrollable", this.scrollable), _ref), this.dialogClass];
    },
    headerClasses: function headerClasses() {
      var _ref2;

      return [(_ref2 = {}, Object(defineProperty["a" /* default */])(_ref2, "bg-".concat(this.headerBgVariant), this.headerBgVariant), Object(defineProperty["a" /* default */])(_ref2, "text-".concat(this.headerTextVariant), this.headerTextVariant), Object(defineProperty["a" /* default */])(_ref2, "border-".concat(this.headerBorderVariant), this.headerBorderVariant), _ref2), this.headerClass];
    },
    titleClasses: function titleClasses() {
      return [{
        "sr-only": this.titleSrOnly
      }, this.titleClass];
    },
    bodyClasses: function bodyClasses() {
      var _ref3;

      return [(_ref3 = {}, Object(defineProperty["a" /* default */])(_ref3, "bg-".concat(this.bodyBgVariant), this.bodyBgVariant), Object(defineProperty["a" /* default */])(_ref3, "text-".concat(this.bodyTextVariant), this.bodyTextVariant), _ref3), this.bodyClass];
    },
    footerClasses: function footerClasses() {
      var _ref4;

      return [(_ref4 = {}, Object(defineProperty["a" /* default */])(_ref4, "bg-".concat(this.footerBgVariant), this.footerBgVariant), Object(defineProperty["a" /* default */])(_ref4, "text-".concat(this.footerTextVariant), this.footerTextVariant), Object(defineProperty["a" /* default */])(_ref4, "border-".concat(this.footerBorderVariant), this.footerBorderVariant), _ref4), this.footerClass];
    },
    modalOuterStyle: function modalOuterStyle() {
      // Styles needed for proper stacking of modals
      return {
        position: "absolute",
        zIndex: this.zIndex
      };
    },
    slotScope: function slotScope() {
      return {
        ok: this.onOk,
        cancel: this.onCancel,
        close: this.onClose,
        hide: this.hide,
        visible: this.isVisible
      };
    },
    computeIgnoreEnforceFocusSelector: function computeIgnoreEnforceFocusSelector() {
      // Normalize to an single selector with selectors separated by `,`
      return concat(this.ignoreEnforceFocusSelector).filter(utils_identity).join(",").trim();
    }
  },
  watch: {
    visible: function visible(newVal, oldVal) {
      if (newVal !== oldVal) {
        this[newVal ? "show" : "hide"]();
      }
    }
  },
  created: function created() {
    // Define non-reactive properties
    this._observer = null;
  },
  mounted: function mounted() {
    // Set initial z-index as queried from the DOM
    this.zIndex = modalManager.getBaseZIndex(); // Listen for events from others to either open or close ourselves
    // and listen to all modals to enable/disable enforce focus

    this.listenOnRoot("nlya::show::modal", this.showHandler);
    this.listenOnRoot("nlya::hide::modal", this.hideHandler);
    this.listenOnRoot("nlya::toggle::modal", this.toggleHandler); // Listen for `nlya:modal::show events`, and close ourselves if the
    // opening modal not us

    this.listenOnRoot("nlya::modal::show", this.modalListener); // Initially show modal?

    if (this.visible === true) {
      this.$nextTick(this.show);
    }
  },
  beforeDestroy: function beforeDestroy() {
    // Ensure everything is back to normal
    if (this._observer) {
      this._observer.disconnect();

      this._observer = null;
    }

    if (this.isVisible) {
      this.isVisible = false;
      this.isShow = false;
      this.isTransitioning = false;
    }
  },
  methods: {
    // Private method to update the v-model
    updateModel: function updateModel(val) {
      if (val !== this.visible) {
        this.$emit("change", val);
      }
    },
    // Private method to create a nlyaModalEvent object
    buildEvent: function buildEvent(type) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new nly_modal_event_class_NlyaModalEvent(type, Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({
        // Default options
        cancelable: false,
        target: this.$refs.modal || this.$el || null,
        relatedTarget: null,
        trigger: null
      }, options), {}, {
        // Options that can't be overridden
        vueTarget: this,
        componentId: this.safeId()
      }));
    },
    // Public method to show modal
    show: function show() {
      if (this.isVisible || this.isOpening) {
        // If already open, or in the process of opening, do nothing

        /* istanbul ignore next */
        return;
      }
      /* istanbul ignore next */


      if (this.isClosing) {
        // If we are in the process of closing, wait until hidden before re-opening

        /* istanbul ignore next */
        this.$once("hidden", this.show);
        /* istanbul ignore next */

        return;
      }

      this.isOpening = true; // Set the element to return focus to when closed

      this.return_focus = this.return_focus || this.getActiveElement();
      var showEvt = this.buildEvent("show", {
        cancelable: true
      });
      this.emitEvent(showEvt); // Don't show if canceled

      if (showEvt.defaultPrevented || this.isVisible) {
        this.isOpening = false; // Ensure the v-model reflects the current state

        this.updateModel(false);
        return;
      } // Show the modal


      this.doShow();
    },
    // Public method to hide modal
    hide: function hide() {
      var trigger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

      if (!this.isVisible || this.isClosing) {
        /* istanbul ignore next */
        return;
      }

      this.isClosing = true;
      var hideEvt = this.buildEvent("hide", {
        cancelable: trigger !== "FORCE",
        trigger: trigger || null
      }); // We emit specific event for one of the three built-in buttons

      if (trigger === "ok") {
        this.$emit("ok", hideEvt);
      } else if (trigger === "cancel") {
        this.$emit("cancel", hideEvt);
      } else if (trigger === "headerclose") {
        this.$emit("close", hideEvt);
      }

      this.emitEvent(hideEvt); // Hide if not canceled

      if (hideEvt.defaultPrevented || !this.isVisible) {
        this.isClosing = false; // Ensure v-model reflects current state

        this.updateModel(true);
        return;
      } // Stop observing for content changes


      if (this._observer) {
        this._observer.disconnect();

        this._observer = null;
      } // Trigger the hide transition


      this.isVisible = false; // Update the v-model

      this.updateModel(false);
    },
    // Public method to toggle modal visibility
    toggle: function toggle(triggerEl) {
      if (triggerEl) {
        this.return_focus = triggerEl;
      }

      if (this.isVisible) {
        this.hide("toggle");
      } else {
        this.show();
      }
    },
    // Private method to get the current document active element
    getActiveElement: function getActiveElement() {
      if (env["g" /* isBrowser */]) {
        var activeElement = document.activeElement; // Note: On IE 11, `document.activeElement` may be null.
        // So we test it for truthiness first.
        // https://github.com/bootstrap-vue/bootstrap-vue/issues/3206
        // Returning focus to document.body may cause unwanted scrolls, so we
        // exclude setting focus on body

        if (activeElement && activeElement !== document.body && activeElement.focus) {
          // Preset the fallback return focus value if it is not set
          // `document.activeElement` should be the trigger element that was clicked or
          // in the case of using the v-model, which ever element has current focus
          // Will be overridden by some commands such as toggle, etc.
          return activeElement;
        }
      }

      return null;
    },
    // Private method to get a list of all tabable elements within modal content
    getTabables: function getTabables() {
      // Find all tabable elements in the modal content
      // Assumes users have not used tabindex > 0 on elements!
      return dom_selectAll(modal_TABABLE_SELECTOR, this.$refs.content).filter(isVisible).filter(function (i) {
        return i.tabIndex > -1 && !i.disabled;
      });
    },
    // Private method to finish showing modal
    doShow: function doShow() {
      var _this = this;

      /* istanbul ignore next: commenting out for now until we can test stacking */
      if (modalManager.modalsAreOpen && this.noStacking) {
        // If another modal(s) is already open, wait for it(them) to close
        this.listenOnRootOnce("nlya::modal::hidden", this.doShow);
        return;
      }

      modalManager.registerModal(this); // Place modal in DOM

      this.isHidden = false;
      this.$nextTick(function () {
        // We do this in `$nextTick()` to ensure the modal is in DOM first
        // before we show it
        _this.isVisible = true;
        _this.isOpening = false; // Update the v-model

        _this.updateModel(true);

        _this.$nextTick(function () {
          // In a nextTick in case modal content is lazy
          // Observe changes in modal content and adjust if necessary
          _this._observer = observe_dom(_this.$refs.content, _this.checkModalOverflow.bind(_this), OBSERVER_CONFIG);
        });
      });
    },
    // Transition handlers
    onBeforeEnter: function onBeforeEnter() {
      this.isTransitioning = true;
      this.setResizeEvent(true);
    },
    onEnter: function onEnter() {
      var _this2 = this;

      this.isBlock = true; // We add the `show` class 1 frame later
      // `requestAF()` runs the callback before the next repaint, so we need
      // two calls to guarantee the next frame has been rendered

      requestAF(function () {
        requestAF(function () {
          _this2.isShow = true;
        });
      });
    },
    onAfterEnter: function onAfterEnter() {
      var _this3 = this;

      this.checkModalOverflow();
      this.isTransitioning = false; // We use `requestAF()` to allow transition hooks to complete
      // before passing control over to the other handlers
      // This will allow users to not have to use `$nextTick()` or `requestAF()`
      // when trying to pre-focus an element

      requestAF(function () {
        _this3.emitEvent(_this3.buildEvent("shown"));

        _this3.setEnforceFocus(true);

        _this3.$nextTick(function () {
          // Delayed in a `$nextTick()` to allow users time to pre-focus
          // an element if the wish
          _this3.focusFirst();
        });
      });
    },
    onBeforeLeave: function onBeforeLeave() {
      this.isTransitioning = true;
      this.setResizeEvent(false);
      this.setEnforceFocus(false);
    },
    onLeave: function onLeave() {
      // Remove the 'show' class
      this.isShow = false;
    },
    onAfterLeave: function onAfterLeave() {
      var _this4 = this;

      this.isBlock = false;
      this.isTransitioning = false;
      this.isModalOverflowing = false;
      this.isHidden = true;
      this.$nextTick(function () {
        _this4.isClosing = false;
        modalManager.unregisterModal(_this4);

        _this4.returnFocusTo(); // TODO: Need to find a way to pass the `trigger` property
        //       to the `hidden` event, not just only the `hide` event


        _this4.emitEvent(_this4.buildEvent("hidden"));
      });
    },
    // Event emitter
    emitEvent: function emitEvent(nlyaModalEvt) {
      var type = nlyaModalEvt.type; // We emit on root first incase a global listener wants to cancel
      // the event first before the instance emits its event

      this.emitOnRoot("nlya::modal::".concat(type), nlyaModalEvt, nlyaModalEvt.componentId);
      this.$emit(type, nlyaModalEvt);
    },
    // UI event handlers
    onDialogMousedown: function onDialogMousedown() {
      var _this5 = this;

      // Watch to see if the matching mouseup event occurs outside the dialog
      // And if it does, cancel the clickOut handler
      var modal = this.$refs.modal;

      var onceModalMouseup = function onceModalMouseup(evt) {
        eventOff(modal, "mouseup", onceModalMouseup, EVENT_OPTIONS_NO_CAPTURE);

        if (evt.target === modal) {
          _this5.ignoreBackdropClick = true;
        }
      };

      eventOn(modal, "mouseup", onceModalMouseup, EVENT_OPTIONS_NO_CAPTURE);
    },
    onClickOut: function onClickOut(evt) {
      if (this.ignoreBackdropClick) {
        // Click was initiated inside the modal content, but finished outside.
        // Set by the above onDialogMousedown handler
        this.ignoreBackdropClick = false;
        return;
      } // Do nothing if not visible, backdrop click disabled, or element
      // that generated click event is no longer in document body


      if (!this.isVisible || this.noCloseOnBackdrop || !dom_contains(document.body, evt.target)) {
        return;
      } // If backdrop clicked, hide modal


      if (!dom_contains(this.$refs.content, evt.target)) {
        this.hide("backdrop");
      }
    },
    onOk: function onOk() {
      this.hide("ok");
    },
    onCancel: function onCancel() {
      this.hide("cancel");
    },
    onClose: function onClose() {
      this.hide("headerclose");
    },
    onEsc: function onEsc(evt) {
      // If ESC pressed, hide modal
      if (evt.keyCode === key_codes.ESC && this.isVisible && !this.noCloseOnEsc) {
        this.hide("esc");
      }
    },
    // Document focusin listener
    focusHandler: function focusHandler(evt) {
      // If focus leaves modal content, bring it back
      var content = this.$refs.content;
      var target = evt.target;

      if (this.noEnforceFocus || !this.isTop || !this.isVisible || !content || document === target || dom_contains(content, target) || this.computeIgnoreEnforceFocusSelector && closest(this.computeIgnoreEnforceFocusSelector, target, true)) {
        return;
      }

      var tabables = this.getTabables();
      var _this$$refs = this.$refs,
          bottomTrap = _this$$refs.bottomTrap,
          topTrap = _this$$refs.topTrap;

      if (bottomTrap && target === bottomTrap) {
        // If user pressed TAB out of modal into our bottom trab trap element
        // Find the first tabable element in the modal content and focus it
        if (modal_attemptFocus(tabables[0])) {
          // Focus was successful
          return;
        }
      } else if (topTrap && target === topTrap) {
        // If user pressed CTRL-TAB out of modal and into our top tab trap element
        // Find the last tabable element in the modal content and focus it
        if (modal_attemptFocus(tabables[tabables.length - 1])) {
          // Focus was successful
          return;
        }
      } // Otherwise focus the modal content container


      content.focus({
        preventScroll: true
      });
    },
    // Turn on/off focusin listener
    setEnforceFocus: function setEnforceFocus(on) {
      this.listenDocument(on, "focusin", this.focusHandler);
    },
    // Resize listener
    setResizeEvent: function setResizeEvent(on) {
      this.listenWindow(on, "resize", this.checkModalOverflow);
      this.listenWindow(on, "orientationchange", this.checkModalOverflow);
    },
    // Root listener handlers
    showHandler: function showHandler(id, triggerEl) {
      if (id === this.safeId()) {
        this.return_focus = triggerEl || this.getActiveElement();
        this.show();
      }
    },
    hideHandler: function hideHandler(id) {
      if (id === this.safeId()) {
        this.hide("event");
      }
    },
    toggleHandler: function toggleHandler(id, triggerEl) {
      if (id === this.safeId()) {
        this.toggle(triggerEl);
      }
    },
    modalListener: function modalListener(nlyaEvt) {
      // If another modal opens, close this one if stacking not permitted
      if (this.noStacking && nlyaEvt.vueTarget !== this) {
        this.hide();
      }
    },
    // Focus control handlers
    focusFirst: function focusFirst() {
      var _this6 = this;

      // Don't try and focus if we are SSR
      if (env["g" /* isBrowser */]) {
        requestAF(function () {
          var modal = _this6.$refs.modal;
          var content = _this6.$refs.content;

          var activeElement = _this6.getActiveElement(); // If the modal contains the activeElement, we don't do anything


          if (modal && content && !(activeElement && dom_contains(content, activeElement))) {
            var ok = _this6.$refs["ok-button"];
            var cancel = _this6.$refs["cancel-button"];
            var close = _this6.$refs["close-button"]; // Focus the appropriate button or modal content wrapper

            var autoFocus = _this6.autoFocusButton;
            var el = autoFocus === "ok" && ok ? ok.$el || ok : autoFocus === "cancel" && cancel ? cancel.$el || cancel : autoFocus === "close" && close ? close.$el || close : content; // Focus the element

            modal_attemptFocus(el);

            if (el === content) {
              // Make sure top of modal is showing (if longer than the viewport)
              _this6.$nextTick(function () {
                modal.scrollTop = 0;
              });
            }
          }
        });
      }
    },
    returnFocusTo: function returnFocusTo() {
      // Prefer `returnFocus` prop over event specified
      // `return_focus` value
      var el = this.returnFocus || this.return_focus || null;
      this.return_focus = null;
      this.$nextTick(function () {
        // Is el a string CSS selector?
        el = isString(el) ? dom_select(el) : el;

        if (el) {
          // Possibly could be a component reference
          el = el.$el || el;
          modal_attemptFocus(el);
        }
      });
    },
    checkModalOverflow: function checkModalOverflow() {
      if (this.isVisible) {
        var modal = this.$refs.modal;
        this.isModalOverflowing = modal.scrollHeight > document.documentElement.clientHeight;
      }
    },
    makeModal: function makeModal(h) {
      // Modal header
      var header = h();

      if (!this.hideHeader) {
        // TODO: Rename slot to `header` and deprecate `modal-header`
        var modalHeader = this.normalizeSlot("modal-header", this.slotScope);

        if (!modalHeader) {
          var closeButton = h();

          if (!this.hideHeaderClose) {
            closeButton = h(NlyButtonClose, {
              ref: "close-button",
              props: {
                content: this.headerCloseContent,
                disabled: this.isTransitioning,
                ariaLabel: this.headerCloseLabel,
                textVariant: this.headerCloseVariant || this.headerTextVariant
              },
              on: {
                click: this.onClose
              }
            }, // TODO: Rename slot to `header-close` and deprecate `modal-header-close`
            [this.normalizeSlot("modal-header-close")]);
          }

          var domProps = // TODO: Rename slot to `title` and deprecate `modal-title`
          !this.hasNormalizedSlot("modal-title") && this.titleHtml ? {
            innerHTML: this.titleHtml
          } : {};
          modalHeader = [h(this.titleTag, {
            staticClass: "modal-title",
            class: this.titleClasses,
            attrs: {
              id: this.safeId("__nlya_modal_title_")
            },
            domProps: domProps
          }, // TODO: Rename slot to `title` and deprecate `modal-title`
          [this.normalizeSlot("modal-title", this.slotScope) || stripTags(this.title)]), closeButton];
        }

        header = h("header", {
          ref: "header",
          staticClass: "modal-header",
          class: this.headerClasses,
          attrs: {
            id: this.safeId("__nlya_modal_header_")
          }
        }, [modalHeader]);
      } // Modal body


      var body = h("div", {
        ref: "body",
        staticClass: "modal-body",
        class: this.bodyClasses,
        attrs: {
          id: this.safeId("__nlya_modal_body_")
        }
      }, this.normalizeSlot("default", this.slotScope)); // Modal footer

      var footer = h();

      if (!this.hideFooter) {
        // TODO: Rename slot to `footer` and deprecate `modal-footer`
        var modalFooter = this.normalizeSlot("modal-footer", this.slotScope);

        if (!modalFooter) {
          var cancelButton = h();

          if (!this.okOnly) {
            var cancelHtml = this.cancelTitleHtml ? {
              innerHTML: this.cancelTitleHtml
            } : null;
            cancelButton = h(NlyButton, {
              ref: "cancel-button",
              props: {
                variant: this.cancelVariant,
                size: this.buttonSize,
                disabled: this.cancelDisabled || this.busy || this.isTransitioning
              },
              on: {
                click: this.onCancel
              }
            }, [// TODO: Rename slot to `cancel-button` and deprecate `modal-cancel`
            this.normalizeSlot("modal-cancel") || (cancelHtml ? h("span", {
              domProps: cancelHtml
            }) : stripTags(this.cancelTitle))]);
          }

          var okHtml = this.okTitleHtml ? {
            innerHTML: this.okTitleHtml
          } : null;
          var okButton = h(NlyButton, {
            ref: "ok-button",
            props: {
              variant: this.okVariant,
              size: this.buttonSize,
              disabled: this.okDisabled || this.busy || this.isTransitioning
            },
            on: {
              click: this.onOk
            }
          }, [// TODO: Rename slot to `ok-button` and deprecate `modal-ok`
          this.normalizeSlot("modal-ok") || (okHtml ? h("span", {
            domProps: okHtml
          }) : stripTags(this.okTitle))]);
          modalFooter = [cancelButton, okButton];
        }

        footer = h("footer", {
          ref: "footer",
          staticClass: "modal-footer",
          class: this.footerClasses,
          attrs: {
            id: this.safeId("__nlya_modal_footer_")
          }
        }, [modalFooter]);
      } // Assemble modal content


      var modalContent = h("div", {
        ref: "content",
        staticClass: "modal-content",
        class: this.contentClass,
        attrs: {
          role: "document",
          id: this.safeId("__nlya_modal_content_"),
          tabindex: "-1"
        }
      }, [header, body, footer]); // Tab trap to prevent page from scrolling to next element in
      // tab index during enforce focus tab cycle

      var tabTrapTop = h();
      var tabTrapBottom = h();

      if (this.isVisible && !this.noEnforceFocus) {
        tabTrapTop = h("span", {
          ref: "topTrap",
          attrs: {
            tabindex: "0"
          }
        });
        tabTrapBottom = h("span", {
          ref: "bottomTrap",
          attrs: {
            tabindex: "0"
          }
        });
      } // Modal dialog wrapper


      var modalDialog = h("div", {
        ref: "dialog",
        staticClass: "modal-dialog",
        class: this.dialogClasses,
        on: {
          mousedown: this.onDialogMousedown
        }
      }, [tabTrapTop, modalContent, tabTrapBottom]); // Modal

      var modal = h("div", {
        ref: "modal",
        staticClass: "modal",
        class: this.modalClasses,
        style: this.modalStyles,
        directives: [{
          name: "show",
          rawName: "v-show",
          value: this.isVisible,
          expression: "isVisible"
        }],
        attrs: {
          id: this.safeId(),
          role: "dialog",
          "aria-hidden": this.isVisible ? null : "true",
          "aria-modal": this.isVisible ? "true" : null,
          "aria-label": this.ariaLabel,
          "aria-labelledby": this.hideHeader || this.ariaLabel || // TODO: Rename slot to `title` and deprecate `modal-title`
          !(this.hasNormalizedSlot("modal-title") || this.titleHtml || this.title) ? null : this.safeId("__nlya_modal_title_"),
          "aria-describedby": this.safeId("__nlya_modal_body_")
        },
        on: {
          keydown: this.onEsc,
          click: this.onClickOut
        }
      }, [modalDialog]); // Wrap modal in transition
      // Sadly, we can't use nlyaTransition here due to the differences in
      // transition durations for .modal and .modal-dialog. Not until
      // issue https://github.com/vuejs/vue/issues/9986 is resolved

      modal = h("transition", {
        props: {
          enterClass: "",
          enterToClass: "",
          enterActiveClass: "",
          leaveClass: "",
          leaveActiveClass: "",
          leaveToClass: ""
        },
        on: {
          beforeEnter: this.onBeforeEnter,
          enter: this.onEnter,
          afterEnter: this.onAfterEnter,
          beforeLeave: this.onBeforeLeave,
          leave: this.onLeave,
          afterLeave: this.onAfterLeave
        }
      }, [modal]); // Modal backdrop

      var backdrop = h();

      if (!this.hideBackdrop && this.isVisible) {
        backdrop = h("div", {
          staticClass: "modal-backdrop",
          attrs: {
            id: this.safeId("__nlya_modal_backdrop_")
          }
        }, // TODO: Rename slot to `backdrop` and deprecate `modal-backdrop`
        [this.normalizeSlot("modal-backdrop")]);
      }

      backdrop = h(nly_toast_transition, {
        props: {
          noFade: this.noFade
        }
      }, [backdrop]); // If the parent has a scoped style attribute, and the modal
      // is portalled, add the scoped attribute to the modal wrapper

      var scopedStyleAttrs = !this.static ? this.scopedStyleAttrs : {}; // Assemble modal and backdrop in an outer <div>

      return h("div", {
        key: "modal-outer-".concat(this._uid),
        style: this.modalOuterStyle,
        attrs: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, scopedStyleAttrs), this.$attrs), {}, {
          id: this.safeId("__nlya_modal_outer_")
        })
      }, [modal, backdrop]);
    }
  },
  render: function render(h) {
    if (this.static) {
      return this.lazy && this.isHidden ? h() : this.makeModal(h);
    } else {
      return this.isHidden ? h() : h(NlyTransporterSingle, [this.makeModal(h)]);
    }
  }
});
// CONCATENATED MODULE: ./src/components/modal/helpers/nlya-modal.js










// Plugin for adding `$nlyaModal` property to all Vue instances






 // --- Constants ---

var nlya_modal_PROP_NAME = "$nlyaModal";
var PROP_NAME_PRIV = "_nlya__modal"; // Base modal props that are allowed
// Some may be ignored or overridden on some message boxes
// Prop ID is allowed, but really only should be used for testing
// We need to add it in explicitly as it comes from the `idMixin`

var BASE_PROPS = ["id"].concat(_toConsumableArray(keys(object_omit(modal_props, ["busy", "lazy", "noStacking", "static", "visible"])))); // Fallback event resolver (returns undefined)

var defaultResolver = function defaultResolver() {}; // Map prop names to modal slot names


var propsToSlots = {
  msgBoxContent: "default",
  title: "modal-title",
  okTitle: "modal-ok",
  cancelTitle: "modal-cancel"
}; // --- Utility methods ---
// Method to filter only recognized props that are not undefined

var nlya_modal_filterOptions = function filterOptions(options) {
  return BASE_PROPS.reduce(function (memo, key) {
    if (!isUndefined(options[key])) {
      memo[key] = options[key];
    }

    return memo;
  }, {});
};

var nlya_modal_plugin = function plugin(Vue) {
  var NlyMsgBox = Vue.extend({
    name: "NlyMsgBox",
    extends: NlyModal,
    destroyed: function destroyed() {
      // Make sure we not in document any more
      if (this.$el && this.$el.parentNode) {
        this.$el.parentNode.removeChild(this.$el);
      }
    },
    mounted: function mounted() {
      var _this = this;

      // Self destruct handler
      var handleDestroy = function handleDestroy() {
        var self = _this;

        _this.$nextTick(function () {
          // In a `setTimeout()` to release control back to application
          setTimeout(function () {
            return self.$destroy();
          }, 0);
        });
      }; // Self destruct if parent destroyed


      this.$parent.$once("hook:destroyed", handleDestroy); // Self destruct after hidden

      this.$once("hidden", handleDestroy); // Self destruct on route change

      /* istanbul ignore if */

      if (this.$router && this.$route) {
        // Destroy ourselves if route changes

        /* istanbul ignore next */
        this.$once("hook:beforeDestroy", this.$watch("$router", handleDestroy));
      } // Show the `NlyMsgBox`


      this.show();
    }
  }); // Method to generate the on-demand modal message box
  // Returns a promise that resolves to a value returned by the resolve

  var asyncMsgBox = function asyncMsgBox($parent, props) {
    var resolver = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultResolver;

    if (warn_warnNotClient(nlya_modal_PROP_NAME) || warn_warnNoPromiseSupport(nlya_modal_PROP_NAME)) {
      /* istanbul ignore next */
      return;
    } // Create an instance of `NlyMsgBox` component


    var msgBox = new NlyMsgBox({
      // We set parent as the local VM so these modals can emit events on
      // the app `$root`, as needed by things like tooltips and popovers
      // And it helps to ensure `NlyMsgBox` is destroyed when parent is destroyed
      parent: $parent,
      // Preset the prop values
      propsData: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, nlya_modal_filterOptions(getComponentConfig("NlyModal") || {})), {}, {
        // Defaults that user can override
        hideHeaderClose: true,
        hideHeader: !(props.title || props.titleHtml)
      }, object_omit(props, keys(propsToSlots))), {}, {
        // Props that can't be overridden
        lazy: false,
        busy: false,
        visible: false,
        noStacking: false,
        noEnforceFocus: false
      })
    }); // Convert certain props to scoped slots

    keys(propsToSlots).forEach(function (prop) {
      if (!isUndefined(props[prop])) {
        // Can be a string, or array of VNodes.
        // Alternatively, user can use HTML version of prop to pass an HTML string.
        msgBox.$slots[propsToSlots[prop]] = concat(props[prop]);
      }
    }); // Return a promise that resolves when hidden, or rejects on destroyed

    return new Promise(function (resolve, reject) {
      var resolved = false;
      msgBox.$once("hook:destroyed", function () {
        if (!resolved) {
          /* istanbul ignore next */
          reject(new Error("NlyAdminlteVue MsgBox destroyed before resolve"));
        }
      });
      msgBox.$on("hide", function (nlyaModalEvt) {
        if (!nlyaModalEvt.defaultPrevented) {
          var result = resolver(nlyaModalEvt); // If resolver didn't cancel hide, we resolve

          if (!nlyaModalEvt.defaultPrevented) {
            resolved = true;
            resolve(result);
          }
        }
      }); // Create a mount point (a DIV) and mount the msgBo which will trigger it to show

      var div = document.createElement("div");
      document.body.appendChild(div);
      msgBox.$mount(div);
    });
  }; // Private utility method to open a user defined message box and returns a promise.
  // Not to be used directly by consumers, as this method may change calling syntax


  var makeMsgBox = function makeMsgBox($parent, content) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var resolver = arguments.length > 3 ? arguments[3] : undefined;

    if (!content || warn_warnNoPromiseSupport(nlya_modal_PROP_NAME) || warn_warnNotClient(nlya_modal_PROP_NAME) || !isFunction(resolver)) {
      /* istanbul ignore next */
      return;
    }

    return asyncMsgBox($parent, Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, nlya_modal_filterOptions(options)), {}, {
      msgBoxContent: content
    }), resolver);
  }; // nlyaModal instance class


  var nlyaModal = /*#__PURE__*/function () {
    function nlyaModal(vm) {
      _classCallCheck(this, nlyaModal);

      // Assign the new properties to this instance
      object_assign(this, {
        _vm: vm,
        _root: vm.$root
      }); // Set these properties as read-only and non-enumerable

      defineProperties(this, {
        _vm: readonlyDescriptor(),
        _root: readonlyDescriptor()
      });
    } // --- Instance methods ---
    // Show modal with the specified ID args are for future use


    _createClass(nlyaModal, [{
      key: "show",
      value: function show(id) {
        if (id && this._root) {
          var _this$_root;

          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          (_this$_root = this._root).$emit.apply(_this$_root, ["nlya::show::modal", id].concat(args));
        }
      } // Hide modal with the specified ID args are for future use

    }, {
      key: "hide",
      value: function hide(id) {
        if (id && this._root) {
          var _this$_root2;

          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          (_this$_root2 = this._root).$emit.apply(_this$_root2, ["nlya::hide::modal", id].concat(args));
        }
      } // The following methods require Promise support!
      // IE 11 and others do not support Promise natively, so users
      // should have a Polyfill loaded (which they need anyways for IE 11 support)
      // Open a message box with OK button only and returns a promise

    }, {
      key: "msgBoxOk",
      value: function msgBoxOk(message) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        // Pick the modal props we support from options
        var props = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, options), {}, {
          // Add in overrides and our content prop
          okOnly: true,
          okDisabled: false,
          hideFooter: false,
          msgBoxContent: message
        });

        return makeMsgBox(this._vm, message, props, function () {
          // Always resolve to true for OK
          return true;
        });
      } // Open a message box modal with OK and CANCEL buttons
      // and returns a promise

    }, {
      key: "msgBoxConfirm",
      value: function msgBoxConfirm(message) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        // Set the modal props we support from options
        var props = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, options), {}, {
          // Add in overrides and our content prop
          okOnly: false,
          okDisabled: false,
          cancelDisabled: false,
          hideFooter: false
        });

        return makeMsgBox(this._vm, message, props, function (nlyaModalEvt) {
          var trigger = nlyaModalEvt.trigger;
          return trigger === "ok" ? true : trigger === "cancel" ? false : null;
        });
      }
    }]);

    return nlyaModal;
  }(); // Add our instance mixin


  Vue.mixin({
    beforeCreate: function beforeCreate() {
      // Because we need access to `$root` for `$emits`, and VM for parenting,
      // we have to create a fresh instance of `nlyaModal` for each VM
      this[PROP_NAME_PRIV] = new nlyaModal(this);
    }
  }); // Define our read-only `$nlyaModal` instance property
  // Placed in an if just in case in HMR mode
  // eslint-disable-next-line no-prototype-builtins

  if (!Vue.prototype.hasOwnProperty(nlya_modal_PROP_NAME)) {
    object_defineProperty(Vue.prototype, nlya_modal_PROP_NAME, {
      get: function get() {
        /* istanbul ignore next */
        if (!this || !this[PROP_NAME_PRIV]) {
          warn_warn("\"".concat(nlya_modal_PROP_NAME, "\" must be accessed from a Vue instance \"this\" context."), "BModal");
        }

        return this[PROP_NAME_PRIV];
      }
    });
  }
};

var NlyAModalPlugin = plugins_nlyPluginFactory({
  plugins: {
    plugin: nlya_modal_plugin
  }
});
// CONCATENATED MODULE: ./src/components/modal/index.js



var ModalPlugin = plugins_nlyPluginFactory({
  components: {
    NlyModal: NlyModal
  },
  plugins: {
    NlyAModalPlugin: NlyAModalPlugin
  }
});

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.fill.js
var es_array_fill = __webpack_require__("cb29");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.small.js
var es_string_small = __webpack_require__("c96a");

// CONCATENATED MODULE: ./src/components/nav/nav.js





var nav_props = {
  tag: {
    type: String,
    default: "ul"
  },
  fill: {
    type: Boolean,
    default: false
  },
  justified: {
    type: Boolean,
    default: false
  },
  align: {
    type: String,
    default: null
  },
  tabs: {
    type: Boolean,
    default: false
  },
  tabsRight: {
    type: Boolean,
    default: false
  },
  pills: {
    type: Boolean,
    default: false
  },
  vertical: {
    type: Boolean,
    default: false
  },
  small: {
    type: Boolean,
    default: false
  },
  cardHeader: {
    type: Boolean,
    default: false
  }
};

var computeJustifyContent = function computeJustifyContent(value) {
  value = value === "left" ? "start" : value === "right" ? "end" : value;
  return "justify-content-".concat(value);
};

var nav_name = "NlyNav";
var NlyNav = utils_vue.extend({
  name: nav_name,
  functional: true,
  props: nav_props,
  render: function render(h, _ref) {
    var _class;

    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "nav",
      class: (_class = {
        "nav-tabs": props.tabs,
        "nav-tabs-right": props.tabsRight,
        "nav-pills": props.pills && !props.tabs,
        "card-header-tabs": !props.vertical && props.cardHeader && props.tabs,
        "card-header-pills": !props.vertical && props.cardHeader && props.pills && !props.tabs,
        "flex-column": props.vertical,
        "nav-fill": !props.vertical && props.fill,
        "nav-justified": !props.vertical && props.justified
      }, Object(defineProperty["a" /* default */])(_class, computeJustifyContent(props.align), !props.vertical && props.align), Object(defineProperty["a" /* default */])(_class, "small", props.small), _class)
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/nav/nav-item.js




var nav_item_props = propsFactory();
var nav_item_name = "NlyNavItem";
var NlyNavItem = utils_vue.extend({
  name: nav_item_name,
  functional: true,
  props: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({
    navItem: {
      type: Boolean,
      default: true
    },
    dropdownItem: {
      type: Boolean,
      default: false
    }
  }, nav_item_props), {}, {
    linkAttrs: {
      type: Object,
      default: function _default() {}
    },
    linkClasses: {
      type: [String, Object, Array],
      default: null
    }
  }),
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        listeners = _ref.listeners,
        children = _ref.children;
    delete data.on;
    return h("li", lib_esm_a(data, {
      staticClass: props.navItem ? "nav-item" : ""
    }), [h(NlyLink, {
      staticClass: props.dropdownItem ? "dropdown-item" : "nav-link",
      class: props.linkClasses,
      attrs: props.linkAttrs,
      props: props,
      on: listeners
    }, children)]);
  }
});
// CONCATENATED MODULE: ./src/components/nav/nav-dropdown.js





var nav_dropdown_name = "NlyNavDropdown";
var NlyNavDropdown = utils_vue.extend({
  name: nav_dropdown_name,
  data: function data() {
    return {
      show: false,
      itemShow: "",
      menuShow: ""
    };
  },
  props: {
    /**
     * li标签
     */
    //按钮是否具有nav-item类
    itemTag: {
      type: String,
      default: "li"
    },
    navItem: {
      type: Boolean,
      default: true
    },
    // 是否悬浮显示
    hover: {
      type: Boolean,
      default: false
    },
    // 是否子菜单
    submenu: {
      type: Boolean,
      default: false
    },
    // 下拉菜单方位
    direction: {
      type: String,
      default: "down"
    },
    itemClass: {
      type: String
    },

    /**
     * a标签
     */
    //aria-haspopup
    disabled: {
      type: Boolean,
      default: false
    },
    popup: {
      type: Boolean,
      default: false
    },
    // 是否nav-link
    navLink: {
      type: Boolean,
      default: true
    },
    //是否带下拉图标
    dropdownToggle: {
      type: Boolean,
      default: false
    },
    //id aria-labelledby
    id: {
      type: String
    },
    linkClass: {
      type: String
    },
    linkTag: {
      type: String,
      default: "a"
    },
    dropdownItem: {
      type: Boolean,
      default: false
    },

    /**
     * ul标签
     * */
    menuTag: {
      type: String,
      default: "ul"
    },
    menuClass: {
      type: String
    },
    size: {
      type: String
    },
    menuDirection: {
      type: String,
      default: "left"
    },
    shadow: {
      type: String,
      default: "shadow"
    },
    text: {
      type: String
    }
  },
  computed: {
    customText: function customText() {
      return this.text;
    },
    coustomItemTag: function coustomItemTag() {
      return this.itemTag;
    },
    customLinkTag: function customLinkTag() {
      return this.linkTag;
    },
    customNavItem: function customNavItem() {
      return this.navItem ? "nav-item" : false;
    },
    customHover: function customHover() {
      return this.hover ? "dropdown-hover" : false;
    },
    customSubmenu: function customSubmenu() {
      return this.submenu ? "dropdown-submenu" : false;
    },
    customDirection: function customDirection() {
      return nlyGetOptionsByKeyEqual(navDropdownDirectionOptions, this.direction);
    },
    customItemClass: function customItemClass() {
      return this.itemClass;
    },
    customPopup: function customPopup() {
      return this.popup;
    },
    customNavLink: function customNavLink() {
      return this.navLink ? "nav-link" : false;
    },
    customDropdownItem: function customDropdownItem() {
      return this.dropdownItem ? "dropdown-item" : false;
    },
    customDropdownToggle: function customDropdownToggle() {
      return this.dropdownToggle ? "dropdown-toggle" : false;
    },
    customId: function customId() {
      return this.id ? nlyDropdownId(this.id) : false;
    },
    customLinkClass: function customLinkClass() {
      return this.linkClass;
    },
    customSize: function customSize() {
      return nlyGetOptionsByKeyEqual(navDropdownSizeOptions, this.size);
    },
    customMenuDirection: function customMenuDirection() {
      if (this.direction == "down" || this.direction == "up") {
        return nlyGetOptionsByKeyEqual(navDropdownMenuDirectionOptions, this.menuDirection);
      } else {
        return "";
      }
    },
    customShadow: function customShadow() {
      return nlyGetOptionsByKeyEqual(navDropdownShadowOptions, this.shadow);
    },
    customMenuClass: function customMenuClass() {
      return this.menuClass;
    },
    customDisabled: function customDisabled() {
      return this.disabled;
    },
    customDisabledClass: function customDisabledClass() {
      return this.disabled ? "disabled" : "";
    }
  },
  // created() {
  //   this.itemShow = this.show ? "show" : "";
  //   this.menuShow = this.show ? "show" : "";
  // },
  methods: {
    onClick: function onClick(ev) {
      var evIsEvent = isEvent(ev);

      if (evIsEvent && this.customDisabled) {
        ev.preventDefault();
        ev.stopPropagation();
        ev.stopImmediatePropagation();
      } else {
        ev.preventDefault();
        ev.stopPropagation();

        if (this.show) {
          this.show = false;
          this.itemShow = this.show ? "show" : "";
          this.menuShow = this.show ? "show" : "";
        } else {
          this.show = true;
          this.itemShow = this.show ? "show" : "";
          this.menuShow = this.show ? "show" : "";
        }
      }
    },
    click_other: function click_other(e) {
      if (!this.$el.contains(e.target)) {
        this.show = false;
        this.itemShow = this.show ? "show" : "";
        this.menuShow = this.show ? "show" : "";
      }
    },
    focus: function focus() {
      if (this.$el && this.$el.focus) {
        this.$el.focus();
      }
    },
    blur: function blur() {
      if (this.$el && this.$el.blur) {
        this.$el.blur();
      }
    }
  },
  watch: {
    show: function show(newVal) {
      if (newVal === true) {
        document.addEventListener("click", this.click_other, true);
      } else {
        document.removeEventListener("click", this.click_other, true);
      }
    }
  },
  render: function render(h) {
    var linkArray = h(this.customLinkTag, {
      attrs: {
        id: this.customId,
        "aria-haspopup": this.customPopup,
        href: "#",
        "aria-expanded": this.show ? "true" : "false"
      },
      class: [this.customNavLink, this.customDropdownItem, this.customDropdownToggle, this.customLinkClass, this.customDisabledClass],
      on: {
        click: this.onClick
      }
    }, [this.customText, this.$slots.linkcontent]);
    var menuArray = h(this.menuTag, {
      attrs: {
        "aria-labelledby": this.customId
      },
      staticClass: "dropdown-menu",
      class: [this.customMenuDirection, this.customShadow, this.customSize, this.customMenuClass, this.menuShow]
    }, [this.$slots.default, this.$slots.menucontent]);
    return h(this.coustomItemTag, {
      staticClass: "dropdown",
      class: [this.customNavItem, this.customSubmenu, this.customDirection, this.customItemClass, this.itemShow, this.customHover]
    }, [linkArray, menuArray]);
  }
});
// CONCATENATED MODULE: ./src/components/nav/nav-form.js





var nav_form_props = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, object_omit(form_props, ["inline"])), {}, {
  formClass: {
    type: [String, Array, Object],
    default: null
  }
});
var NlyNavForm = utils_vue.extend({
  name: "NlyNavForm",
  functional: true,
  props: nav_form_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children,
        _ref$listeners = _ref.listeners,
        listeners = _ref$listeners === void 0 ? {} : _ref$listeners;
    var attrs = data.attrs;
    data.attrs = {};
    data.on = {};
    var $form = h(NlyForm, {
      class: props.formClass,
      props: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, props), {}, {
        inline: true
      }),
      attrs: attrs,
      on: listeners
    }, children);
    return h("li", lib_esm_a(data, {
      staticClass: "form-inline"
    }), [$form]);
  }
});
// CONCATENATED MODULE: ./src/components/nav/nav-text.js


var nav_text_props = {};
var NlyNavText = utils_vue.extend({
  name: "NlyNavText",
  functional: true,
  props: nav_text_props,
  // eslint-disable-next-line no-unused-vars
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h("li", lib_esm_a(data, {
      staticClass: "navbar-text"
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/nav/index.js






var NavPlugin = plugins_nlyPluginFactory({
  components: {
    NlyNav: NlyNav,
    NlyNavItem: NlyNavItem,
    NlyNavDropdown: NlyNavDropdown,
    NlyNavForm: NlyNavForm,
    NlyNavText: NlyNavText
  }
});

// CONCATENATED MODULE: ./src/components/navbar/navbar.js





var navbar_name = "NlyNavbar";
var navbar_props = {
  //头部菜单
  header: {
    type: Boolean,
    default: false
  },
  expand: {
    type: String
  },
  variant: {
    type: String,
    default: "white"
  },
  dark: {
    type: Boolean,
    default: false
  },
  size: {
    type: String,
    default: ""
  },
  border: {
    type: Boolean,
    default: true
  },
  navbarClass: {
    type: String
  },
  fixed: {
    type: String
  },
  sticky: {
    type: Boolean,
    default: false
  },
  tag: {
    type: String,
    default: "nav"
  }
};

var navbar_customClass = function customClass(props) {
  var customStickyClass = props.sticky === true ? "sticky-top" : null;
  var customFixedClass = props.fixed ? "fixed-".concat(props.fixed) : null;
  var customNavbarHeader = props.header ? "main-header" : "";
  var customNavbarExpand = props.expand == "xl" ? "navbar-expand-xl" : props.expand == "lg" ? "navbar-expand-lg" : props.expand == "md" ? "navbar-expand-md" : props.expand == "sm" ? "navbar-expand-sm" : props.expand == "no" ? "navbar-no-expand" : "navbar-expand";

  var customnNvbarVariant = function customnNvbarVariant() {
    return nlyGetOptionsByKeyEqual(navbarVariantOpitons, props.variant);
  };

  var customNavbarFontSize = function customNavbarFontSize() {
    return nlyGetOptionsByKeyEqual(textSizeOptions, props.size);
  };

  var customNavbarBorder = props.border ? "" : "border-bottom-0";
  var customNavbarClass = props.navbarClass;
  var customNavbarDark = props.dark ? "navbar-dark" : "navbar-light";
  return [customStickyClass, customFixedClass, customNavbarHeader, customNavbarExpand, customnNvbarVariant(), customNavbarFontSize(), customNavbarBorder, customNavbarClass, customNavbarDark];
};

var NlyNavbar = utils_vue.extend({
  name: navbar_name,
  functional: true,
  props: navbar_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "navbar",
      class: navbar_customClass(props)
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/navbar/navbar-nav.js





var navbar_nav_name = "NlyNavbarNav";
var navbar_nav_props = {
  tag: {
    type: String,
    default: "ul"
  },
  fill: {
    type: Boolean,
    default: false
  },
  justified: {
    type: Boolean,
    default: false
  },
  align: {
    type: String,
    default: null
  },
  small: {
    type: Boolean,
    default: false
  }
};

var navbar_nav_computeJustifyContent = function computeJustifyContent(value) {
  value = value === "left" ? "start" : value === "right" ? "end" : value;
  return "justify-content-".concat(value);
};

var NlyNavbarNav = utils_vue.extend({
  name: navbar_nav_name,
  props: navbar_nav_props,
  functional: true,
  render: function render(h, _ref) {
    var _class;

    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "navbar-nav",
      class: (_class = {
        "nav-fill": !props.vertical && props.fill,
        "nav-justified": !props.vertical && props.justified
      }, Object(defineProperty["a" /* default */])(_class, navbar_nav_computeJustifyContent(props.align), !props.vertical && props.align), Object(defineProperty["a" /* default */])(_class, "small", props.small), _class)
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/navbar/navbar-brand.js



var navbar_brand_name = "NlyNavbarBrand";
var navbar_brand_props = {
  href: {
    type: String,
    default: null
  },
  target: {
    type: String,
    default: "_self"
  },
  to: {
    type: [String, Object],
    default: null
  }
};
var NlyNavbarBrand = utils_vue.extend({
  name: navbar_brand_name,
  props: navbar_brand_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(NlyLink, lib_esm_a(data, {
      staticClass: "navbar-brand",
      props: {
        to: props.to,
        href: props.href,
        target: props.target
      }
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/navbar/navbar-brandimg.js


var navbar_brandimg_name = "NlyNavbarBrandimg";
var navbar_brandimg_props = {
  src: {
    type: String,
    required: true
  },
  navbarBrandimgClass: {
    type: String
  },
  alt: {
    type: String
  },
  circle: {
    type: Boolean,
    default: false
  },
  elevation: {
    type: Boolean,
    default: false
  }
};

var navbar_brandimg_customClass = function customClass(props) {
  return [props.circle ? "img-circle" : null, props.elevation ? "elevation-3" : null, props.navbarBrandimgClass];
};

var NlyNavbarBrandimg = utils_vue.extend({
  name: navbar_brandimg_name,
  props: navbar_brandimg_props,
  functional: true,
  computed: {
    customSrc: function customSrc() {
      return this.src;
    },
    customNavbarBrandimgClass: function customNavbarBrandimgClass() {
      return this.navbarBrandimgClass;
    },
    customCircle: function customCircle() {
      return this.circle ? "img-circle" : "";
    },
    customAlt: function customAlt() {
      return this.alt;
    },
    customElevation: function customElevation() {
      return this.elevation ? "elevation-3" : "";
    }
  },
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h("img", lib_esm_a(data, {
      attrs: {
        alt: props.alt,
        src: props.src
      },
      style: {
        opacity: 0.8,
        height: "33px"
      },
      staticClass: "brand-image",
      class: navbar_brandimg_customClass(props)
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/navbar/navbar-brandtext.js


var navbar_brandtext_name = "NlyNavbarBrandtext";
var navbar_brandtext_props = {
  textClass: {
    type: String,
    default: null
  },
  tag: {
    type: String,
    default: "span"
  },
  weight: {
    type: Boolean,
    default: true
  }
};
var NlyNavbarBrandtext = utils_vue.extend({
  name: navbar_brandtext_name,
  props: navbar_brandtext_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "brand-text",
      class: [props.weight ? "font-weight-light" : null, props.textClass]
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/navbar/navbar-toggle.js
 // import { getComponentConfig } from "../../utils/config";



 // --- Constants ---

var navbar_toggle_NAME = "NlyNavbarToggle";
var CLASS_NAME = "navbar-toggler"; // --- Main component ---
// @vue/component

var NlyNavbarToggle = /*#__PURE__*/utils_vue.extend({
  name: navbar_toggle_NAME,
  directives: {
    NlyToggle: VNlyToggle
  },
  mixins: [listen_on_root, mixins_normalize_slot],
  props: {
    label: {
      type: String,
      default: "Nly Toggle navigation"
    },
    target: {
      type: String,
      required: true
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      toggleState: false
    };
  },
  created: function created() {
    this.listenOnRoot(EVENT_STATE, this.handleStateEvt);
    this.listenOnRoot(EVENT_STATE_SYNC, this.handleStateEvt);
  },
  methods: {
    onClick: function onClick(evt) {
      if (!this.disabled) {
        // Emit courtesy `click` event
        this.$emit("click", evt);
      }
    },
    handleStateEvt: function handleStateEvt(id, state) {
      // We listen for state events so that we can pass the
      // boolean expanded state to the default scoped slot
      if (id === this.target) {
        this.toggleState = state;
      }
    }
  },
  render: function render(h) {
    var disabled = this.disabled;
    return h("button", {
      staticClass: CLASS_NAME,
      class: {
        disabled: disabled
      },
      directives: [{
        name: "NlyToggle",
        value: this.target
      }],
      attrs: {
        type: "button",
        disabled: disabled,
        "aria-label": this.label
      },
      on: {
        click: this.onClick
      }
    }, [this.normalizeSlot("default", {
      expanded: this.toggleState
    }) || h("span", {
      staticClass: "".concat(CLASS_NAME, "-icon")
    })]);
  }
});
// CONCATENATED MODULE: ./src/components/navbar/index.js







var NavbarPlugin = plugins_nlyPluginFactory({
  components: {
    NlyNavbar: NlyNavbar,
    NlyNavbarNav: NlyNavbarNav,
    NlyNavbarBrand: NlyNavbarBrand,
    NlyNavbarBrandimg: NlyNavbarBrandimg,
    NlyNavbarBrandtext: NlyNavbarBrandtext,
    NlyNavbarToggle: NlyNavbarToggle
  }
});

// CONCATENATED MODULE: ./src/components/overlay/index.js


var OverlayPlugin = plugins_nlyPluginFactory({
  components: {
    NlyOverlay: NlyOverlay
  }
});

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.flat.js
var es_array_flat = __webpack_require__("0481");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.includes.js
var es_array_includes = __webpack_require__("caad");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.unscopables.flat.js
var es_array_unscopables_flat = __webpack_require__("4069");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.includes.js
var es_string_includes = __webpack_require__("2532");

// EXTERNAL MODULE: ./node_modules/lodash.clonedeep/index.js
var lodash_clonedeep = __webpack_require__("cd3f");
var lodash_clonedeep_default = /*#__PURE__*/__webpack_require__.n(lodash_clonedeep);

// CONCATENATED MODULE: ./src/components/render-function/render-function.js












var render_function_name = "NlyRenderFunction";
var NlyRenderFunction = utils_vue.extend({
  name: render_function_name,
  props: {
    contentToRender: Array,
    flat: Boolean
  },
  computed: {
    copiedContent: function copiedContent() {
      return lodash_clonedeep_default()(this.contentToRender);
    },
    content: function content() {
      if (!this.flat) {
        return this.copiedContent;
      } else {
        return this.convertedContent[0];
      }
    },
    convertedContent: function convertedContent() {
      var _this = this;

      return this.copiedContent.map(function (item) {
        return _this.convertItem(item);
      });
    }
  },
  methods: {
    convertItem: function convertItem(item) {
      var _this2 = this;

      if (typeof item === "string") {
        return item;
      }

      var newItem = [];
      newItem[0] = item._type;
      newItem[1] = {};
      newItem[1].props = this.getProps(item);
      this.$options.renderFunctionOptions.forEach(function (option) {
        //on option doesn't work, possible to use only nativeOn
        if (item["_".concat(option)]) {
          newItem[1][option] = item["_".concat(option)];
        }
      });

      if (item._children) {
        newItem[2] = item._children.map(function (item) {
          return _this2.convertItem(item);
        });
      } else {
        newItem[2] = item._name;
      }

      return newItem;
    },
    getProps: function getProps(item) {
      return Object.keys(item).reduce(function (itemProps, key) {
        if (!key.includes("_")) {
          itemProps[key] = item[key];
        }

        return itemProps;
      }, {});
    }
  },
  renderFunctionOptions: ["attrs", "directives", "on", "nativeOn", "class", "style", "domProps", "scopedSlots", "slot", "key", "ref", "refInFor", "id"],
  // eslint-disable-next-line no-unused-vars
  render: function render() {
    var _this3 = this;

    var h = this.$createElement;

    var computeRenderFunction = function computeRenderFunction(renderFunction) {
      return renderFunction.map(function (item) {
        if (Array.isArray(item)) {
          return item.map(function (_children) {
            if (typeof _children === "string") {
              return _children;
            } else if (Array.isArray(_children)) {
              var el = h.apply(void 0, _toConsumableArray(computeRenderFunction(_children)));
              return el;
            } else if (_children.slot) {
              return _this3.$scopedSlots[_children.slot]();
            }
          });
        }

        return item;
      });
    };

    if (Array.isArray(this.content) && this.content.length) {
      return h.apply(void 0, _toConsumableArray(computeRenderFunction(this.content)));
    } else {
      return h(false);
    }
  }
});
// CONCATENATED MODULE: ./src/components/pagination/pagination.js









var pagination_pagination_name = "NlyPagination";
var NlyPagination = utils_vue.extend({
  name: pagination_pagination_name,
  data: function data() {
    return {
      tempalteCurrentPage: ""
    };
  },
  props: {
    total: {
      type: [Number, String]
    },
    size: {
      type: [Number, String],
      default: 10
    },
    currentPage: {
      type: [Number, String],
      default: 1
    },
    limit: {
      type: [Number, String],
      default: 5
    },
    align: {
      default: "left",
      type: String
    },
    firstFunction: {
      type: Function
    },
    prevFunction: {
      type: Function
    },
    currentFunction: {
      type: Function
    },
    nextFunction: {
      type: Function
    },
    lastFunction: {
      type: Function
    },
    sizeFunction: {
      type: Function
    },
    showPg: {
      type: Boolean,
      default: false
    },
    sm: {
      type: Boolean,
      default: false
    },
    lg: {
      type: Boolean,
      default: false
    }
  },
  methods: {
    _firstFunction: function _firstFunction() {
      if (this.firstFunction) {
        this.tempalteCurrentPage = 1;
        this.firstFunction();
      } else {
        this.tempalteCurrentPage = 1;
      }
    },
    _prevFunction: function _prevFunction() {
      if (this.prevFunction) {
        this.tempalteCurrentPage = this.tempalteCurrentPage - 1;
        this.prevFunction();
      } else {
        this.tempalteCurrentPage = this.tempalteCurrentPage - 1;
      }
    },
    _currentFunction: function _currentFunction(item) {
      if (this.currentFunction) {
        this.tempalteCurrentPage = item;
        this.currentFunction();
      } else {
        this.tempalteCurrentPage = item;
      }
    },
    _nextFunction: function _nextFunction() {
      if (this.nextFunction) {
        this.tempalteCurrentPage = this.tempalteCurrentPage + 1;
        this.nextFunction();
      } else {
        this.tempalteCurrentPage = this.tempalteCurrentPage + 1;
      }
    },
    _lastFunction: function _lastFunction() {
      if (this.lastFunction) {
        this.tempalteCurrentPage = this.nlyPgPages;
        this.lastFunction();
      } else {
        this.tempalteCurrentPage = this.nlyPgPages;
      }
    },
    _sizeFunction: function _sizeFunction() {
      if (this.sizeFunction) {
        this.sizeFunction();
      }
    }
  },
  computed: {
    nlyPgFontSize: function nlyPgFontSize() {
      if (this.sm) {
        return "pagination-sm";
      } else if (this.lg) {
        return "pagination-lg";
      } else {
        return "";
      }
    },
    nlypgShowPg: function nlypgShowPg() {
      return this.showPg;
    },
    nlyPgtTotal: function nlyPgtTotal() {
      return isNaN(toInteger(this.total)) ? 1 : toInteger(this.total) <= 0 ? 1 : toInteger(this.total);
    },
    nlyPgSize: function nlyPgSize() {
      return isNaN(toInteger(this.size)) ? 10 : toInteger(this.size) <= 0 ? 10 : toInteger(this.size);
    },
    nlyPgCurrentPage: function nlyPgCurrentPage() {
      return toInteger(this.tempalteCurrentPage);
    },
    nlyPgLimit: function nlyPgLimit() {
      return isNaN(toInteger(this.limit)) ? 5 : toInteger(this.limit) <= 4 ? 5 : toInteger(this.limit);
    },
    nlyPgPages: function nlyPgPages() {
      return Math.ceil(this.nlyPgtTotal / this.nlyPgSize);
    },
    nlyPgItemArray: function nlyPgItemArray() {
      var _this = this;

      if (this.nlyPgCurrentPage + 1 <= this.nlyPgLimit && this.nlyPgPages < this.nlyPgLimit) {
        var itemList = Array.from({
          length: this.nlyPgPages
        }).map(function (v, k) {
          return k + 1;
        });
        return itemList;
      } else if (this.nlyPgCurrentPage + 1 <= this.nlyPgLimit && this.nlyPgPages == this.nlyPgLimit) {
        var _itemList = Array.from({
          length: this.nlyPgLimit
        }).map(function (v, k) {
          return k + 1;
        });

        return _itemList;
      } else if (this.nlyPgCurrentPage + 2 <= this.nlyPgLimit && this.nlyPgPages > this.nlyPgLimit) {
        var _itemList2 = Array.from({
          length: this.nlyPgLimit - 1
        }).map(function (v, k) {
          return k + 1;
        });

        _itemList2.push("···");

        return _itemList2;
      } else if (this.nlyPgPages - this.nlyPgCurrentPage + 2 < this.nlyPgLimit && this.nlyPgPages > this.nlyPgLimit) {
        var _itemList3 = Array.from({
          length: this.nlyPgLimit - 1
        }).map(function (v, k) {
          return k + (_this.nlyPgPages - _this.nlyPgLimit + 2);
        });

        _itemList3.splice(0, 0, "···");

        return _itemList3;
      } else if (this.nlyPgPages - this.nlyPgCurrentPage + 2 < this.nlyPgLimit && this.nlyPgPages == this.nlyPgLimit) {
        var _itemList4 = Array.from({
          length: this.nlyPgLimit - 1
        }).map(function (v, k) {
          return k + (_this.nlyPgPages - _this.nlyPgLimit + 2);
        });

        return _itemList4;
      } else {
        var _itemList5 = Array.from({
          length: this.nlyPgLimit - 2
        }).map(function (v, k) {
          return k + _this.nlyPgCurrentPage - Math.ceil(_this.nlyPgLimit / 2) + 2;
        });

        _itemList5.splice(0, 0, "···");

        _itemList5.push("···");

        return _itemList5;
      }
    },
    alignClass: function alignClass() {
      var align = this.align;

      if (align === "center") {
        return "justify-content-center";
      } else if (align === "end" || align === "right") {
        return "justify-content-end";
      }

      return "";
    },
    tempalteArray: function tempalteArray() {
      var _this2 = this;

      var _tempalteArray = function _tempalteArray() {
        var nlyPgItemArrayAll = _this2.nlyPgItemArray;
        nlyPgItemArrayAll.splice(0, 0, "‹");
        nlyPgItemArrayAll.splice(0, 0, "‹‹");
        nlyPgItemArrayAll.push("›");
        nlyPgItemArrayAll.push("››");
        var nlyPgTempalteArray = nlyPgItemArrayAll.map(function (item) {
          if (item == "‹‹") {
            if (_this2.nlyPgCurrentPage == 1) {
              return {
                _type: "li",
                _class: "page-item disabled",
                _children: [{
                  _type: NlyLink,
                  _name: item,
                  _class: "page-link"
                }]
              };
            } else {
              return {
                _type: "li",
                _class: "page-item",
                _on: {
                  click: _this2._firstFunction
                },
                _children: [{
                  _type: NlyLink,
                  _name: item,
                  _class: "page-link"
                }]
              };
            }
          } else if (item == "‹") {
            if (_this2.nlyPgCurrentPage == 1) {
              return {
                _type: "li",
                _class: "page-item disabled",
                _children: [{
                  _type: NlyLink,
                  _name: item,
                  _class: "page-link"
                }]
              };
            } else {
              return {
                _type: "li",
                _class: "page-item",
                _on: {
                  click: _this2._prevFunction
                },
                _children: [{
                  _type: NlyLink,
                  _name: item,
                  _class: "page-link"
                }]
              };
            }
          } else if (item == "···") {
            return {
              _type: "li",
              _class: "page-item disabled",
              _children: [{
                _type: NlyLink,
                _name: item,
                _class: "page-link"
              }]
            };
          } else if (item == "›") {
            if (_this2.nlyPgCurrentPage == _this2.nlyPgPages) {
              return {
                _type: "li",
                _class: "page-item disabled",
                _children: [{
                  _type: NlyLink,
                  _name: item,
                  _class: "page-link"
                }]
              };
            } else {
              return {
                _type: "li",
                _class: "page-item",
                _on: {
                  click: _this2._nextFunction
                },
                _children: [{
                  _type: NlyLink,
                  _name: item,
                  _class: "page-link"
                }]
              };
            }
          } else if (item == "››") {
            if (_this2.nlyPgCurrentPage == _this2.nlyPgPages) {
              return {
                _type: "li",
                _class: "page-item disabled",
                _children: [{
                  _type: NlyLink,
                  _name: item,
                  _class: "page-link"
                }]
              };
            } else {
              return {
                _type: "li",
                _class: "page-item",
                _on: {
                  click: _this2._lastFunction
                },
                _children: [{
                  _type: NlyLink,
                  _name: item,
                  _class: "page-link"
                }]
              };
            }
          } else if (item == _this2.tempalteCurrentPage) {
            return {
              _type: "li",
              _class: "page-item active",
              _on: {
                click: function click() {
                  return _this2._currentFunction(item);
                }
              },
              _children: [{
                _type: NlyLink,
                _name: item,
                _class: "page-link"
              }]
            };
          } else {
            return {
              _type: "li",
              _class: "page-item",
              _on: {
                click: function click() {
                  return _this2._currentFunction(item);
                }
              },
              _children: [{
                _type: NlyLink,
                _name: item,
                _class: "page-link"
              }]
            };
          }
        });
        var nlyPgTempalteArrayAll = [{
          _type: "ul",
          _class: ["pagination", _this2.nlyPgFontSize, _this2.alignClass],
          _children: nlyPgTempalteArray
        }];
        return nlyPgTempalteArrayAll;
      };

      return _tempalteArray();
    }
  },
  created: function created() {
    this.tempalteCurrentPage = isNaN(toInteger(this.currentPage)) ? 1 : toInteger(this.currentPage) <= 1 ? 1 : toInteger(this.currentPage);
  },
  watch: {
    tempalteCurrentPage: function tempalteCurrentPage() {
      this.$emit("getCurrentPage", this.tempalteCurrentPage);
    },
    currentPage: function currentPage(newval, oldval) {
      if (newval != oldval) {
        this.tempalteCurrentPage = toInteger(this.currentPage);
      }
    },
    nlyPgPages: function nlyPgPages(newval, oldval) {
      if (newval != oldval) {
        this.tempalteCurrentPage = this.tempalteCurrentPage > newval ? newval : this.tempalteCurrentPage;
      }
    },
    nlyPgSize: function nlyPgSize(newval, oldval) {
      if (newval != oldval) {
        this._sizeFunction();
      }
    }
  },
  render: function render(h) {
    var _this3 = this;

    var pgVnode = function pgVnode() {
      if (_this3.nlypgShowPg && _this3.nlyPgPages <= 1) {
        return h();
      } else {
        return h(NlyRenderFunction, {
          props: {
            contentToRender: _this3.tempalteArray,
            flat: true
          }
        });
      }
    };

    return pgVnode();
  }
});
// CONCATENATED MODULE: ./src/components/pagination/index.js


var PaginationPlugin = plugins_nlyPluginFactory({
  components: {
    NlyPagination: NlyPagination
  }
});

// CONCATENATED MODULE: ./src/components/tooltip/plugin/nlya-popper.js






var nlya_popper_NAME = "NlyaPopper";
var nlya_popper_AttachmentMap = {
  AUTO: "auto",
  TOP: "top",
  RIGHT: "right",
  BOTTOM: "bottom",
  LEFT: "left",
  TOPLEFT: "top",
  TOPRIGHT: "top",
  RIGHTTOP: "right",
  RIGHTBOTTOM: "right",
  BOTTOMLEFT: "bottom",
  BOTTOMRIGHT: "bottom",
  LEFTTOP: "left",
  LEFTBOTTOM: "left"
};
var OffsetMap = {
  AUTO: 0,
  TOPLEFT: -1,
  TOP: 0,
  TOPRIGHT: +1,
  RIGHTTOP: -1,
  RIGHT: 0,
  RIGHTBOTTOM: +1,
  BOTTOMLEFT: -1,
  BOTTOM: 0,
  BOTTOMRIGHT: +1,
  LEFTTOP: -1,
  LEFT: 0,
  LEFTBOTTOM: +1
}; // @vue/component

var NlyaPopper = utils_vue.extend({
  name: nlya_popper_NAME,
  props: {
    target: {
      // Element that the tooltip/popover is positioned relative to
      type: [safe_types_HTMLElement, safe_types_SVGElement],
      default: null
    },
    placement: {
      type: String,
      default: "top"
    },
    fallbackPlacement: {
      type: [String, Array],
      default: "flip"
    },
    offset: {
      type: Number,
      default: 0
    },
    boundary: {
      // 'scrollParent', 'viewport', 'window', or Element
      type: [String, safe_types_HTMLElement],
      default: "scrollParent"
    },
    boundaryPadding: {
      // Tooltip/popover will try and stay away from
      // boundary edge by this many pixels
      type: Number,
      default: 5
    },
    arrowPadding: {
      // The minimum distance (in `px`) from the edge of the
      // tooltip/popover that the arrow can be positioned
      type: Number,
      default: 6
    }
  },
  data: function data() {
    return {
      // reactive props set by parent
      noFade: false,
      // State related data
      localShow: true,
      attachment: this.getAttachment(this.placement)
    };
  },
  computed: {
    templateType: function templateType()
    /* istanbul ignore next */
    {
      // Overridden by template component
      return "unknown";
    },
    popperConfig: function popperConfig() {
      var _this = this;

      var placement = this.placement;
      return {
        placement: this.getAttachment(placement),
        modifiers: {
          offset: {
            offset: this.getOffset(placement)
          },
          flip: {
            behavior: this.fallbackPlacement
          },
          // `arrow.element` can also be a reference to an HTML Element
          // maybe we should make this a `$ref` in the templates?
          arrow: {
            element: ".arrow"
          },
          preventOverflow: {
            padding: this.boundaryPadding,
            boundariesElement: this.boundary
          }
        },
        onCreate: function onCreate(data) {
          // Handle flipping arrow classes
          if (data.originalPlacement !== data.placement) {
            /* istanbul ignore next: can't test in JSDOM */
            _this.popperPlacementChange(data);
          }
        },
        onUpdate: function onUpdate(data) {
          // Handle flipping arrow classes
          _this.popperPlacementChange(data);
        }
      };
    }
  },
  created: function created() {
    var _this2 = this;

    // Note: We are created on-demand, and should be guaranteed that
    // DOM is rendered/ready by the time the created hook runs
    this.$_popper = null; // Ensure we show as we mount

    this.localShow = true; // Create popper instance before shown

    this.$on("show", function (el) {
      _this2.popperCreate(el);
    }); // Self destruct once hidden

    this.$on("hidden", function () {
      _this2.$nextTick(_this2.$destroy);
    }); // If parent is destroyed, ensure we are destroyed

    this.$parent.$once("hook:destroyed", this.$destroy);
  },
  beforeMount: function beforeMount() {
    // Ensure that the attachment position is correct before mounting
    // as our propsData is added after `new Template({...})`
    this.attachment = this.getAttachment(this.placement);
  },
  mounted: function mounted() {// TBD
  },
  updated: function updated() {
    // Update popper if needed
    // TODO: Should this be a watcher on `this.popperConfig` instead?
    this.popperUpdate();
  },
  beforeDestroy: function beforeDestroy() {
    this.popperDestroy();
  },
  destroyed: function destroyed() {
    // Make sure template is removed from DOM
    var el = this.$el;
    el && el.parentNode && el.parentNode.removeChild(el);
  },
  methods: {
    // "Public" method to trigger hide template
    hide: function hide() {
      this.localShow = false;
    },
    // Private
    getAttachment: function getAttachment(placement) {
      return nlya_popper_AttachmentMap[String(placement).toUpperCase()] || "auto";
    },
    getOffset: function getOffset(placement) {
      if (!this.offset) {
        // Could set a ref for the arrow element
        var arrow = this.$refs.arrow || dom_select(".arrow", this.$el);
        var arrowOffset = (parseFloat(dom_getCS(arrow).width) || 0) + (parseFloat(this.arrowPadding) || 0);

        switch (OffsetMap[String(placement).toUpperCase()] || 0) {
          case +1:
            /* istanbul ignore next: can't test in JSDOM */
            return "+50%p - ".concat(arrowOffset, "px");

          case -1:
            /* istanbul ignore next: can't test in JSDOM */
            return "-50%p + ".concat(arrowOffset, "px");

          default:
            return 0;
        }
      }
      /* istanbul ignore next */


      return this.offset;
    },
    popperCreate: function popperCreate(el) {
      this.popperDestroy(); // We use `el` rather than `this.$el` just in case the original
      // mountpoint root element type was changed by the template

      this.$_popper = new popper["a" /* default */](this.target, el, this.popperConfig);
    },
    popperDestroy: function popperDestroy() {
      this.$_popper && this.$_popper.destroy();
      this.$_popper = null;
    },
    popperUpdate: function popperUpdate() {
      this.$_popper && this.$_popper.scheduleUpdate();
    },
    popperPlacementChange: function popperPlacementChange(data) {
      // Callback used by popper to adjust the arrow placement
      this.attachment = this.getAttachment(data.placement);
    },
    renderTemplate: function renderTemplate(h)
    /* istanbul ignore next */
    {
      // Will be overridden by templates
      return h("div");
    }
  },
  render: function render(h) {
    var _this3 = this;

    // Note: `show` and 'fade' classes are only appled during transition
    return h(NlyToastTransition, {
      // Transitions as soon as mounted
      props: {
        appear: true,
        noFade: this.noFade
      },
      on: {
        // Events used by parent component/instance
        beforeEnter: function beforeEnter(el) {
          return _this3.$emit("show", el);
        },
        afterEnter: function afterEnter(el) {
          return _this3.$emit("shown", el);
        },
        beforeLeave: function beforeLeave(el) {
          return _this3.$emit("hide", el);
        },
        afterLeave: function afterLeave(el) {
          return _this3.$emit("hidden", el);
        }
      }
    }, [this.localShow ? this.renderTemplate(h) : h()]);
  }
});
// CONCATENATED MODULE: ./src/components/tooltip/plugin/nlya-tooltip-template.js







var nlya_tooltip_template_NAME = "NlyaTooltipTemplate"; // @vue/component

var NlyaTooltipTemplate = /*#__PURE__*/utils_vue.extend({
  name: nlya_tooltip_template_NAME,
  extends: NlyaPopper,
  mixins: [scoped_style_attrs],
  props: {
    id: {
      type: String,
      default: null
    },
    html: {
      // Used only by the directive versions
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    // We use data, rather than props to ensure reactivity
    // Parent component will directly set this data
    return {
      title: "",
      content: "",
      variant: null,
      customClass: null,
      interactive: true
    };
  },
  computed: {
    templateType: function templateType() {
      return "tooltip";
    },
    templateClasses: function templateClasses() {
      var _ref;

      return [(_ref = {
        // Disables pointer events to hide the tooltip when the user
        // hovers over its content
        noninteractive: !this.interactive
      }, Object(defineProperty["a" /* default */])(_ref, "nly-".concat(this.templateType, "-").concat(this.variant), this.variant), Object(defineProperty["a" /* default */])(_ref, "bs-".concat(this.templateType, "-").concat(this.attachment), this.attachment), _ref), this.customClass];
    },
    templateAttributes: function templateAttributes() {
      return Object(objectSpread2["a" /* default */])({
        id: this.id,
        role: "tooltip",
        tabindex: "-1"
      }, this.scopedStyleAttrs);
    },
    templateListeners: function templateListeners() {
      var _this = this;

      // Used for hover/focus trigger listeners
      return {
        mouseenter: function mouseenter(evt) {
          /* istanbul ignore next: difficult to test in JSDOM */
          _this.$emit("mouseenter", evt);
        },
        mouseleave: function mouseleave(evt) {
          /* istanbul ignore next: difficult to test in JSDOM */
          _this.$emit("mouseleave", evt);
        },
        focusin: function focusin(evt) {
          /* istanbul ignore next: difficult to test in JSDOM */
          _this.$emit("focusin", evt);
        },
        focusout: function focusout(evt) {
          /* istanbul ignore next: difficult to test in JSDOM */
          _this.$emit("focusout", evt);
        }
      };
    }
  },
  methods: {
    renderTemplate: function renderTemplate(h) {
      // Title can be a scoped slot function
      var $title = isFunction(this.title) ? this.title({}) : isUndefinedOrNull(this.title) ? h() : this.title; // Directive versions only

      var domProps = this.html && !isFunction(this.title) ? {
        innerHTML: this.title
      } : {};
      return h("div", {
        staticClass: "tooltip nly-tooltip",
        class: this.templateClasses,
        attrs: this.templateAttributes,
        on: this.templateListeners
      }, [h("div", {
        ref: "arrow",
        staticClass: "arrow"
      }), h("div", {
        staticClass: "tooltip-inner",
        domProps: domProps
      }, [$title])]);
    }
  }
});
// CONCATENATED MODULE: ./src/components/tooltip/plugin/nlya-tooltip.js










// Tooltip "Class" (Built as a renderless Vue instance)
//
// Handles trigger events, etc.
// Instantiates template on demand












var noop = function noop() {};

var nlya_tooltip_NAME = "NlyaTooltip"; // Modal container selector for appending tooltip/popover

var MODAL_SELECTOR = ".modal-content"; // Modal `$root` hidden event

var MODAL_CLOSE_EVENT = "nlya::modal::hidden"; // For dropdown sniffing

var DROPDOWN_CLASS = "dropdown";
var DROPDOWN_OPEN_SELECTOR = ".dropdown-menu.show"; // Data specific to popper and template
// We don't use props, as we need reactivity (we can't pass reactive props)

var templateData = {
  // Text string or Scoped slot function
  title: "",
  // Text string or Scoped slot function
  content: "",
  // String
  variant: null,
  // String, Array, Object
  customClass: null,
  triggers: "",
  placement: "auto",
  // String or array of strings
  fallbackPlacement: "flip",
  // Element or Component reference (or function that returns element) of
  // the element that will have the trigger events bound, and is also
  // default element for positioning
  target: null,
  // HTML ID, Element or Component reference
  container: null,
  // 'body'
  // Boolean
  noFade: false,
  // 'scrollParent', 'viewport', 'window', Element, or Component reference
  boundary: "scrollParent",
  // Tooltip/popover will try and stay away from
  // boundary edge by this many pixels (Number)
  boundaryPadding: 5,
  // Arrow offset (Number)
  offset: 0,
  // Hover/focus delay (Number or Object)
  delay: 0,
  // Arrow of Tooltip/popover will try and stay away from
  // the edge of tooltip/popover edge by this many pixels
  arrowPadding: 6,
  // Interactive state (Boolean)
  interactive: true,
  // Disabled state (Boolean)
  disabled: false,
  // ID to use for tooltip/popover
  id: null,
  // Flag used by directives only, for HTML content
  html: false
}; // @vue/component

var NlyaTooltip = utils_vue.extend({
  name: nlya_tooltip_NAME,
  props: {// None
  },
  data: function data() {
    return Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, templateData), {}, {
      // State management data
      activeTrigger: {
        // manual: false,
        hover: false,
        click: false,
        focus: false
      },
      localShow: false
    });
  },
  computed: {
    templateType: function templateType() {
      return "tooltip";
    },
    computedId: function computedId() {
      return this.id || "__nly_".concat(this.templateType, "_").concat(this._uid, "__");
    },
    computedDelay: function computedDelay() {
      // Normalizes delay into object form
      var delay = {
        show: 0,
        hide: 0
      };

      if (isPlainObject(this.delay)) {
        delay.show = Math.max(parseInt(this.delay.show, 10) || 0, 0);
        delay.hide = Math.max(parseInt(this.delay.hide, 10) || 0, 0);
      } else if (isNumber(this.delay) || isString(this.delay)) {
        delay.show = delay.hide = Math.max(parseInt(this.delay, 10) || 0, 0);
      }

      return delay;
    },
    computedTriggers: function computedTriggers() {
      // Returns the triggers in sorted array form
      // TODO: Switch this to object form for easier lookup
      return concat(this.triggers).filter(Boolean).join(" ").trim().toLowerCase().split(/\s+/).sort();
    },
    isWithActiveTrigger: function isWithActiveTrigger() {
      for (var trigger in this.activeTrigger) {
        if (this.activeTrigger[trigger]) {
          return true;
        }
      }

      return false;
    },
    computedTemplateData: function computedTemplateData() {
      return {
        title: this.title,
        content: this.content,
        variant: this.variant,
        customClass: this.customClass,
        noFade: this.noFade,
        interactive: this.interactive
      };
    }
  },
  watch: {
    computedTriggers: function computedTriggers(newTriggers, oldTriggers) {
      var _this = this;

      // Triggers have changed, so re-register them

      /* istanbul ignore next */
      if (!loose_equal(newTriggers, oldTriggers)) {
        this.$nextTick(function () {
          // Disable trigger listeners
          _this.unListen(); // Clear any active triggers that are no longer in the list of triggers


          oldTriggers.forEach(function (trigger) {
            if (!arrayIncludes(newTriggers, trigger)) {
              if (_this.activeTrigger[trigger]) {
                _this.activeTrigger[trigger] = false;
              }
            }
          }); // Re-enable the trigger listeners

          _this.listen();
        });
      }
    },
    computedTemplateData: function computedTemplateData() {
      // If any of the while open reactive "props" change,
      // ensure that the template updates accordingly
      this.handleTemplateUpdate();
    },
    disabled: function disabled(newVal) {
      newVal ? this.disable() : this.enable();
    }
  },
  created: function created() {
    var _this2 = this;

    // Create non-reactive properties
    this.$_tip = null;
    this.$_hoverTimeout = null;
    this.$_hoverState = "";
    this.$_visibleInterval = null;
    this.$_enabled = !this.disabled;
    this.$_noop = noop.bind(this); // Destroy ourselves when the parent is destroyed

    if (this.$parent) {
      this.$parent.$once("hook:beforeDestroy", this.$destroy);
    }

    this.$nextTick(function () {
      var target = _this2.getTarget();

      if (target && dom_contains(document.body, target)) {
        // Copy the parent's scoped style attribute
        _this2.scopeId = get_scope_id(_this2.$parent); // Set up all trigger handlers and listeners

        _this2.listen();
      } else {
        /* istanbul ignore next */
        warn_warn("Unable to find target element in document.", _this2.templateType);
      }
    });
  },
  updated: function updated()
  /* istanbul ignore next */
  {
    // Usually called when the slots/data changes
    this.$nextTick(this.handleTemplateUpdate);
  },
  deactivated: function deactivated()
  /* istanbul ignore next */
  {
    // In a keepalive that has been deactivated, so hide
    // the tooltip/popover if it is showing
    this.forceHide();
  },
  beforeDestroy: function beforeDestroy()
  /* istanbul ignore next */
  {
    // Remove all handler/listeners
    this.unListen();
    this.setWhileOpenListeners(false); // Clear any timeouts/intervals

    this.clearHoverTimeout();
    this.clearVisibilityInterval(); // Destroy the template

    this.destroyTemplate();
  },
  methods: {
    // --- Methods for creating and destroying the template ---
    getTemplate: function getTemplate() {
      return NlyaTooltipTemplate;
    },
    updateData: function updateData() {
      var _this3 = this;

      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // Method for updating popper/template data
      // We only update data if it exists, and has not changed
      var titleUpdated = false;
      keys(templateData).forEach(function (prop) {
        if (!isUndefined(data[prop]) && _this3[prop] !== data[prop]) {
          _this3[prop] = data[prop];

          if (prop === "title") {
            titleUpdated = true;
          }
        }
      });

      if (titleUpdated && this.localShow) {
        // If the title has updated, we may need to handle the title
        // attribute on the trigger target. We only do this while the
        // template is open
        this.fixTitle();
      }
    },
    createTemplateAndShow: function createTemplateAndShow() {
      // Creates the template instance and show it
      var container = this.getContainer();
      var Template = this.getTemplate();
      var $tip = this.$_tip = new Template({
        parent: this,
        // The following is not reactive to changes in the props data
        propsData: {
          // These values cannot be changed while template is showing
          id: this.computedId,
          html: this.html,
          placement: this.placement,
          fallbackPlacement: this.fallbackPlacement,
          target: this.getPlacementTarget(),
          boundary: this.getBoundary(),
          // Ensure the following are integers
          offset: parseInt(this.offset, 10) || 0,
          arrowPadding: parseInt(this.arrowPadding, 10) || 0,
          boundaryPadding: parseInt(this.boundaryPadding, 10) || 0
        }
      }); // We set the initial reactive data (values that can be changed while open)

      this.handleTemplateUpdate(); // Template transition phase events (handled once only)
      // When the template has mounted, but not visibly shown yet

      $tip.$once("show", this.onTemplateShow); // When the template has completed showing

      $tip.$once("shown", this.onTemplateShown); // When the template has started to hide

      $tip.$once("hide", this.onTemplateHide); // When the template has completed hiding

      $tip.$once("hidden", this.onTemplateHidden); // When the template gets destroyed for any reason

      $tip.$once("hook:destroyed", this.destroyTemplate); // Convenience events from template
      // To save us from manually adding/removing DOM
      // listeners to tip element when it is open

      $tip.$on("focusin", this.handleEvent);
      $tip.$on("focusout", this.handleEvent);
      $tip.$on("mouseenter", this.handleEvent);
      $tip.$on("mouseleave", this.handleEvent); // Mount (which triggers the `show`)

      $tip.$mount(container.appendChild(document.createElement("div"))); // Template will automatically remove its markup from DOM when hidden
    },
    hideTemplate: function hideTemplate() {
      // Trigger the template to start hiding
      // The template will emit the `hide` event after this and
      // then emit the `hidden` event once it is fully hidden
      // The `hook:destroyed` will also be called (safety measure)
      this.$_tip && this.$_tip.hide(); // Clear out any stragging active triggers

      this.clearActiveTriggers(); // Reset the hover state

      this.$_hoverState = "";
    },
    // Destroy the template instance and reset state
    destroyTemplate: function destroyTemplate() {
      this.setWhileOpenListeners(false);
      this.clearHoverTimeout();
      this.$_hoverState = "";
      this.clearActiveTriggers();
      this.localPlacementTarget = null;

      try {
        this.$_tip && this.$_tip.$destroy(); // eslint-disable-next-line no-empty
      } catch (_unused) {}

      this.$_tip = null;
      this.removeAriaDescribedby();
      this.restoreTitle();
      this.localShow = false;
    },
    getTemplateElement: function getTemplateElement() {
      return this.$_tip ? this.$_tip.$el : null;
    },
    handleTemplateUpdate: function handleTemplateUpdate() {
      var _this4 = this;

      // Update our template title/content "props"
      // So that the template updates accordingly
      var $tip = this.$_tip;

      if ($tip) {
        var props = ["title", "content", "variant", "customClass", "noFade", "interactive"]; // Only update the values if they have changed

        props.forEach(function (prop) {
          if ($tip[prop] !== _this4[prop]) {
            $tip[prop] = _this4[prop];
          }
        });
      }
    },
    // --- Show/Hide handlers ---
    // Show the tooltip
    show: function show() {
      var target = this.getTarget();

      if (!target || !dom_contains(document.body, target) || !isVisible(target) || this.dropdownOpen() || (isUndefinedOrNull(this.title) || this.title === "") && (isUndefinedOrNull(this.content) || this.content === "")) {
        // If trigger element isn't in the DOM or is not visible, or
        // is on an open dropdown toggle, or has no content, then
        // we exit without showing
        return;
      } // If tip already exists, exit early


      if (this.$_tip || this.localShow) {
        /* istanbul ignore next */
        return;
      } // In the process of showing


      this.localShow = true;
      var showEvt = this.buildEvent("show", {
        cancelable: true
      });
      this.emitEvent(showEvt); // Don't show if event cancelled

      /* istanbul ignore next: ignore for now */

      if (showEvt.defaultPrevented) {
        // Destroy the template (if for some reason it was created)

        /* istanbul ignore next */
        this.destroyTemplate();
        /* istanbul ignore next */

        return;
      } // Fix the title attribute on target


      this.fixTitle(); // Set aria-describedby on target

      this.addAriaDescribedby(); // Create and show the tooltip

      this.createTemplateAndShow();
    },
    hide: function hide() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      // Hide the tooltip
      var tip = this.getTemplateElement();

      if (!tip || !this.localShow) {
        /* istanbul ignore next */
        this.restoreTitle();
        /* istanbul ignore next */

        return;
      } // We disable cancelling if `force` is true


      var hideEvt = this.buildEvent("hide", {
        cancelable: !force
      });
      this.emitEvent(hideEvt);
      /* istanbul ignore next: ignore for now */

      if (hideEvt.defaultPrevented) {
        // Don't hide if event cancelled

        /* istanbul ignore next */
        return;
      } // Tell the template to hide


      this.hideTemplate();
    },
    forceHide: function forceHide() {
      // Forcefully hides/destroys the template, regardless of any active triggers
      var tip = this.getTemplateElement();

      if (!tip || !this.localShow) {
        /* istanbul ignore next */
        return;
      } // Disable while open listeners/watchers
      // This is also done in the template `hide` evt handler


      this.setWhileOpenListeners(false); // Clear any hover enter/leave event

      this.clearHoverTimeout();
      this.$_hoverState = "";
      this.clearActiveTriggers(); // Disable the fade animation on the template

      if (this.$_tip) {
        this.$_tip.noFade = true;
      } // Hide the tip (with force = true)


      this.hide(true);
    },
    enable: function enable() {
      this.$_enabled = true;
      this.emitEvent(this.buildEvent("enabled"));
    },
    disable: function disable() {
      this.$_enabled = false;
      this.emitEvent(this.buildEvent("disabled"));
    },
    // --- Handlers for template events ---
    // When template is inserted into DOM, but not yet shown
    onTemplateShow: function onTemplateShow() {
      // Enable while open listeners/watchers
      this.setWhileOpenListeners(true);
    },
    // When template show transition completes
    onTemplateShown: function onTemplateShown() {
      var prevHoverState = this.$_hoverState;
      this.$_hoverState = "";

      if (prevHoverState === "out") {
        this.leave(null);
      }

      this.emitEvent(this.buildEvent("shown"));
    },
    // When template is starting to hide
    onTemplateHide: function onTemplateHide() {
      // Disable while open listeners/watchers
      this.setWhileOpenListeners(false);
    },
    // When template has completed closing (just before it self destructs)
    onTemplateHidden: function onTemplateHidden() {
      // Destroy the template
      this.destroyTemplate();
      this.emitEvent(this.buildEvent("hidden"));
    },
    // --- Utility methods ---
    getTarget: function getTarget() {
      // Handle case where target may be a component ref
      var target = this.target ? this.target.$el || this.target : null; // If an ID

      target = isString(target) ? getById(target.replace(/^#/, "")) : target; // If a function

      target = isFunction(target) ? target() : target; // If an element ref

      return isElement(target) ? target : null;
    },
    getPlacementTarget: function getPlacementTarget() {
      // This is the target that the tooltip will be placed on, which may not
      // necessarily be the same element that has the trigger event listeners
      // For now, this is the same as target
      // TODO:
      //   Add in child selector support
      //   Add in visibility checks for this element
      //   Fallback to target if not found
      return this.getTarget();
    },
    getTargetId: function getTargetId() {
      // Returns the ID of the trigger element
      var target = this.getTarget();
      return target && target.id ? target.id : null;
    },
    getContainer: function getContainer() {
      // Handle case where container may be a component ref
      var container = this.container ? this.container.$el || this.container : false;
      var body = document.body;
      var target = this.getTarget(); // If we are in a modal, we append to the modal instead
      // of body, unless a container is specified
      // TODO:
      //   Template should periodically check to see if it is in dom
      //   And if not, self destruct (if container got v-if'ed out of DOM)
      //   Or this could possibly be part of the visibility check

      return container === false ? closest(MODAL_SELECTOR, target) || body : isString(container) ? getById(container.replace(/^#/, "")) || body : body;
    },
    getBoundary: function getBoundary() {
      return this.boundary ? this.boundary.$el || this.boundary : "scrollParent";
    },
    isInModal: function isInModal() {
      var target = this.getTarget();
      return target && closest(MODAL_SELECTOR, target);
    },
    isDropdown: function isDropdown() {
      // Returns true if trigger is a dropdown
      var target = this.getTarget();
      return target && hasClass(target, DROPDOWN_CLASS);
    },
    dropdownOpen: function dropdownOpen() {
      // Returns true if trigger is a dropdown and the dropdown menu is open
      var target = this.getTarget();
      return this.isDropdown() && target && dom_select(DROPDOWN_OPEN_SELECTOR, target);
    },
    clearHoverTimeout: function clearHoverTimeout() {
      if (this.$_hoverTimeout) {
        clearTimeout(this.$_hoverTimeout);
        this.$_hoverTimeout = null;
      }
    },
    clearVisibilityInterval: function clearVisibilityInterval() {
      if (this.$_visibleInterval) {
        clearInterval(this.$_visibleInterval);
        this.$_visibleInterval = null;
      }
    },
    clearActiveTriggers: function clearActiveTriggers() {
      for (var trigger in this.activeTrigger) {
        this.activeTrigger[trigger] = false;
      }
    },
    addAriaDescribedby: function addAriaDescribedby() {
      // Add aria-describedby on trigger element, without removing any other IDs
      var target = this.getTarget();
      var desc = getAttr(target, "aria-describedby") || "";
      desc = desc.split(/\s+/).concat(this.computedId).join(" ").trim(); // Update/add aria-described by

      setAttr(target, "aria-describedby", desc);
    },
    removeAriaDescribedby: function removeAriaDescribedby() {
      var _this5 = this;

      // Remove aria-describedby on trigger element, without removing any other IDs
      var target = this.getTarget();
      var desc = getAttr(target, "aria-describedby") || "";
      desc = desc.split(/\s+/).filter(function (d) {
        return d !== _this5.computedId;
      }).join(" ").trim(); // Update or remove aria-describedby

      if (desc) {
        /* istanbul ignore next */
        setAttr(target, "aria-describedby", desc);
      } else {
        removeAttr(target, "aria-describedby");
      }
    },
    fixTitle: function fixTitle() {
      // If the target has a title attribute, null it out and
      // store on data-title
      var target = this.getTarget();

      if (target && getAttr(target, "title")) {
        // We only update title attribute if it has a value
        setAttr(target, "data-original-title", getAttr(target, "title") || "");
        setAttr(target, "title", "");
      }
    },
    restoreTitle: function restoreTitle() {
      // If target had a title, restore the title attribute
      // and remove the data-title attribute
      var target = this.getTarget();

      if (target && hasAttr(target, "data-original-title")) {
        setAttr(target, "title", getAttr(target, "data-original-title") || "");
        removeAttr(target, "data-original-title");
      }
    },
    buildEvent: function buildEvent(type) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // Defaults to a non-cancellable event
      return new nly_event_class_NlyEvent(type, Object(objectSpread2["a" /* default */])({
        cancelable: false,
        target: this.getTarget(),
        relatedTarget: this.getTemplateElement() || null,
        componentId: this.computedId,
        vueTarget: this
      }, options));
    },
    emitEvent: function emitEvent(nlyaEvt) {
      var evtName = nlyaEvt.type;
      var $root = this.$root;

      if ($root && $root.$emit) {
        // Emit an event on $root
        $root.$emit("nlya::".concat(this.templateType, "::").concat(evtName), nlyaEvt);
      }

      this.$emit(evtName, nlyaEvt);
    },
    // --- Event handler setup methods ---
    listen: function listen() {
      var _this6 = this;

      // Enable trigger event handlers
      var el = this.getTarget();

      if (!el) {
        /* istanbul ignore next */
        return;
      } // Listen for global show/hide events


      this.setRootListener(true); // Set up our listeners on the target trigger element

      this.computedTriggers.forEach(function (trigger) {
        if (trigger === "click") {
          eventOn(el, "click", _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);
        } else if (trigger === "focus") {
          eventOn(el, "focusin", _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);
          eventOn(el, "focusout", _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);
        } else if (trigger === "blur") {
          // Used to close $tip when element looses focus

          /* istanbul ignore next */
          eventOn(el, "focusout", _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);
        } else if (trigger === "hover") {
          eventOn(el, "mouseenter", _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);
          eventOn(el, "mouseleave", _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);
        }
      }, this);
    },
    unListen: function unListen()
    /* istanbul ignore next */
    {
      var _this7 = this;

      // Remove trigger event handlers
      var events = ["click", "focusin", "focusout", "mouseenter", "mouseleave"];
      var target = this.getTarget(); // Stop listening for global show/hide/enable/disable events

      this.setRootListener(false); // Clear out any active target listeners

      events.forEach(function (evt) {
        target && eventOff(target, evt, _this7.handleEvent, EVENT_OPTIONS_NO_CAPTURE);
      }, this);
    },
    setRootListener: function setRootListener(on) {
      var $root = this.$root;

      if ($root) {
        var method = on ? "$on" : "$off";
        var type = this.templateType;
        $root[method]("nlya::hide::".concat(type), this.doHide);
        $root[method]("nlya::show::".concat(type), this.doShow);
        $root[method]("nlya::disable::".concat(type), this.doDisable);
        $root[method]("nlya::enable::".concat(type), this.doEnable);
      }
    },
    setWhileOpenListeners: function setWhileOpenListeners(on) {
      // Events that are only registered when the template is showing
      // Modal close events
      this.setModalListener(on); // Dropdown open events (if we are attached to a dropdown)

      this.setDropdownListener(on); // Periodic $element visibility check
      // For handling when tip target is in <keepalive>, tabs, carousel, etc

      this.visibleCheck(on); // On-touch start listeners

      this.setOnTouchStartListener(on);
    },
    // Handler for periodic visibility check
    visibleCheck: function visibleCheck(on) {
      var _this8 = this;

      this.clearVisibilityInterval();
      var target = this.getTarget();
      var tip = this.getTemplateElement();

      if (on) {
        this.$_visibleInterval = setInterval(function () {
          if (tip && _this8.localShow && (!target.parentNode || !isVisible(target))) {
            // Target element is no longer visible or not in DOM, so force-hide the tooltip
            _this8.forceHide();
          }
        }, 100);
      }
    },
    setModalListener: function setModalListener(on) {
      // Handle case where tooltip/target is in a modal
      if (this.isInModal()) {
        // We can listen for modal hidden events on `$root`
        this.$root[on ? "$on" : "$off"](MODAL_CLOSE_EVENT, this.forceHide);
      }
    },
    setOnTouchStartListener: function setOnTouchStartListener(on)
    /* istanbul ignore next: JSDOM doesn't support `ontouchstart` */
    {
      var _this9 = this;

      // If this is a touch-enabled device we add extra empty
      // `mouseover` listeners to the body's immediate children
      // Only needed because of broken event delegation on iOS
      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
      if ("ontouchstart" in document.documentElement) {
        from(document.body.children).forEach(function (el) {
          eventOnOff(on, el, "mouseover", _this9.$_noop);
        });
      }
    },
    setDropdownListener: function setDropdownListener(on) {
      var target = this.getTarget();

      if (!target || !this.$root || !this.isDropdown) {
        return;
      } // We can listen for dropdown shown events on its instance
      // TODO:
      //   We could grab the ID from the dropdown, and listen for
      //   $root events for that particular dropdown id
      //   Dropdown shown and hidden events will need to emit
      //   Note: Dropdown auto-ID happens in a `$nextTick()` after mount
      //         So the ID lookup would need to be done in a `$nextTick()`


      if (target.__vue__) {
        target.__vue__[on ? "$on" : "$off"]("shown", this.forceHide);
      }
    },
    // --- Event handlers ---
    handleEvent: function handleEvent(evt) {
      // General trigger event handler
      // target is the trigger element
      var target = this.getTarget();

      if (!target || dom_isDisabled(target) || !this.$_enabled || this.dropdownOpen()) {
        // If disabled or not enabled, or if a dropdown that is open, don't do anything
        // If tip is shown before element gets disabled, then tip will not
        // close until no longer disabled or forcefully closed
        return;
      }

      var type = evt.type;
      var triggers = this.computedTriggers;

      if (type === "click" && arrayIncludes(triggers, "click")) {
        this.click(evt);
      } else if (type === "mouseenter" && arrayIncludes(triggers, "hover")) {
        // `mouseenter` is a non-bubbling event
        this.enter(evt);
      } else if (type === "focusin" && arrayIncludes(triggers, "focus")) {
        // `focusin` is a bubbling event
        // `evt` includes `relatedTarget` (element loosing focus)
        this.enter(evt);
      } else if (type === "focusout" && (arrayIncludes(triggers, "focus") || arrayIncludes(triggers, "blur")) || type === "mouseleave" && arrayIncludes(triggers, "hover")) {
        // `focusout` is a bubbling event
        // `mouseleave` is a non-bubbling event
        // `tip` is the template (will be null if not open)
        var tip = this.getTemplateElement(); // `evtTarget` is the element which is loosing focus/hover and

        var evtTarget = evt.target; // `relatedTarget` is the element gaining focus/hover

        var relatedTarget = evt.relatedTarget;
        /* istanbul ignore next */

        if ( // From tip to target
        tip && dom_contains(tip, evtTarget) && dom_contains(target, relatedTarget) || // From target to tip
        tip && dom_contains(target, evtTarget) && dom_contains(tip, relatedTarget) || // Within tip
        tip && dom_contains(tip, evtTarget) && dom_contains(tip, relatedTarget) || // Within target
        dom_contains(target, evtTarget) && dom_contains(target, relatedTarget)) {
          // If focus/hover moves within `tip` and `target`, don't trigger a leave
          return;
        } // Otherwise trigger a leave


        this.leave(evt);
      }
    },
    doHide: function doHide(id) {
      // Programmatically hide tooltip or popover
      if (!id || this.getTargetId() === id || this.computedId === id) {
        // Close all tooltips or popovers, or this specific tip (with ID)
        this.forceHide();
      }
    },
    doShow: function doShow(id) {
      // Programmatically show tooltip or popover
      if (!id || this.getTargetId() === id || this.computedId === id) {
        // Open all tooltips or popovers, or this specific tip (with ID)
        this.show();
      }
    },
    doDisable: function doDisable(id)
    /*istanbul ignore next: ignore for now */
    {
      // Programmatically disable tooltip or popover
      if (!id || this.getTargetId() === id || this.computedId === id) {
        // Disable all tooltips or popovers (no ID), or this specific tip (with ID)
        this.disable();
      }
    },
    doEnable: function doEnable(id)
    /*istanbul ignore next: ignore for now */
    {
      // Programmatically enable tooltip or popover
      if (!id || this.getTargetId() === id || this.computedId === id) {
        // Enable all tooltips or popovers (no ID), or this specific tip (with ID)
        this.enable();
      }
    },
    click: function click() {
      if (!this.$_enabled || this.dropdownOpen()) {
        /* istanbul ignore next */
        return;
      }

      this.activeTrigger.click = !this.activeTrigger.click;

      if (this.isWithActiveTrigger) {
        this.enter(null);
      } else {
        /* istanbul ignore next */
        this.leave(null);
      }
    },
    toggle: function toggle()
    /* istanbul ignore next */
    {
      // Manual toggle handler
      if (!this.$_enabled || this.dropdownOpen()) {
        /* istanbul ignore next */
        return;
      } // Should we register as an active trigger?
      // this.activeTrigger.manual = !this.activeTrigger.manual


      if (this.localShow) {
        this.leave(null);
      } else {
        this.enter(null);
      }
    },
    enter: function enter() {
      var _this10 = this;

      var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      // Opening trigger handler
      // Note: Click events are sent with evt === null
      if (evt) {
        this.activeTrigger[evt.type === "focusin" ? "focus" : "hover"] = true;
      }
      /* istanbul ignore next */


      if (this.localShow || this.$_hoverState === "in") {
        this.$_hoverState = "in";
        return;
      }

      this.clearHoverTimeout();
      this.$_hoverState = "in";

      if (!this.computedDelay.show) {
        this.show();
      } else {
        // Hide any title attribute while enter delay is active
        this.fixTitle();
        this.$_hoverTimeout = setTimeout(function () {
          /* istanbul ignore else */
          if (_this10.$_hoverState === "in") {
            _this10.show();
          } else if (!_this10.localShow) {
            _this10.restoreTitle();
          }
        }, this.computedDelay.show);
      }
    },
    leave: function leave() {
      var _this11 = this;

      var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      // Closing trigger handler
      // Note: Click events are sent with evt === null
      if (evt) {
        this.activeTrigger[evt.type === "focusout" ? "focus" : "hover"] = false;
        /* istanbul ignore next */

        if (evt.type === "focusout" && arrayIncludes(this.computedTriggers, "blur")) {
          // Special case for `blur`: we clear out the other triggers
          this.activeTrigger.click = false;
          this.activeTrigger.hover = false;
        }
      }
      /* istanbul ignore next: ignore for now */


      if (this.isWithActiveTrigger) {
        return;
      }

      this.clearHoverTimeout();
      this.$_hoverState = "out";

      if (!this.computedDelay.hide) {
        this.hide();
      } else {
        this.$_hoverTimeout = setTimeout(function () {
          if (_this11.$_hoverState === "out") {
            _this11.hide();
          }
        }, this.computedDelay.hide);
      }
    }
  }
});
// CONCATENATED MODULE: ./src/components/tooltip/tooltip.js









var tooltip_NAME = "NlyTooltip"; // @vue/component

var NlyTooltip = utils_vue.extend({
  name: tooltip_NAME,
  props: {
    title: {
      type: String // default: undefined

    },
    // Added in by BPopover
    // content: {
    //   type: String,
    //   default: undefined
    // },
    target: {
      type: [String, safe_types_HTMLElement, safe_types_SVGElement, Function, Object],
      required: true
    },
    triggers: {
      type: [String, Array],
      default: "hover focus"
    },
    placement: {
      type: String,
      default: "top"
    },
    fallbackPlacement: {
      type: [String, Array],
      default: "flip",
      validator: function validator(value) {
        return isArray(value) && value.every(function (v) {
          return isString(v);
        }) || arrayIncludes(["flip", "clockwise", "counterclockwise"], value);
      }
    },
    variant: {
      type: String,
      default: function _default() {
        return getComponentConfig(tooltip_NAME, "variant");
      }
    },
    customClass: {
      type: String,
      default: function _default() {
        return getComponentConfig(tooltip_NAME, "customClass");
      }
    },
    delay: {
      type: [Number, Object, String],
      default: function _default() {
        return getComponentConfig(tooltip_NAME, "delay");
      }
    },
    boundary: {
      // String: scrollParent, window, or viewport
      // Element: element reference
      // Object: Vue component
      type: [String, safe_types_HTMLElement, Object],
      default: function _default() {
        return getComponentConfig(tooltip_NAME, "boundary");
      }
    },
    boundaryPadding: {
      type: [Number, String],
      default: function _default() {
        return getComponentConfig(tooltip_NAME, "boundaryPadding");
      }
    },
    offset: {
      type: [Number, String],
      default: 0
    },
    noFade: {
      type: Boolean,
      default: false
    },
    container: {
      // String: HTML ID of container, if null body is used (default)
      // HTMLElement: element reference reference
      // Object: Vue Component
      type: [String, safe_types_HTMLElement, Object] // default: undefined

    },
    show: {
      type: Boolean,
      default: false
    },
    noninteractive: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    id: {
      // ID to use for tooltip element
      // If not provided on will automatically be generated
      type: String,
      default: null
    }
  },
  data: function data() {
    return {
      localShow: this.show,
      localTitle: "",
      localContent: ""
    };
  },
  computed: {
    templateData: function templateData() {
      // Data that will be passed to the template and popper
      return {
        // We use massaged versions of the title and content props/slots
        title: this.localTitle,
        content: this.localContent,
        // Pass these props as is
        target: this.target,
        triggers: this.triggers,
        placement: this.placement,
        fallbackPlacement: this.fallbackPlacement,
        variant: this.variant,
        customClass: this.customClass,
        container: this.container,
        boundary: this.boundary,
        boundaryPadding: this.boundaryPadding,
        delay: this.delay,
        offset: this.offset,
        noFade: this.noFade,
        interactive: !this.noninteractive,
        disabled: this.disabled,
        id: this.id
      };
    },
    templateTitleContent: function templateTitleContent() {
      // Used to watch for changes to the title and content props
      return {
        title: this.title,
        content: this.content
      };
    }
  },
  watch: {
    show: function show(_show, oldVal) {
      if (_show !== oldVal && _show !== this.localShow && this.$_nly_toolpop) {
        if (_show) {
          this.$_nly_toolpop.show();
        } else {
          // We use `forceHide()` to override any active triggers
          this.$_nly_toolpop.forceHide();
        }
      }
    },
    disabled: function disabled(newVal) {
      if (newVal) {
        this.doDisable();
      } else {
        this.doEnable();
      }
    },
    localShow: function localShow(newVal) {
      // TODO: May need to be done in a `$nextTick()`
      this.$emit("update:show", newVal);
    },
    templateData: function templateData() {
      var _this = this;

      this.$nextTick(function () {
        if (_this.$_nly_toolpop) {
          _this.$_nly_toolpop.updateData(_this.templateData);
        }
      });
    },
    // Watchers for title/content props (prop changes do not trigger the `updated()` hook)
    templateTitleContent: function templateTitleContent() {
      this.$nextTick(this.updateContent);
    }
  },
  created: function created() {
    // Non reactive properties
    this.$_nly_toolpop = null;
  },
  updated: function updated() {
    // Update the `propData` object
    // Done in a `$nextTick()` to ensure slot(s) have updated
    this.$nextTick(this.updateContent);
  },
  beforeDestroy: function beforeDestroy() {
    // Shutdown our local event listeners
    this.$off("open", this.doOpen);
    this.$off("close", this.doClose);
    this.$off("disable", this.doDisable);
    this.$off("enable", this.doEnable); // Destroy the tip instance

    this.$_nly_toolpop && this.$_nly_toolpop.$destroy();
    this.$_nly_toolpop = null;
  },
  mounted: function mounted() {
    var _this2 = this;

    // Instantiate a new nlyTooltip instance
    // Done in a `$nextTick()` to ensure DOM has completed rendering
    // so that target can be found
    this.$nextTick(function () {
      // Load the on demand child instance
      var Component = _this2.getComponent(); // Ensure we have initial content


      _this2.updateContent(); // Pass down the scoped style attribute if available


      var scopeId = get_scope_id(_this2) || get_scope_id(_this2.$parent); // Create the instance

      var $toolpop = _this2.$_nly_toolpop = new Component({
        parent: _this2,
        // Pass down the scoped style ID
        _scopeId: scopeId || undefined
      }); // Set the initial data

      $toolpop.updateData(_this2.templateData); // Set listeners

      $toolpop.$on("show", _this2.onShow);
      $toolpop.$on("shown", _this2.onShown);
      $toolpop.$on("hide", _this2.onHide);
      $toolpop.$on("hidden", _this2.onHidden);
      $toolpop.$on("disabled", _this2.onDisabled);
      $toolpop.$on("enabled", _this2.onEnabled); // Initially disabled?

      if (_this2.disabled) {
        // Initially disabled
        _this2.doDisable();
      } // Listen to open signals from others


      _this2.$on("open", _this2.doOpen); // Listen to close signals from others


      _this2.$on("close", _this2.doClose); // Listen to disable signals from others


      _this2.$on("disable", _this2.doDisable); // Listen to enable signals from others


      _this2.$on("enable", _this2.doEnable); // Initially show tooltip?


      if (_this2.localShow) {
        _this2.$_nly_toolpop && _this2.$_nly_toolpop.show();
      }
    });
  },
  methods: {
    getComponent: function getComponent() {
      // Overridden by BPopover
      return NlyaTooltip;
    },
    updateContent: function updateContent() {
      // Overridden by BPopover
      // Tooltip: Default slot is `title`
      // Popover: Default slot is `content`, `title` slot is title
      // We pass a scoped slot function reference by default (Vue v2.6x)
      // And pass the title prop as a fallback
      this.setTitle(this.$scopedSlots.default || this.title);
    },
    // Helper methods for `updateContent()`
    setTitle: function setTitle(val) {
      val = isUndefinedOrNull(val) ? "" : val; // We only update the value if it has changed

      if (this.localTitle !== val) {
        this.localTitle = val;
      }
    },
    setContent: function setContent(val) {
      val = isUndefinedOrNull(val) ? "" : val; // We only update the value if it has changed

      if (this.localContent !== val) {
        this.localContent = val;
      }
    },
    // --- Template event handlers ---
    onShow: function onShow(nlyaEvt) {
      // Placeholder
      this.$emit("show", nlyaEvt);

      if (nlyaEvt) {
        this.localShow = !nlyaEvt.defaultPrevented;
      }
    },
    onShown: function onShown(nlyaEvt) {
      // Tip is now showing
      this.localShow = true;
      this.$emit("shown", nlyaEvt);
    },
    onHide: function onHide(nlyaEvt) {
      this.$emit("hide", nlyaEvt);
    },
    onHidden: function onHidden(nlyaEvt) {
      // Tip is no longer showing
      this.$emit("hidden", nlyaEvt);
      this.localShow = false;
    },
    onDisabled: function onDisabled(nlyaEvt) {
      // Prevent possible endless loop if user mistakenly
      // fires `disabled` instead of `disable`
      if (nlyaEvt && nlyaEvt.type === "disabled") {
        this.$emit("update:disabled", true);
        this.$emit("disabled", nlyaEvt);
      }
    },
    onEnabled: function onEnabled(nlyaEvt) {
      // Prevent possible endless loop if user mistakenly
      // fires `enabled` instead of `enable`
      if (nlyaEvt && nlyaEvt.type === "enabled") {
        this.$emit("update:disabled", false);
        this.$emit("enabled", nlyaEvt);
      }
    },
    // --- Local event listeners ---
    doOpen: function doOpen() {
      !this.localShow && this.$_nly_toolpop && this.$_nly_toolpop.show();
    },
    doClose: function doClose() {
      this.localShow && this.$_nly_toolpop && this.$_nly_toolpop.hide();
    },
    doDisable: function doDisable() {
      this.$_nly_toolpop && this.$_nly_toolpop.disable();
    },
    doEnable: function doEnable() {
      this.$_nly_toolpop && this.$_nly_toolpop.enable();
    }
  },
  render: function render(h) {
    // Always renders a comment node
    // TODO:
    //   Future: Possibly render a target slot (single root element)
    //   which we can apply the listeners to (pass `this.$el` to nlyTooltip)
    return h();
  }
});
// CONCATENATED MODULE: ./src/components/popover/plugin/nlya-popover-template.js



var nlya_popover_template_NAME = "NlyaPopoverTemplate"; // @vue/component

var NlyaPopoverTemplate = /*#__PURE__*/utils_vue.extend({
  name: nlya_popover_template_NAME,
  extends: NlyaTooltipTemplate,
  computed: {
    templateType: function templateType() {
      return "popover";
    }
  },
  methods: {
    renderTemplate: function renderTemplate(h) {
      // Title and content could be a scoped slot function
      var $title = isFunction(this.title) ? this.title({}) : this.title;
      var $content = isFunction(this.content) ? this.content({}) : this.content; // Directive usage only

      var titleDomProps = this.html && !isFunction(this.title) ? {
        innerHTML: this.title
      } : {};
      var contentDomProps = this.html && !isFunction(this.content) ? {
        innerHTML: this.content
      } : {};
      return h("div", {
        staticClass: "popover nly-popover",
        class: this.templateClasses,
        attrs: this.templateAttributes,
        on: this.templateListeners
      }, [h("div", {
        ref: "arrow",
        staticClass: "arrow"
      }), isUndefinedOrNull($title) || $title === "" ?
      /* istanbul ignore next */
      h() : h("h3", {
        staticClass: "popover-header",
        domProps: titleDomProps
      }, [$title]), isUndefinedOrNull($content) || $content === "" ?
      /* istanbul ignore next */
      h() : h("div", {
        staticClass: "popover-body",
        domProps: contentDomProps
      }, [$content])]);
    }
  }
});
// CONCATENATED MODULE: ./src/components/popover/plugin/nlya-popover.js
// Popover "Class" (Built as a renderless Vue instance)
// Inherits from NlyaTooltip
//
// Handles trigger events, etc.
// Instantiates template on demand



var nlya_popover_NAME = "NlyaPopover"; // @vue/component

var NlyaPopover = /*#__PURE__*/utils_vue.extend({
  name: nlya_popover_NAME,
  extends: NlyaTooltip,
  computed: {
    // Overwrites NlyaTooltip
    templateType: function templateType() {
      return "popover";
    }
  },
  methods: {
    getTemplate: function getTemplate() {
      // Overwrites NlyaTooltip
      return NlyaPopoverTemplate;
    }
  }
});
// CONCATENATED MODULE: ./src/components/popover/popover.js






var popover_NAME = "NlyPopover";
var NlyPopover = /*#__PURE__*/utils_vue.extend({
  name: popover_NAME,
  extends: NlyTooltip,
  inheritAttrs: false,
  props: {
    title: {
      type: String // default: undefined

    },
    content: {
      type: String // default: undefined

    },
    triggers: {
      type: [String, Array],
      default: "click"
    },
    placement: {
      type: String,
      default: "right"
    },
    variant: {
      type: String,
      default: function _default() {
        return getComponentConfig(popover_NAME, "variant");
      }
    },
    customClass: {
      type: String,
      default: function _default() {
        return getComponentConfig(popover_NAME, "customClass");
      }
    },
    delay: {
      type: [Number, Object, String],
      default: function _default() {
        return getComponentConfig(popover_NAME, "delay");
      }
    },
    boundary: {
      // String: scrollParent, window, or viewport
      // Element: element reference
      // Object: Vue component
      type: [String, safe_types_HTMLElement, Object],
      default: function _default() {
        return getComponentConfig(popover_NAME, "boundary");
      }
    },
    boundaryPadding: {
      type: [Number, String],
      default: function _default() {
        return getComponentConfig(popover_NAME, "boundaryPadding");
      }
    }
  },
  methods: {
    getComponent: function getComponent() {
      // Overridden by BPopover
      return NlyaPopover;
    },
    updateContent: function updateContent() {
      // Tooltip: Default slot is `title`
      // Popover: Default slot is `content`, `title` slot is title
      // We pass a scoped slot function references by default (Vue v2.6x)
      // And pass the title prop as a fallback
      this.setContent(this.$scopedSlots.default || this.content);
      this.setTitle(this.$scopedSlots.title || this.title);
    }
  } // Render function provided by BTooltip

});
// CONCATENATED MODULE: ./src/directives/popover/popover.js


















 // Key which we use to store tooltip object on element

var NLYA_POPOVER = "__NLYA_Popover__"; // Default trigger

var DefaultTrigger = "click"; // Valid event triggers

var validTriggers = {
  focus: true,
  hover: true,
  click: true,
  blur: true,
  manual: true
}; // Directive modifier test regular expressions. Pre-compile for performance

var htmlRE = /^html$/i;
var noFadeRE = /^nofade$/i;
var placementRE = /^(auto|top(left|right)?|bottom(left|right)?|left(top|bottom)?|right(top|bottom)?)$/i;
var boundaryRE = /^(window|viewport|scrollParent)$/i;
var delayRE = /^d\d+$/i;
var delayShowRE = /^ds\d+$/i;
var delayHideRE = /^dh\d+$/i;
var offsetRE = /^o-?\d+$/i;
var variantRE = /^v-.+$/i;
var spacesRE = /\s+/; // Build a Popover config based on bindings (if any)
// Arguments and modifiers take precedence over passed value config object

var popover_parseBindings = function parseBindings(bindings, vnode)
/* istanbul ignore next: not easy to test */
{
  // We start out with a basic config
  var NAME = "NlyPopover";
  var config = {
    title: undefined,
    content: undefined,
    trigger: "",
    // Default set below if needed
    placement: "right",
    fallbackPlacement: "flip",
    container: false,
    // Default of body
    animation: true,
    offset: 0,
    disabled: false,
    id: null,
    html: false,
    delay: getComponentConfig(NAME, "delay"),
    boundary: String(getComponentConfig(NAME, "boundary")),
    boundaryPadding: toInteger(getComponentConfig(NAME, "boundaryPadding"), 0),
    variant: getComponentConfig(NAME, "variant"),
    customClass: getComponentConfig(NAME, "customClass")
  }; // Process `bindings.value`

  if (isString(bindings.value) || isNumber(bindings.value)) {
    // Value is popover content (html optionally supported)
    config.content = bindings.value;
  } else if (isFunction(bindings.value)) {
    // Content generator function
    config.content = bindings.value;
  } else if (isPlainObject(bindings.value)) {
    // Value is config object, so merge
    config = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, config), bindings.value);
  } // If argument, assume element ID of container element


  if (bindings.arg) {
    // Element ID specified as arg
    // We must prepend '#' to become a CSS selector
    config.container = "#".concat(bindings.arg);
  } // If title is not provided, try title attribute


  if (isUndefined(config.title)) {
    // Try attribute
    var data = vnode.data || {};
    config.title = data.attrs && !isUndefinedOrNull(data.attrs.title) ? data.attrs.title : undefined;
  } // Normalize delay


  if (!isPlainObject(config.delay)) {
    config.delay = {
      show: toInteger(config.delay, 0),
      hide: toInteger(config.delay, 0)
    };
  } // Process modifiers


  keys(bindings.modifiers).forEach(function (mod) {
    if (htmlRE.test(mod)) {
      // Title/content allows HTML
      config.html = true;
    } else if (noFadeRE.test(mod)) {
      // No animation
      config.animation = false;
    } else if (placementRE.test(mod)) {
      // Placement of popover
      config.placement = mod;
    } else if (boundaryRE.test(mod)) {
      // Boundary of popover
      mod = mod === "scrollparent" ? "scrollParent" : mod;
      config.boundary = mod;
    } else if (delayRE.test(mod)) {
      // Delay value
      var delay = toInteger(mod.slice(1), 0);
      config.delay.show = delay;
      config.delay.hide = delay;
    } else if (delayShowRE.test(mod)) {
      // Delay show value
      config.delay.show = toInteger(mod.slice(2), 0);
    } else if (delayHideRE.test(mod)) {
      // Delay hide value
      config.delay.hide = toInteger(mod.slice(2), 0);
    } else if (offsetRE.test(mod)) {
      // Offset value, negative allowed
      config.offset = toInteger(mod.slice(1), 0);
    } else if (variantRE.test(mod)) {
      // Variant
      config.variant = mod.slice(2) || null;
    }
  }); // Special handling of event trigger modifiers trigger is
  // a space separated list

  var selectedTriggers = {}; // Parse current config object trigger

  concat(config.trigger || "").filter(utils_identity).join(" ").trim().toLowerCase().split(spacesRE).forEach(function (trigger) {
    if (validTriggers[trigger]) {
      selectedTriggers[trigger] = true;
    }
  }); // Parse modifiers for triggers

  keys(bindings.modifiers).forEach(function (mod) {
    mod = mod.toLowerCase();

    if (validTriggers[mod]) {
      // If modifier is a valid trigger
      selectedTriggers[mod] = true;
    }
  }); // Sanitize triggers

  config.trigger = keys(selectedTriggers).join(" ");

  if (config.trigger === "blur") {
    // Blur by itself is useless, so convert it to 'focus'
    config.trigger = "focus";
  }

  if (!config.trigger) {
    // Use default trigger
    config.trigger = DefaultTrigger;
  }

  return config;
}; // Add or update Popover on our element


var popover_applyPopover = function applyPopover(el, bindings, vnode) {
  if (!env["g" /* isBrowser */]) {
    /* istanbul ignore next */
    return;
  }

  var config = popover_parseBindings(bindings, vnode);

  if (!el[NLYA_POPOVER]) {
    var $parent = vnode.context;
    el[NLYA_POPOVER] = new NlyaPopover({
      parent: $parent,
      // Add the parent's scoped style attribute data
      _scopeId: get_scope_id($parent, undefined)
    });
    el[NLYA_POPOVER].__nlya_prev_data__ = {};
    el[NLYA_POPOVER].$on("show", function ()
    /* istanbul ignore next: for now */
    {
      // Before showing the popover, we update the title
      // and content if they are functions
      var data = {};

      if (isFunction(config.title)) {
        data.title = config.title(el);
      }

      if (isFunction(config.content)) {
        data.content = config.content(el);
      }

      if (keys(data).length > 0) {
        el[NLYA_POPOVER].updateData(data);
      }
    });
  }

  var data = {
    title: config.title,
    content: config.content,
    triggers: config.trigger,
    placement: config.placement,
    fallbackPlacement: config.fallbackPlacement,
    variant: config.variant,
    customClass: config.customClass,
    container: config.container,
    boundary: config.boundary,
    delay: config.delay,
    offset: config.offset,
    noFade: !config.animation,
    id: config.id,
    disabled: config.disabled,
    html: config.html
  };
  var oldData = el[NLYA_POPOVER].__nlya_prev_data__;
  el[NLYA_POPOVER].__nlya_prev_data__ = data;

  if (!loose_equal(data, oldData)) {
    // We only update the instance if data has changed
    var newData = {
      target: el
    };
    keys(data).forEach(function (prop) {
      // We only pass data properties that have changed
      if (data[prop] !== oldData[prop]) {
        // If title/content is a function, we execute it here
        newData[prop] = (prop === "title" || prop === "content") && isFunction(data[prop]) ?
        /* istanbul ignore next */
        data[prop](el) : data[prop];
      }
    });
    el[NLYA_POPOVER].updateData(newData);
  }
}; // Remove Popover from our element


var removePopover = function removePopover(el) {
  if (el[NLYA_POPOVER]) {
    el[NLYA_POPOVER].$destroy();
    el[NLYA_POPOVER] = null;
  }

  delete el[NLYA_POPOVER];
}; // Export our directive


var VNlyPopover = {
  bind: function bind(el, bindings, vnode) {
    popover_applyPopover(el, bindings, vnode);
  },
  // We use `componentUpdated` here instead of `update`, as the former
  // waits until the containing component and children have finished updating
  componentUpdated: function componentUpdated(el, bindings, vnode) {
    // Performed in a `$nextTick()` to prevent endless render/update loops
    vnode.context.$nextTick(function () {
      popover_applyPopover(el, bindings, vnode);
    });
  },
  unbind: function unbind(el) {
    removePopover(el);
  }
};
// CONCATENATED MODULE: ./src/directives/popover/index.js


var VNlyPopoverPlugin = plugins_nlyPluginFactory({
  directives: {
    VNlyPopover: VNlyPopover
  }
});

// CONCATENATED MODULE: ./src/components/popover/index.js



var PopoverPlugin = plugins_nlyPluginFactory({
  components: {
    NlyPopover: NlyPopover
  },
  plugins: {
    VNlyPopoverPlugin: VNlyPopoverPlugin
  }
});

// CONCATENATED MODULE: ./src/components/progress/index.js




var ProgressPlugin = plugins_nlyPluginFactory({
  components: {
    NlyProgress: NlyProgress,
    NlyProgressBar: NlyProgressBar,
    NlyProgressDescription: NlyProgressDescription
  }
});

// CONCATENATED MODULE: ./src/components/search-select/plugin/mixin-options.js



/* harmony default export */ var plugin_mixin_options = ({
  mixins: [form_options],
  props: {
    labelField: {
      type: String,
      default: "label"
    },
    optionsField: {
      type: String,
      default: "options"
    }
  },
  methods: {
    normalizeOption: function normalizeOption(option) {
      var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (isPlainObject(option)) {
        var value = utils_get(option, this.valueField);
        var text = utils_get(option, this.textField);
        var options = utils_get(option, this.optionsField, null);

        if (!isNull(options)) {
          return {
            label: String(utils_get(option, this.labelField) || text),
            options: this.normalizeOptions(options)
          };
        }

        return {
          value: isUndefined(value) ? key || text : value,
          text: String(isUndefined(text) ? key : text),
          html: utils_get(option, this.htmlField),
          disabled: Boolean(utils_get(option, this.disabledField)),
          selected: false
        };
      }

      return {
        value: key || option,
        text: String(option),
        disabled: false,
        selected: false
      };
    }
  }
});
// CONCATENATED MODULE: ./src/components/search-select/plugin/select-option.js


var select_option_NAME = "NlySelectOption";
var select_option_props = {
  value: {
    required: true
  },
  disabled: {
    type: Boolean,
    default: false
  }
};
var NlySelectOption = utils_vue.extend({
  name: select_option_NAME,
  functional: true,
  props: select_option_props,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    var value = props.value,
        disabled = props.disabled;
    return h("option", lib_esm_a(data, {
      attrs: {
        disabled: disabled
      },
      domProps: {
        value: value
      }
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/search-select/plugin/select-option-group.js






var select_option_group_name = "NlySelectOptionGroup";
var NlySelectOptionGroup = utils_vue.extend({
  name: select_option_group_name,
  mixins: [mixins_normalize_slot, form_options],
  props: {
    label: {
      type: String,
      required: true
    }
  },
  render: function render(h) {
    var $options = this.formOptions.map(function (option, index) {
      var value = option.value,
          text = option.text,
          html = option.html,
          disabled = option.disabled;
      return h(NlySelectOption, {
        attrs: {
          value: value,
          disabled: disabled
        },
        domProps: htmlOrText(html, text),
        key: "option_".concat(index)
      });
    });
    return h("optgroup", {
      attrs: {
        label: this.label
      }
    }, [this.normalizeSlot("first"), $options, this.normalizeSlot("default")]);
  }
});
// CONCATENATED MODULE: ./src/components/search-select/plugin/search-select-item.js









var search_select_item_name = "NlySearchSelectItem";
var NlySearchSelectItem = utils_vue.extend({
  name: search_select_item_name,
  mixins: [mixins_id, mixins_normalize_slot, plugin_mixin_options],
  props: {
    variant: {
      type: String,
      default: null
    },
    multiple: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    customVriant: function customVriant() {
      return this.variant ? "select2-".concat(this.variant) : null;
    },
    customMultiple: function customMultiple() {
      return this.multiple ? null : "form-control";
    }
  },
  render: function render(h) {
    var $options = this.formOptions.map(function (option, index) {
      var value = option.value,
          label = option.label,
          options = option.options,
          disabled = option.disabled;
      var key = "option_".concat(index);
      return isArray(options) ? h(NlySelectOptionGroup, {
        props: {
          label: label,
          options: options
        },
        key: key
      }) : h(NlySelectOption, {
        props: {
          value: value,
          disabled: disabled
        },
        domProps: htmlOrText(option.html, option.text),
        key: key
      });
    });
    return h("select", {
      staticClass: "select2 select2-hidden-accessible",
      class: [this.customMultiple, this.customVriant],
      attrs: {
        id: this.safeId("select2_select_item"),
        multiple: this.multiple || null,
        "aria-hidden": "true",
        tabindex: "-1"
      },
      style: {
        width: "100%"
      }
    }, [this.normalizeSlot("first"), $options, this.normalizeSlot("default")]);
  }
});
// CONCATENATED MODULE: ./src/components/search-select/plugin/search-select-item-option.js







var search_select_item_option_OPTIONS_OBJECT_DEPRECATED_MSG = 'Setting prop "options" to an object is deprecated. Use the array format instead.';
/* harmony default export */ var search_select_item_option = ({
  props: {
    value: {
      type: [Array, Object],
      default: function _default() {
        return [];
      }
    },
    placeholder: {
      type: String,
      default: "Choice a field"
    },
    valueField: {
      type: String,
      default: "value"
    },
    textField: {
      type: String,
      default: "text"
    }
  },
  computed: {
    valueOptions: function valueOptions() {
      return this.normalizeOptions(this.value);
    }
  },
  methods: {
    normalizeOption: function normalizeOption(option) {
      var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (isPlainObject(option)) {
        var value = utils_get(option, this.valueField);
        var text = utils_get(option, this.textField);
        return {
          value: isUndefined(value) ? key || text : value,
          text: stripTags(String(isUndefined(text) ? key : text))
        };
      }

      return {
        value: key || option,
        text: stripTags(String(option))
      };
    },
    normalizeOptions: function normalizeOptions(options) {
      var _this = this;

      if (isArray(options)) {
        return options.map(function (option) {
          return _this.normalizeOption(option);
        });
      } else if (isPlainObject(options)) {
        warn_warn(search_select_item_option_OPTIONS_OBJECT_DEPRECATED_MSG, this.$options.name);
        return keys(options).map(function (key) {
          return _this.normalizeOption(options[key] || {}, key);
        });
      }

      return [];
    }
  }
});
// CONCATENATED MODULE: ./src/components/search-select/plugin/search-select-single-item.js
 // import { mergeData } from "vue-functional-data-merge";


var search_select_single_item_name = "NlySearchSelectSingleItem";
var NlySearchSelectSingleItem = utils_vue.extend({
  name: search_select_single_item_name,
  mixins: [search_select_item_option],
  render: function render(h) {
    return h("span", {
      staticClass: "select2-selection__rendered",
      attrs: {
        role: "textbox",
        "aria-readonly": true,
        title: this.value
      }
    }, [this.valueOptions[0] || this.placeholder, h("span", {
      staticClass: "select2-selection__arrow",
      attrs: {
        role: "presentation"
      }
    }, [h("b", {
      attrs: {
        role: "presentation"
      }
    })])]);
  }
});
// CONCATENATED MODULE: ./src/components/search-select/plugin/search-select-multiple-item.js











var search_select_multiple_item_name = "NlySearchSelectMultipleItem";
var NlySearchSelectMultipleItem = utils_vue.extend({
  name: search_select_multiple_item_name,
  mixins: [search_select_item_option],
  data: function data() {
    return {
      localValue: null
    };
  },
  // model: {
  //   prop: "value",
  //   event: "input"
  // },
  props: {
    inputFunction: {
      type: Function
    },
    removeCheckedValue: {
      type: Function
    },
    id: {
      type: String,
      default: null
    } // value: {
    //   type: [Array, Object],
    //   default: () => []
    // }

  },
  computed: {
    isInputFunction: function isInputFunction() {
      return isFunction(this.inputFunction);
    }
  },
  // created() {
  //   console.log(this.id, 2222222);
  // },
  methods: {
    updateValue: function updateValue(index, newValue) {
      newValue.splice(index, 1);
      this.removeCheckedValue(newValue);
    },
    stopRefresh: function stopRefresh(evt) {
      if (evt.preventDefault) {
        // preventDefault()方法阻止元素发生默认的行为
        evt.preventDefault();
      }

      if (evt.returnValue) {// IE浏览器下用window.event.returnValue = false;实现阻止元素发生默认的行为
      }
    },
    updateLocalValue: function updateLocalValue(localValue) {
      if (this.isInputFunction) {
        this.inputFunction(localValue);
      }
    },
    changeBackSpace: function changeBackSpace(evt) {
      var _this = this;

      var evtName = evt.target || evt.relatedTarget || evt.srcElement || evt.currentTarget;

      if (evt.keyCode === 8) {
        if (this.localValue === null || this.localValue === "") {
          if (evtName.nodeName === "INPUT") {
            this.stopRefresh(evt);
          }

          var deletedValue = this.value.slice(-1);
          this.updateValue(-1, this.value);
          this.$nextTick(function () {
            // if (isArray(deletedValue[0])) {
            //   this.$refs["nly_serach_select_multiple_input"].value =
            //     deletedValue[0];
            //   this.localValue = deletedValue[0];
            // } else if (isPlainObject(deletedValue[0])) {
            //   this.$refs["nly_serach_select_multiple_input"].value =
            //     deletedValue[0][this.textField];
            //   this.localValue = deletedValue[0][this.textField];
            // } else {
            //   this.$refs["nly_serach_select_multiple_input"].value = null;
            //   this.localValue = null;
            // }
            if (isPlainObject(deletedValue[0]) && keys(deletedValue[0]).indexOf("text") !== -1 && keys(deletedValue[0]).indexOf("value") !== -1) {
              _this.$refs["".concat(_this.id, "-input")].value = deletedValue[0].text;
              _this.localValue = deletedValue[0].text;
            } else if (isString(deletedValue[0])) {
              _this.$refs["".concat(_this.id, "-input")].value = deletedValue[0];
              _this.localValue = deletedValue[0];
            } else {
              _this.$refs["".concat(_this.id, "-input")].value = null;
              _this.localValue = null;
            }

            _this.updateLocalValue(_this.localValue);

            _this.$refs["".concat(_this.id, "-input")].focus();
          });
        }
      }
    }
  },
  watch: {
    // value: {
    //   // eslint-disable-next-line no-unused-vars
    //   handler(newValue) {
    //     this.localValue = null;
    //     this.updateLocalValue(this.localValue);
    //   }
    // },
    value: {
      // eslint-disable-next-line no-unused-vars
      handler: function handler(newValue) {
        this.localValue = null;
        this.updateLocalValue(this.localValue);
      },
      deep: true
    }
  },
  // eslint-disable-next-line no-unused-vars
  // value(newValue) {
  //   // 监控value的值， 清除localValue值, 传入的value，也就是渲染出的tag会发生变化时，清空输入框的值
  //   // 给valueOptions赋值为value的新值，即动态渲染tag
  //   // 传入 inputFunction 获取输入框最新值，此时输入框值清除了，inputFunction获取的也应该是空值
  //   this.localValue = null;
  //   this.updateLocalValue(this.localValue);
  // }
  render: function render(h) {
    var that = this; // console.log(`${that.id}-input`);

    var $multipleOptions = that.valueOptions ? that.valueOptions.map(function (item, index) {
      return h("li", {
        staticClass: "select2-selection__choice",
        attrs: {
          title: item
        }
      }, [h("span", {
        staticClass: "select2-selection__choice__remove",
        attrs: {
          role: "presentation"
        },
        title: "".concat(index, "_tags"),
        on: {
          click: function click(evt) {
            evt.stopPropagation();
            that.updateValue(index, that.value);
          }
        }
      }, "×"), item.text]);
    }) : null;
    var $multipleInput = that.valueOptions === undefined || that.valueOptions.length == [] ? h("li", {
      staticClass: "select2-search select2-search--inline"
    }, [h("input", {
      staticClass: "select2-search__field",
      attrs: {
        type: "search",
        tabindex: "0",
        autocomplete: "off",
        autocapitalize: "none",
        spellcheck: false,
        role: "searchbox",
        "aria-autocomplete": "list",
        placeholder: that.placeholder,
        id: "".concat(that.id, "-input")
      },
      style: {
        width: "100%"
      },
      domProps: {
        value: that.localValue
      },
      ref: "".concat(that.id, "-input"),
      on: {
        input: function input(evt) {
          // 阻止ime
          if (evt.target.composing) {
            return;
          } // 给 localValue 赋值为输入框输入的值


          that.localValue = evt.target.value; // 传入 inputFunction 获取输入框最新值

          if (that.isInputFunction) {
            that.inputFunction(evt.target.value);
          }
        },
        keydown: function keydown(evt) {
          that.changeBackSpace(evt);
        }
      }
    })]) : h("li", {
      staticClass: "select2-search select2-search--inline"
    }, [h("input", {
      staticClass: "select2-search__field",
      attrs: {
        type: "search",
        tabindex: "0",
        autocomplete: "off",
        autocapitalize: "none",
        spellcheck: false,
        role: "searchbox",
        "aria-autocomplete": "list",
        placeholder: "",
        id: "".concat(that.id, "-input")
      },
      style: {
        width: "100%"
      },
      domProps: {
        value: that.localValue
      },
      ref: "".concat(that.id, "-input"),
      on: {
        input: function input(evt) {
          if (evt.target.composing) {
            return;
          }

          that.localValue = evt.target.value;

          if (that.isInputFunction) {
            that.inputFunction(evt.target.value);
          }
        },
        keydown: function keydown(evt) {
          that.changeBackSpace(evt);
        }
      }
    })]);
    return h("ul", {
      staticClass: "select2-selection__rendered",
      on: Object(objectSpread2["a" /* default */])({}, self.$listeners)
    }, [$multipleOptions, $multipleInput]);
  }
});
// CONCATENATED MODULE: ./src/components/search-select/plugin/search-select-single-container.js



var search_select_single_container_name = "NlySearchSelectSingleContainer";
var search_select_single_container_props = {
  open: {
    type: Boolean,
    default: false
  },
  focus: {
    type: Boolean,
    default: false
  },
  below: {
    type: Boolean,
    default: null
  },
  ower: {
    type: String,
    default: null
  },
  value: {
    type: [Array, Object],
    default: function _default() {
      return [];
    }
  },
  placeholder: {
    type: String,
    default: "Choice a field"
  },
  rtl: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  }
};
var NlySearchSelectSingleContainer = utils_vue.extend({
  name: search_select_single_container_name,
  props: search_select_single_container_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data;
    var $single = h("span", {
      staticClass: "select2-selection select2-selection--single",
      attrs: {
        role: "combobox",
        "aria-haspopup": true,
        "aria-expanded": props.open ? true : false,
        tabindex: "0",
        "aria-disabled": props.disabled,
        "aria-labelledby": props.ower && props.open ? "".concat(props.ower, "-container") : null,
        "aria-owns": props.ower ? "".concat(props.ower, "-results") : null
      }
    }, [h(NlySearchSelectSingleItem, {
      props: {
        value: props.value,
        placeholder: props.placeholder
      }
    })]);
    var $selection = h("span", {
      staticClass: "selection"
    }, [$single]);
    var $dropdown = h("span", {
      staticClass: "dropdown-wrapper",
      attrs: {
        "aria-hidden": props.open ? "true" : "false"
      }
    });
    return h("span", lib_esm_a(data, {
      staticClass: "select2 select2-container select2-container--default",
      class: [props.below === true ? "select2-container--below" : props.below === false ? "select2-container--above" : null, props.open ? "select2-container--open" : null, props.open ? null : props.focus ? "select2-container--focus" : null, props.disabled ? " select2-container--disabled" : null],
      attrs: {
        dir: props.rtl ? "rtl" : "ltr"
      },
      style: {
        width: "100%"
      }
    }), [$selection, $dropdown]);
  }
});
// CONCATENATED MODULE: ./src/components/search-select/plugin/search-select-multiple-container.js

 // import { mergeData } from "vue-functional-data-merge";



var search_select_multiple_container_name = "NlySearchSelectMultipleContainer";
var NlySearchSelectMultipleContainer = utils_vue.extend({
  name: search_select_multiple_container_name,
  // model: {
  //   prop: "value",
  //   event: "input"
  // },
  props: {
    open: {
      type: Boolean,
      default: false
    },
    focus: {
      type: Boolean,
      default: false
    },
    below: {
      type: Boolean,
      default: null
    },
    ower: {
      type: String,
      default: null
    },
    value: {
      type: [Array, Object],
      default: function _default() {
        return [];
      }
    },
    placeholder: {
      type: String,
      default: "Choice a field"
    },
    inputFunction: {
      type: Function
    },
    valueField: {
      type: String,
      default: "value"
    },
    textField: {
      type: String,
      default: "text"
    },
    rtl: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    removeCheckedValue: {
      type: Function
    }
  },
  methods: {// updateValue(newValue) {
    //   this.$emit("input", newValue);
    // }
  },
  // watch: {
  //   value: {
  //     // eslint-disable-next-line no-unused-vars
  //     handler(newValue) {
  //       this.updateValue(newValue);
  //     },
  //     deep: true
  //   }
  // },
  computed: {
    customProps: function customProps() {
      return {
        open: this.open,
        focus: this.focus,
        below: this.below,
        ower: this.ower,
        placeholder: this.placeholder,
        disabled: this.disabled,
        rtl: this.rtl
      };
    },
    isItemInputFunction: function isItemInputFunction() {
      return isFunction(this.inputFunction);
    }
  },
  render: function render(h) {
    var self = this;
    var $single = h("span", {
      staticClass: "select2-selection select2-selection--multiple",
      attrs: {
        role: "combobox",
        "aria-haspopup": true,
        "aria-expanded": self.customProps.open ? true : false,
        tabindex: "0",
        "aria-disabled": self.customProps.disabled,
        "aria-labelledby": "".concat(self.customProps.ower, "-container"),
        "aria-owns": self.customProps.open && self.customProps.ower ? "".concat(self.customProps.ower, "-results") : null
      }
    }, [h(NlySearchSelectMultipleItem, {
      props: {
        placeholder: self.customProps.placeholder,
        inputFunction: self.isItemInputFunction ? self.inputFunction : null,
        valueField: self.valueField,
        textField: self.textField,
        value: self.value,
        removeCheckedValue: self.removeCheckedValue,
        id: self.customProps.ower
      } // directives: [
      //   {
      //     name: "model",
      //     rawName: "v-model",
      //     value: self.value,
      //     expression: "value"
      //   }
      // ]

    })]);
    var $selection = h("span", {
      staticClass: "selection"
    }, [$single]);
    var $dropdown = h("span", {
      staticClass: "dropdown-wrapper",
      attrs: {
        "aria-hidden": true
      }
    });
    return h("span", {
      staticClass: "select2 select2-container select2-container--default",
      class: [self.customProps.below === true ? "select2-container--below" : self.customProps.below === false ? "select2-container--above" : null, self.customProps.open ? "select2-container--open" : null, self.customProps.focus ? "select2-container--focus" : null],
      attrs: {
        dir: self.customProps.rtl ? "rtl" : "ltr"
      },
      style: {
        width: "100%"
      },
      on: Object(objectSpread2["a" /* default */])({}, self.$listeners)
    }, [$selection, $dropdown]);
  }
});
// CONCATENATED MODULE: ./src/mixins/form/search-select-options.js







var search_select_options_OPTIONS_OBJECT_DEPRECATED_MSG = 'Setting prop "options" to an object is deprecated. Use the array format instead.';
/* harmony default export */ var search_select_options = ({
  props: {
    options: {
      type: [Array, Object],
      default: function _default() {
        return [];
      }
    },
    valueField: {
      type: String,
      default: "value"
    },
    textField: {
      type: String,
      default: "text"
    },
    htmlField: {
      type: String,
      default: "html"
    },
    disabledField: {
      type: String,
      default: "disabled"
    }
  },
  computed: {
    formOptions: function formOptions() {
      return this.normalizeOptions(this.options);
    }
  },
  methods: {
    normalizeOption: function normalizeOption(option) {
      var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (isPlainObject(option)) {
        var value = utils_get(option, this.valueField);
        var text = utils_get(option, this.textField);
        return {
          value: isUndefined(value) ? key || text : value,
          text: stripTags(String(isUndefined(text) ? key : text)),
          html: utils_get(option, this.htmlField),
          disabled: Boolean(utils_get(option, this.disabledField)),
          selected: Boolean(utils_get(option, "selected"))
        };
      }

      return {
        value: key || option,
        text: stripTags(String(option)),
        disabled: false
      };
    },
    normalizeOptions: function normalizeOptions(options) {
      var _this = this;

      if (isArray(options)) {
        return options.map(function (option) {
          return _this.normalizeOption(option);
        });
      } else if (isPlainObject(options)) {
        warn_warn(search_select_options_OPTIONS_OBJECT_DEPRECATED_MSG, this.$options.name);
        return keys(options).map(function (key) {
          return _this.normalizeOption(options[key] || {}, key);
        });
      }

      return [];
    }
  }
});
// CONCATENATED MODULE: ./src/components/search-select/plugin/search-select-dropdown-option.js


 // import { mergeData } from "vue-functional-data-merge";

var search_select_dropdown_option_NAME = "NlySearchSelectDropdownOption";
var search_select_dropdown_option_props = {
  value: {
    required: true
  },
  disabled: {
    type: Boolean,
    default: false
  },
  selected: {
    type: Boolean,
    default: false
  }
};
var NlySearchSelectDropdownOption = utils_vue.extend({
  name: search_select_dropdown_option_NAME,
  props: search_select_dropdown_option_props,
  methods: {
    optionHover: function optionHover(evt) {
      if (!this.disabled) {
        if (evt.target.className.indexOf("select2-results__option--highlighted") === -1) {
          evt.target.classList.add("select2-results__option--highlighted");
        }
      }
    },
    optionUnHover: function optionUnHover(evt) {
      if (!this.disabled) {
        if (evt.target.className.indexOf("select2-results__option--highlighted") !== -1) {
          evt.target.classList.remove("select2-results__option--highlighted");
        }
      }
    }
  },
  render: function render(h) {
    return h("li", {
      staticClass: "select2-results__option",
      attrs: {
        role: "option",
        "aria-selected": this.disabled ? null : "".concat(this.selected),
        "aria-disabled": "".concat(this.disabled),
        value: this.value
      },
      on: Object(objectSpread2["a" /* default */])({
        mouseenter: this.optionHover,
        mouseleave: this.optionUnHover
      }, this.$listeners)
    }, this.value);
  }
});
// CONCATENATED MODULE: ./src/components/search-select/plugin/search-select-dropdown-group.js





var NlySearchSelectDropdownGroup = utils_vue.extend({
  name: "NlySearchSelectDropdownGroup",
  mixins: [search_select_options],
  props: {
    label: {
      type: String,
      required: true
    },
    addCheckedValue: {
      type: Function
    }
  },
  render: function render(h) {
    var self = this;
    var $options = self.formOptions.map(function (option, index) {
      var value = option.value,
          text = option.text,
          html = option.html,
          disabled = option.disabled,
          selected = option.selected;
      return h(NlySearchSelectDropdownOption, {
        props: {
          value: value,
          disabled: disabled,
          selected: selected
        },
        domProps: htmlOrText(html, text),
        key: "search_select_group_option_".concat(index),
        on: {
          click: function click() {
            if (!disabled) {
              self.addCheckedValue(option);
            }
          }
        }
      });
    });
    return h("li", {
      staticClass: "select2-results__option select2-results__option--group",
      attrs: {
        role: "group",
        "aria-label": self.label
      }
    }, [h("strong", {
      staticClass: "select2-results__group"
    }, self.label), h("ul", {
      staticClass: "select2-results__options select2-results__options--nested"
    }, [$options])]);
  }
});

// CONCATENATED MODULE: ./src/components/search-select/plugin/search-select-dropdown-container.js

 //import get from "../../../utils/get";

 // import { keys } from "../../../utils/object";
// import { warn } from "../../../utils/warn";

 // import optionsMixin from "./mixin-options";





var search_select_dropdown_container_name = "NlySearchSelectDropdownContainer"; // const OPTIONS_OBJECT_DEPRECATED_MSG =
//   'Setting prop "options" to an object is deprecated. Use the array format instead.';

var NlySearchSelectDropdownContainer = utils_vue.extend({
  name: search_select_dropdown_container_name,
  mixins: [mixins_id],
  model: {
    prop: "value",
    event: "input"
  },
  props: {
    variant: {
      type: String,
      default: null
    },
    multiple: {
      type: Boolean,
      default: false
    },
    value: {},
    top: {
      type: String,
      default: null
    },
    left: {
      type: String,
      default: null
    },
    labelField: {
      type: String,
      default: "label"
    },
    optionsField: {
      type: String,
      default: "options"
    },
    options: {
      type: [Array, Object],
      default: function _default() {
        return [];
      }
    },
    valueField: {
      type: String,
      default: "value"
    },
    textField: {
      type: String,
      default: "text"
    },
    htmlField: {
      type: String,
      default: "html"
    },
    disabledField: {
      type: String,
      default: "disabled"
    },
    open: {
      type: Boolean,
      default: null
    },
    below: {
      type: Boolean,
      default: null
    },
    addCheckedValue: {
      type: Function
    },
    width: {
      type: String
    },
    inputFunction: {
      type: Function
    }
  },
  data: function data() {
    return {
      localValue: this.value
    };
  },
  destroyed: function destroyed() {
    if (this.$el && this.$el.parentNode) {
      this.$el.parentNode.removeChild(this.$el);
    }
  },
  computed: {
    formOptions: function formOptions() {
      return this.options;
    },
    customWidth: function customWidth() {
      return this.width;
    },
    customLeft: function customLeft() {
      return this.left;
    },
    customTop: function customTop() {
      return this.top;
    },
    isInputFunction: function isInputFunction() {
      return isFunction(this.inputFunction);
    }
  },
  render: function render(h) {
    var self = this;
    var $dropDownGroup = self.options.map(function (option, index) {
      var value = option.value,
          label = option.label,
          options = option.options,
          disabled = option.disabled,
          selected = option.selected;
      var key = "option_".concat(index);
      return isArray(options) ? h(NlySearchSelectDropdownGroup, {
        props: {
          addCheckedValue: self.addCheckedValue,
          label: label,
          options: options
        },
        key: key
      }) : h(NlySearchSelectDropdownOption, {
        props: {
          value: value,
          disabled: disabled,
          selected: selected
        },
        domProps: htmlOrText(option.html, option.text),
        key: "search_select_group_option_".concat(index),
        on: {
          click: function click() {
            if (!disabled) {
              self.addCheckedValue(option);
            }
          }
        }
      });
    });
    var $dropResult = h("span", {
      staticClass: "select2-results"
    }, [h("ul", {
      staticClass: "select2-results__options",
      attrs: {
        "aria-expanded": self.open ? "true" : "false",
        "aria-hidden": !self.open ? "true" : "false",
        id: self.id ? "".concat(self.id, "-result") : null,
        role: "listbox"
      }
    }, [$dropDownGroup])]);
    var $dropDownInput = h("span", {
      staticClass: "select2-search select2-search--dropdown"
    }, [h("input", {
      staticClass: "select2-search__field",
      attrs: {
        type: "search",
        tabindex: "1",
        autocomplete: "off",
        autocorrect: "off",
        autocapitalize: "none",
        spellcheck: "false",
        role: "searchbox",
        "aria-autocomplete": "list",
        "aria-controls": "select2-a5l9-results",
        "aria-activedescendant": "select2-a5l9-result-v6dd-Alabama"
      },
      on: {
        input: function input(evt) {
          // 阻止ime
          if (evt.target.composing) {
            return;
          } // 给 localValue 赋值为输入框输入的值


          self.localValue = evt.target.value; // 传入 inputFunction 获取输入框最新值

          if (self.isInputFunction) {
            self.inputFunction(evt.target.value);
          }
        }
      },
      directives: [{
        name: "model",
        rawName: "v-model",
        value: self.value,
        expression: "value"
      }]
    })]);
    var childrenVnodes = self.multiple === true ? [$dropResult] : [$dropDownInput, $dropResult];
    return h("span", {
      staticClass: "select2-container select2-container--default",
      class: [self.open ? "select2-container--open" : null],
      style: {
        position: "absolute",
        top: self.customTop,
        left: self.customLeft
      }
    }, [h("span", {
      staticClass: "select2-dropdown",
      class: [self.variant ? "select2-".concat(self.variant) : null, self.below === true ? "select2-danger select2-dropdown--below" : self.below === false ? "select2-danger select2-dropdown--above" : null],
      attrs: {
        dir: "ltr"
      },
      style: {
        width: self.customWidth
      }
    }, childrenVnodes)]);
  }
});
// CONCATENATED MODULE: ./src/components/search-select/plugin/mixin-search-select-options.js








/* harmony default export */ var mixin_search_select_options = ({
  mixins: [search_select_options],
  props: {
    labelField: {
      type: String,
      default: "label"
    },
    optionsField: {
      type: String,
      default: "options"
    }
  },
  methods: {
    normalizeOption: function normalizeOption(option) {
      var _this = this;

      var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var optionCheckedValue = this.checkedValue ? this.checkedValue.map(function (item) {
        return item[_this.valueField];
      }) : [];

      if (isPlainObject(option)) {
        var value = utils_get(option, this.valueField);
        var text = utils_get(option, this.textField);
        var options = utils_get(option, this.optionsField, null);

        if (!isNull(options)) {
          from(options).forEach(function (item, index) {
            if (optionCheckedValue.indexOf(item[_this.valueField]) !== -1) {
              options[index]["selected"] = true;
            } else {
              options[index]["selected"] = false;
            }
          });
          return {
            label: String(utils_get(option, this.labelField) || text),
            options: this.normalizeOptions(options)
          };
        }

        if (optionCheckedValue.indexOf(value) !== -1) {
          return {
            value: isUndefined(value) ? key || text : value,
            text: String(isUndefined(text) ? key : text),
            html: utils_get(option, this.htmlField),
            disabled: Boolean(utils_get(option, this.disabledField)),
            selected: true
          };
        } else {
          return {
            value: isUndefined(value) ? key || text : value,
            text: String(isUndefined(text) ? key : text),
            html: utils_get(option, this.htmlField),
            disabled: Boolean(utils_get(option, this.disabledField)),
            selected: false
          };
        }
      }

      return {
        value: key || option,
        text: String(option),
        disabled: false,
        selected: false
      };
    }
  }
});
// EXTERNAL MODULE: ./node_modules/portal-vue/dist/portal-vue.common.js
var portal_vue_common = __webpack_require__("2b88");

// CONCATENATED MODULE: ./src/components/search-select/plugin/search-select-portal.js


 // const OPTIONS_OBJECT_DEPRECATED_MSG =
//   'Setting prop "options" to an object is deprecated. Use the array format instead.';

var NlySearchSelectPortal = utils_vue.extend({
  name: "NlySearchSelectPortal",
  props: {
    name: {
      type: String,
      required: true
    },
    id: {
      type: String
    }
  },
  data: function data() {
    return {
      localValue: this.value,
      portalName: this.name
    };
  },
  beforeMount: function beforeMount() {
    this.portalName = this.name;
  },
  destroyed: function destroyed() {
    if (this.$el && this.$el.parentNode) {
      this.$el.parentNode.removeChild(this.$el);
    }
  },
  render: function render(h) {
    var self = this;
    return h(portal_vue_common["PortalTarget"], {
      props: {
        tag: "span",
        name: self.portalName
      },
      attrs: {
        id: self.id
      }
    });
  }
});
// CONCATENATED MODULE: ./src/components/search-select/search-select.js















 // import { props } from "./plugin/select-option";

 // const VALUE_NOT_IN_OPTIONS =
//   "The Value in v-model is not in options, it is not render";

var search_select_name = "NlySearchSelect";
var NlySearchSelect = utils_vue.extend({
  name: search_select_name,
  mixins: [mixins_id, mixin_search_select_options],
  model: {
    prop: "value",
    event: "input"
  },
  props: {
    /** select的prop */
    // 隐藏的select 的 id
    // id: {
    //   type: String,
    //   default: null
    // },
    // 隐藏的select 的 option，即需要渲染到下拉框中的数据
    options: {
      type: [Array, Object],
      default: function _default() {
        return [];
      }
    },
    // 隐藏的select 的 value, 即 渲染为下拉框中元素的 value
    valueField: {
      type: String,
      default: "value"
    },
    // 隐藏的select 的 text, 即 渲染为下拉框中元素的 文本
    textField: {
      type: String,
      default: "text"
    },
    // 隐藏的select 的 分组标签 的名称
    labelField: {
      type: String,
      default: "label"
    },
    // 隐藏的select 的分组下默的 option 字段名称
    optionsField: {
      type: String,
      default: "options"
    },
    // 颜色
    variant: {
      type: String,
      default: null
    },
    // 多选
    multiple: {
      type: Boolean,
      default: false
    },

    /** select-container的 pops */
    placeholder: {
      type: String,
      default: "Choice a field"
    },
    // inputFunction: {
    //   type: Function
    // },
    // 获取所选择的值
    value: {//   type: [Array, Object],
      //   default: () => []
    },
    //
    disabled: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      // 选中的值， 用来传给 item 的
      checkedValue: [],
      inputValue: null,
      open: false,
      focus: false,
      below: null,
      portalName: "nly-search-select-".concat(this._uid),
      dropdownWidth: null,
      dropdownLeft: null,
      dropdownTop: null
    };
  },
  beforeDestroy: function beforeDestroy() {
    this.clearPortalTarget();
  },
  methods: {
    clearPortalTarget: function clearPortalTarget() {
      if (portal_vue_common["Wormhole"].hasTarget(this.portalName)) {
        document.body.removeChild(document.body.querySelector("#".concat(this.portalName, "-id")));
      }
    },
    showDropDown: function showDropDown() {
      this.dropdownWidth = this.$refs[this.customProps.ref].getBoundingClientRect().width;
      this.dropdownLeft = this.$refs[this.customProps.ref].getBoundingClientRect().left;
      this.dropdownTop = this.getOffsetTop(this.$refs[this.customProps.ref]);

      if (!portal_vue_common["Wormhole"].hasTarget(this.portalName)) {
        var div = document.createElement("div");
        document.body.appendChild(div);
        var searchSelectPortal = new NlySearchSelectPortal({
          parent: this.$root,
          propsData: {
            name: this.portalName,
            id: "".concat(this.portalName, "-id")
          }
        });
        searchSelectPortal.$mount(div);
      } else {
        warn_warn("A \"<portal-target>\" with name \"".concat(this.portalName, "\" already exists in the document."), "NlySearchSelectPortal");
      }
    },
    getCheckValueValueFieldValue: function getCheckValueValueFieldValue() {},
    inputFunction: function inputFunction(evt) {
      this.inputValue = evt;
    },
    click_other: function click_other(e) {
      // console.log(e.target);
      // this.$nextTick(() => {
      //   console.log(this.$refs[`${this.safeId()}-input`]);
      // });
      if (!this.multiple) if (!this.$el.contains(e.target)) {
        this.open = false;
        this.focus = false;
      }
    },
    addCheckedValue: function addCheckedValue(evt) {
      var _this = this;

      if (this.multiple) {
        var newValue = [];
        var addCheckedValue = from(this.checkedValue).map(function (o) {
          return o[_this.valueField];
        });

        if (addCheckedValue.indexOf(evt[this.valueField]) === -1) {
          this.checkedValue.push(evt);
        } else {
          this.checkedValue.splice(addCheckedValue.indexOf(evt[this.valueField]), 1);
        }

        this.checkedValue.forEach(function (item) {
          if (item[_this.valueField] !== null) {
            newValue.push(item[_this.valueField]);
          }
        });
        this.open = false;
        this.$emit("input", newValue);
      } else {
        var _newValue = [];

        var _addCheckedValue = from(this.checkedValue).map(function (o) {
          return o[_this.valueField];
        });

        if (_addCheckedValue.indexOf(evt[this.valueField]) === -1) {
          this.checkedValue = [evt];
        } else if (evt[this.valueField] === null) {
          this.checkedValue = [evt];
        } else {
          this.checkedValue = null;
        }

        if (this.checkedValue) {
          this.checkedValue.forEach(function (item) {
            _newValue.push(item[_this.valueField]);
          });
        }

        this.open = false;

        if (this.checkedValue) {
          this.$emit("input", _newValue[0]);
        } else {
          this.$emit("input", null);
        }
      }
    },
    removeCheckedValue: function removeCheckedValue(newValue) {
      var _this2 = this;

      var newVal = [];
      newValue.forEach(function (item) {
        if (item[_this2.valueField] !== null) {
          newVal.push(item[_this2.valueField]);
        }
      });
      this.$emit("input", newVal);
    },
    getCheckValue: function getCheckValue() {
      var _this3 = this;

      if (this.multiple) {
        if (isArray(this.customProps.value)) {
          var selectedValArray = [];
          this.customProps.value.forEach(function (element) {
            from(_this3.options).forEach(function (item) {
              if (Object.keys(item).indexOf(_this3.valueField) !== -1) {
                if (JSON.stringify(item[_this3.valueField]) === JSON.stringify(element)) {
                  selectedValArray.push(item);
                }
              } else if (Object.keys(item).indexOf(_this3.optionsField) !== -1) {
                item[_this3.optionsField].forEach(function (children) {
                  if (Object.keys(children).indexOf(_this3.valueField) !== -1) {
                    if (JSON.stringify(children[_this3.valueField]) === JSON.stringify(element)) {
                      selectedValArray.push(children);
                    }
                  }
                });
              }
            });
          });
          return selectedValArray;
        } else {
          var _selectedValArray = [];
          from(this.options).forEach(function (item) {
            if (Object.keys(item).indexOf(_this3.valueField) !== -1) {
              if (JSON.stringify(item[_this3.valueField]) === JSON.stringify(_this3.customProps.value)) {
                _selectedValArray.push(item);
              }
            } else if (Object.keys(item).indexOf(_this3.optionsField) !== -1) {
              item[_this3.optionsField].forEach(function (children) {
                if (Object.keys(children).indexOf(_this3.valueField) !== -1) {
                  if (JSON.stringify(children[_this3.valueField]) === JSON.stringify(_this3.customProps.value)) {
                    _selectedValArray.push(children);
                  }
                }
              });
            }
          });
          return _selectedValArray;
        }
      } else {
        if (isArray(this.customProps.value)) {
          var _selectedValArray2 = [];
          var element = this.customProps.value[0];
          from(this.options).forEach(function (item) {
            if (Object.keys(item).indexOf(_this3.valueField) !== -1) {
              if (JSON.stringify(item[_this3.valueField]) === JSON.stringify(element)) {
                _selectedValArray2.push(item);
              }
            } else if (Object.keys(item).indexOf(_this3.optionsField) !== -1) {
              item[_this3.optionsField].forEach(function (children) {
                if (Object.keys(children).indexOf(_this3.valueField) !== -1) {
                  if (JSON.stringify(children[_this3.valueField]) === JSON.stringify(element)) {
                    _selectedValArray2.push(children);
                  }
                }
              });
            }
          });
          return [_selectedValArray2[0]];
        } else {
          var _selectedValArray3 = [];
          from(this.options).forEach(function (item) {
            if (Object.keys(item).indexOf(_this3.valueField) !== -1) {
              if (JSON.stringify(item[_this3.valueField]) === JSON.stringify(_this3.customProps.value)) {
                _selectedValArray3.push(item);
              }
            } else if (Object.keys(item).indexOf(_this3.optionsField) !== -1) {
              item[_this3.optionsField].forEach(function (children) {
                if (Object.keys(children).indexOf(_this3.valueField) !== -1) {
                  if (JSON.stringify(children[_this3.valueField]) === JSON.stringify(_this3.customProps.value)) {
                    _selectedValArray3.push(children);
                  }
                }
              });
            }
          });
          return [_selectedValArray3[0]];
        }
      }
    },
    getOffsetTop: function getOffsetTop(obj) {
      var top = obj.getBoundingClientRect().height;

      while (obj.offsetParent) {
        //如果obj的有最近的父级定位元素就继续
        top += obj.offsetTop;
        obj = obj.offsetParent; //更新obj,继续判断新的obj是否还有父级定位，然后继续累加
      }

      return top; //返回json格式
    }
  },
  created: function created() {},
  mounted: function mounted() {
    this.checkedValue = this.getCheckValue();
  },
  computed: {
    customProps: function customProps() {
      return {
        focus: this.focus,
        below: this.below,
        ower: this.id,
        placeholder: this.placeholder,
        inputFunction: this.inputFunction,
        valueField: this.valueField,
        textField: this.textField,
        options: this.options,
        value: this.value,
        id: this.safeId(),
        ref: this.selectRef ? this.selectRef : "".concat(this.portalName, "-ref"),
        variant: this.variant
      };
    }
  },
  watch: {
    open: function open(newVal) {
      if (newVal === true) {
        document.addEventListener("click", this.click_other, true);
      } else {
        document.removeEventListener("click", this.click_other, true);
      }
    },
    value: {
      //监听的对象
      deep: true,
      //深度监听设置为 true
      handler: function handler() {
        this.checkedValue = this.getCheckValue();
      }
    }
  },
  render: function render(h) {
    var thatselect = this;
    var $searchSelectItemVnodes = h(NlySearchSelectItem, {
      props: {
        id: thatselect.id,
        // 隐藏的select 的 option，即需要渲染到下拉框中的数据
        options: thatselect.options,
        // 隐藏的select 的 value, 即 渲染为下拉框中元素的 value
        valueField: thatselect.valueField,
        // 隐藏的select 的 text, 即 渲染为下拉框中元素的 文本
        textField: thatselect.textField,
        // 隐藏的select 的 分组标签 的名称
        labelField: thatselect.labelField,
        // 隐藏的select 的分组下默的 option 字段名称
        optionsField: thatselect.optionsField
      }
    });
    var $multipleVnodes = h(NlySearchSelectMultipleContainer, {
      props: {
        open: thatselect.open,
        focus: thatselect.focus,
        below: thatselect.below,
        ower: thatselect.safeId(),
        value: thatselect.checkedValue,
        placeholder: thatselect.placeholder,
        inputFunction: thatselect.inputFunction,
        valueField: thatselect.valueField,
        textField: thatselect.textField,
        removeCheckedValue: thatselect.removeCheckedValue
      },
      on: {
        click: function click() {
          if (thatselect.open) {
            thatselect.open = false;
          } else {
            thatselect.open = true;
            thatselect.showDropDown();
          }

          thatselect.focus = true;
        }
      }
    });
    var $singleVnodes = h(NlySearchSelectSingleContainer, {
      props: {
        open: thatselect.open,
        focus: thatselect.focus,
        below: thatselect.below,
        ower: thatselect.safeId(),
        value: thatselect.checkedValue,
        placeholder: thatselect.placeholder,
        disabled: thatselect.disabled
      },
      on: {
        click: function click() {
          if (thatselect.open) {
            thatselect.open = false;
          } else {
            thatselect.open = true;
            thatselect.showDropDown();
          }

          thatselect.focus = true;
        }
      }
    });
    var $dropdownVnodes = h(portal_vue_common["Portal"], {
      props: {
        to: thatselect.portalName,
        // slim: true,
        name: thatselect.portalName
      }
    }, [h(NlySearchSelectDropdownContainer, {
      props: {
        open: thatselect.open,
        below: thatselect.below,
        id: thatselect.safeId(),
        variant: thatselect.customProps.variant,
        valueField: thatselect.valueField,
        textField: thatselect.textField,
        labelField: thatselect.labelField,
        optionsField: thatselect.optionsField,
        options: thatselect.formOptions,
        multiple: thatselect.multiple,
        addCheckedValue: thatselect.addCheckedValue,
        width: "".concat(thatselect.dropdownWidth, "px"),
        left: "".concat(thatselect.dropdownLeft, "px"),
        top: "".concat(thatselect.dropdownTop, "px"),
        inputFunction: thatselect.inputFunction
      }
    })]);

    if (thatselect.multiple) {
      return h("div", {
        staticClass: thatselect.customProps.variant ? "select2-".concat(thatselect.variant) : null,
        attrs: {
          id: thatselect.customProps.id
        },
        ref: thatselect.customProps.ref
      }, [$searchSelectItemVnodes, $multipleVnodes, $dropdownVnodes]);
    } else {
      return h("div", {
        attrs: {
          id: thatselect.customProps.id
        },
        ref: thatselect.customProps.ref
      }, [$searchSelectItemVnodes, $singleVnodes, $dropdownVnodes]);
    }
  }
});
// CONCATENATED MODULE: ./src/components/search-select/index.js









var SearchSelectPlugin = plugins_nlyPluginFactory({
  components: {
    NlySearchSelectItem: NlySearchSelectItem,
    NlySearchSelectSingleItem: NlySearchSelectSingleItem,
    NlySearchSelectMultipleItem: NlySearchSelectMultipleItem,
    NlySearchSelectSingleContainer: NlySearchSelectSingleContainer,
    NlySearchSelectMultipleContainer: NlySearchSelectMultipleContainer,
    NlySearchSelect: NlySearchSelect,
    NlySearchSelectDropdownOption: NlySearchSelectDropdownOption,
    NlySearchSelectDropdownContainer: NlySearchSelectDropdownContainer
  }
});

// CONCATENATED MODULE: ./src/components/sidebar/sidebar-container.js



var sidebar_container_name = "NlySidebarContainer";
var NlySidebarContainer = utils_vue.extend({
  name: sidebar_container_name,
  props: {
    variant: {
      type: String,
      default: "darkPrimary"
    },
    hover: {
      type: Boolean,
      default: true
    },
    elevation: {
      type: String,
      default: "xl"
    }
  },
  computed: {
    customVariant: function customVariant() {
      return nlyGetOptionsByKeyEqual(sidebarContainerVariantOpitons, this.variant);
    },
    customHover: function customHover() {
      return this.hover ? "" : "sidebar-no-expand";
    },
    customElevation: function customElevation() {
      return nlyGetOptionsByKeyEqual(sidebarElevationOptions, this.elevation);
    }
  },
  render: function render(h) {
    return h("aside", {
      staticClass: "main-sidebar",
      class: [this.customVariant, this.customElevation, this.customHover]
    }, this.$slots.default);
  }
});
// CONCATENATED MODULE: ./src/components/sidebar/sidebar-brand.js





var sidebar_brand_props = propsFactory();
var sidebar_brand_name = "NlySidebarBrand";
var NlySidebarBrand = utils_vue.extend({
  name: sidebar_brand_name,
  props: Object(objectSpread2["a" /* default */])({
    size: {
      type: String
    },
    variant: {
      type: String
    },
    elevation: {
      type: String
    }
  }, sidebar_brand_props),
  computed: {
    customSize: function customSize() {
      var fontSize = nlyGetOptionsByKeyEqual(textSizeOptions, this.size);
      return fontSize;
    },
    customVariant: function customVariant() {
      return nlyGetOptionsByKeyEqual(sidebarBrandVariantOptions, this.variant);
    },
    customElevation: function customElevation() {
      return nlyGetOptionsByKeyEqual(sidebarElevationOptions, this.elevation);
    },
    computedProps: function computedProps() {
      return Object(objectSpread2["a" /* default */])({}, this.$props);
    }
  },
  render: function render(h) {
    return h(NlyLink, {
      staticClass: "brand-link",
      class: [this.customSize, this.customVariant, this.customElevation],
      props: this.computedProps
    }, this.$slots.default);
  }
});
// CONCATENATED MODULE: ./src/components/sidebar/sidebar-brandimg.js

var sidebar_brandimg_name = "NlySidebarBrandimg";
var NlySidebarBrandimg = utils_vue.extend({
  name: sidebar_brandimg_name,
  props: {
    src: {
      type: String,
      required: true
    },
    sidebarBrandimgClass: {
      type: String
    },
    alt: {
      type: String
    },
    circle: {
      type: Boolean,
      default: false
    },
    elevation: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    customSrc: function customSrc() {
      return this.src;
    },
    customSidebarBrandimgClass: function customSidebarBrandimgClass() {
      return this.sidebarBrandimgClass;
    },
    customCircle: function customCircle() {
      return this.circle ? "img-circle" : "";
    },
    customAlt: function customAlt() {
      return this.alt;
    },
    customElevation: function customElevation() {
      return this.elevation ? "elevation-3" : "";
    }
  },
  render: function render(h) {
    return h("img", {
      attrs: {
        alt: this.customAlt,
        src: this.customSrc
      },
      style: {
        opacity: 0.8
      },
      staticClass: "brand-image",
      class: [this.customCircle, this.customElevation, this.customSidebarBrandimgClass]
    }, this.$slots.default);
  }
});
// CONCATENATED MODULE: ./src/components/sidebar/siderbar-brandtext.js


var siderbar_brandtext_name = "NlySidebarBrandtext";
var NlySidebarBrandtext = utils_vue.extend({
  name: siderbar_brandtext_name,
  render: function render(h) {
    return h(NlyNavbarBrandtext, this.$slots.default);
  }
});
// CONCATENATED MODULE: ./src/components/sidebar/sidebar.js



var sidebar_name = "NlySidebar";
var NlySidebar = utils_vue.extend({
  name: sidebar_name,
  props: {
    scrollbar: {
      type: Boolean,
      default: true
    }
  },
  computed: {
    customScrollbar: function customScrollbar() {
      return this.scrollbar;
    }
  },
  render: function render(h) {
    var scrollbarArray = h(__vue_component__, {
      staticClass: "sidebar",
      props: {
        options: {
          scrollbars: {
            autoHide: "scroll"
          }
        }
      }
    }, this.$slots.default);
    var unscrollbarArray = h("div", {
      staticClass: "sidebar"
    }, this.$slots.default);
    var controlSidebarArray = this.customScrollbar ? scrollbarArray : unscrollbarArray;
    return controlSidebarArray;
  }
});
// CONCATENATED MODULE: ./src/components/sidebar/sidebar-userpanel.js

var sidebar_userpanel_name = "NlySidebarUserpanel";
var NlySidebarUserpanel = utils_vue.extend({
  name: sidebar_userpanel_name,
  render: function render(h) {
    return h("div", {
      staticClass: "user-panel"
    }, this.$slots.default);
  }
});
// CONCATENATED MODULE: ./src/components/sidebar/sidebar-userpanel-img.js



var sidebar_userpanel_img_name = "NlySidebarUserpanelImg";
var NlySidebarUserpanelImg = utils_vue.extend({
  name: sidebar_userpanel_img_name,
  props: {
    src: {
      type: String,
      required: true
    },
    circle: {
      type: Boolean,
      default: true
    },
    elevation: {
      type: String,
      default: "md"
    },
    alt: {
      type: String
    },
    imgClass: {
      type: String
    }
  },
  computed: {
    customSrc: function customSrc() {
      return this.src;
    },
    customCircle: function customCircle() {
      return this.circle ? "img-circle" : "";
    },
    customElevation: function customElevation() {
      return nlyGetOptionsByKeyEqual(sidebarElevationOptions, this.elevation);
    },
    customAlt: function customAlt() {
      return this.alt;
    },
    customImgClass: function customImgClass() {
      return this.imgClass;
    }
  },
  render: function render(h) {
    var inner = h("img", {
      attrs: {
        src: this.customSrc,
        alt: this.customAlt
      },
      class: [this.customCircle, this.customElevation, this.customImgClass]
    });
    return h("div", {
      staticClass: "image"
    }, [inner]);
  }
});
// CONCATENATED MODULE: ./src/components/sidebar/sidebar-userpanel-info.js


 // import { mergeData } from "vue-functional-data-merge";

var sidebar_userpanel_info_props = propsFactory();
var sidebar_userpanel_info_name = "NlySidebarUserpanelInfo";
var NlySidebarUserpanelInfo = utils_vue.extend({
  name: sidebar_userpanel_info_name,
  props: Object(objectSpread2["a" /* default */])({
    infoClass: {
      type: String
    }
  }, sidebar_userpanel_info_props),
  computed: {
    customInfoClass: function customInfoClass() {
      return this.infoClass;
    },
    computedProps: function computedProps() {
      return Object(objectSpread2["a" /* default */])({}, this.$props);
    }
  },
  render: function render(h) {
    return h("div", {
      staticClass: "info"
    }, [h(NlyLink, {
      staticClass: "d-block",
      class: this.customInfoClass,
      props: this.computedProps
    }, this.$slots.default)]);
  }
});
// CONCATENATED MODULE: ./src/components/sidebar/sidebar-nav.js





var sidebar_nav_name = "NlySidebarNav";
var NlySidebarNav = utils_vue.extend({
  name: sidebar_nav_name,
  props: {
    pill: {
      type: Boolean,
      default: false
    },
    flat: {
      type: Boolean,
      default: false
    },
    legacy: {
      type: Boolean,
      default: false
    },
    compact: {
      type: Boolean,
      default: false
    },
    childIndent: {
      type: Boolean,
      default: false
    },
    size: {
      String: String
    },
    sidebarNavClass: {
      type: String
    },
    role: {
      type: String,
      default: "menu"
    }
  },
  computed: {
    customShape: function customShape() {
      return {
        flat: this.flat ? "nav-flat" : "",
        pill: this.pill ? "nav-pills" : "",
        legacy: this.legacy ? "nav-legacy" : "",
        compact: this.compact ? "nav-compact" : ""
      };
    },
    customChildIndent: function customChildIndent() {
      return this.childIndent ? "nav-child-indent" : "";
    },
    customSize: function customSize() {
      return nlyGetOptionsByKeyEqual(textSizeOptions, this.size);
    },
    customSidebarNavClass: function customSidebarNavClass() {
      return this.sidebarNavClass;
    },
    customRole: function customRole() {
      return this.role;
    }
  },
  render: function render(h) {
    return h("nav", [h("ul", {
      staticClass: "nav nav-sidebar flex-column",
      class: [this.customShape.flat, this.customShape.pill, this.customShape.legacy, this.customShape.compact, this.customSize, this.customChildIndent, this.customSidebarNavClass],
      attrs: {
        role: this.customRole
      }
    }, this.$slots.default)]);
  }
});
// CONCATENATED MODULE: ./src/components/sidebar/sidebar-nav-item.js



var sidebar_nav_item_props = propsFactory();
var sidebar_nav_item_name = "NlySidebarNavItem";
var NlySidebarNavItem = utils_vue.extend({
  name: sidebar_nav_item_name,
  props: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, sidebar_nav_item_props), {}, {
    linkClass: {
      type: String
    },
    icon: {
      type: String
    }
  }),
  computed: {
    customLinkProps: function customLinkProps() {
      return {
        href: this.href,
        linkTarget: this.linkTarget,
        active: this.active,
        disabled: this.disabled,
        to: this.to,
        append: this.append,
        exact: this.exact,
        exactActiveClass: "active"
      };
    },
    customLinkClass: function customLinkClass() {
      return this.linkClass;
    },
    customIcon: function customIcon() {
      return this.icon;
    }
  },
  render: function render(h) {
    return h("li", {
      staticClass: "nav-item"
    }, [h(NlyLink, {
      staticClass: "nav-link",
      props: this.customLinkProps,
      class: this.customLinkClass
    }, [h("i", {
      class: this.icon
    }), h("p", this.$slots.default)])]);
  }
});
// CONCATENATED MODULE: ./src/components/sidebar/sidebar-nav-tree.js





var sidebar_nav_tree_name = "NlySidebarNavTree";
var NlySidebarNavTree = utils_vue.extend({
  name: sidebar_nav_tree_name,
  mixins: [listen_on_root],
  data: function data() {
    return {
      toggleState: false
    };
  },
  props: {
    label: {
      type: String,
      default: "nly sidebar navigation"
    },
    target: {
      type: String,
      required: true
    },
    linkClass: {
      type: String
    },
    // nly-link props
    href: {
      type: String,
      default: null
    },
    linkTarget: {
      type: String,
      default: "_self"
    },
    active: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    to: {
      type: [String, Object],
      default: null
    },
    append: {
      type: Boolean,
      default: false
    },
    exact: {
      type: Boolean,
      default: false
    },
    exactActiveClass: {
      type: String
    },
    //icon
    icon: {
      type: String
    },
    // menu props
    accordion: {
      type: String,
      default: "nly-accordion"
    },
    visible: {
      type: Boolean,
      default: false
    },
    tag: {
      type: String,
      default: "ul"
    },
    appear: {
      type: Boolean,
      default: false
    },
    menuClass: {
      type: String
    },
    text: {
      type: String
    }
  },
  computed: {
    customLabel: function customLabel() {
      return this.label;
    },
    customTarget: function customTarget() {
      return this.target;
    },
    customLinkClass: function customLinkClass() {
      return this.linkClass;
    },
    customLinkProps: function customLinkProps() {
      return {
        href: this.href,
        linkTarget: this.linkTarget,
        active: this.active,
        disabled: this.disabled,
        to: this.to,
        append: this.append,
        exact: this.exact,
        exactActiveClass: "active"
      };
    },
    customMenuProps: function customMenuProps() {
      return {
        accordion: this.accordion,
        visible: this.visible,
        tag: "ul",
        appear: this.appear,
        collapseClass: this.menuClass
      };
    },
    customIcon: function customIcon() {
      return this.icon;
    },
    customText: function customText() {
      return this.text;
    }
  },
  created: function created() {
    // 监听root 事件，获取初始toggleState值
    this.listenOnRoot(EVENT_STATE, this.handleStateEvt);
    this.listenOnRoot(EVENT_STATE_SYNC, this.handleStateEvt);
  },
  methods: {
    onClick: function onClick(evt) {
      this.$emit("click", evt);

      if (!evt.defaultPrevented) {
        this.$root.$emit(EVENT_TOGGLE, this.customTarget);
      }
    },
    handleStateEvt: function handleStateEvt(id, state) {
      if (id === this.customTarget) {
        this.toggleState = state;
      }
    }
  },
  render: function render(h) {
    var menuArray = h(NlyCollapseNoclass, {
      props: this.customMenuProps,
      attrs: {
        id: this.customTarget
      },
      style: {
        display: this.customMenuProps.visible ? "block" : "none"
      },
      staticClass: "nav nav-treeview"
    }, this.$slots.default);
    var linkArray = h(NlyLink, {
      staticClass: "nav-link",
      class: [this.customLinkClass],
      attrs: {
        "aria-label": this.customLabel,
        "aria-controls": this.customTarget,
        "aria-expanded": this.toggleState ? "true" : "false",
        "data-target": "#".concat(this.customTarget)
      },
      props: this.customLinkProps,
      on: {
        click: this.onClick
      }
    }, [h("i", {
      class: this.customIcon
    }), h("p", [this.customText, h("i", {
      class: "right fas fa-angle-left"
    }), this.$slots.linktool])]);
    return h("li", {
      staticClass: "nav-item has-treeview",
      class: this.toggleState ? "menu-open" : ""
    }, [linkArray, menuArray]);
  }
});
// CONCATENATED MODULE: ./src/components/sidebar/sidebar-nav-header.js

var sidebar_nav_header_name = "NlySidebarNavHeader";
var NlySidebarNavHeader = utils_vue.extend({
  name: sidebar_nav_header_name,
  props: {
    tag: {
      type: String,
      default: "li"
    }
  },
  computed: {
    customTag: function customTag() {
      return this.tag;
    }
  },
  render: function render(h) {
    return h(this.customTag, {
      staticClass: "nav-header"
    }, this.$slots.default);
  }
});
// CONCATENATED MODULE: ./src/components/sidebar/index.js













var SidebarPlugin = plugins_nlyPluginFactory({
  components: {
    NlySidebarContainer: NlySidebarContainer,
    NlySidebarBrand: NlySidebarBrand,
    NlySidebarBrandimg: NlySidebarBrandimg,
    NlySidebarBrandtext: NlySidebarBrandtext,
    NlySidebar: NlySidebar,
    NlySidebarUserpanel: NlySidebarUserpanel,
    NlySidebarUserpanelImg: NlySidebarUserpanelImg,
    NlySidebarUserpanelInfo: NlySidebarUserpanelInfo,
    NlySidebarNav: NlySidebarNav,
    NlySidebarNavItem: NlySidebarNavItem,
    NlySidebarNavTree: NlySidebarNavTree,
    NlySidebarNavHeader: NlySidebarNavHeader
  }
});

// CONCATENATED MODULE: ./src/components/spinner/index.js


var SpinnerPlugin = plugins_nlyPluginFactory({
  components: {
    NlySpinner: NlySpinner
  }
});

// CONCATENATED MODULE: ./src/components/switch/switch.js







var switch_name = "NlySwitch";
var NlySwitch = utils_vue.extend({
  name: switch_name,
  model: {
    prop: "checked",
    event: "change"
  },
  props: {
    size: {
      type: String
    },
    flat: {
      type: Boolean,
      default: false
    },
    offVariant: {
      type: String
    },
    onVariant: {
      type: String
    },
    switchClass: {
      type: String
    },
    inputClass: {
      type: String
    },
    labelClass: {
      type: String
    },
    id: {
      type: String
    },
    tag: {
      type: String,
      default: "div"
    },
    disabled: {
      type: Boolean,
      default: false
    },
    checked: {
      type: [Boolean, String, Number]
    }
  },
  computed: {
    customProps: function customProps() {
      return {
        size: nlyGetOptionsByKeyEqual(switchSizeOptions, this.size),
        flat: this.flat ? "custom-switch-flat" : "custom-switch",
        offVariant: nlyGetOptionsByKeyEqual(switchVariantOptions.off, this.offVariant),
        onVariant: nlyGetOptionsByKeyEqual(switchVariantOptions.on, this.onVariant),
        switchClass: this.switchClass,
        inputClass: this.inputClass,
        labelClass: this.labelClass,
        id: nlySwitchId(this.id) ? nlySwitchId(this.id) : nlySwitchId(this._uid),
        tag: this.tag,
        disabled: this.disabled ? "disabled" : this.disabled
      };
    }
  },
  methods: {
    change: function change(event) {
      this.$emit("change", event.target.checked);
    }
  },
  render: function render(h) {
    return h(this.customProps.tag, {
      staticClass: "custom-control",
      class: [this.customProps.flat, this.customProps.size, this.customProps.offVariant, this.customProps.onVariant, this.customProps.switchClass]
    }, [h("input", {
      attrs: {
        type: "checkbox",
        id: this.customProps.id,
        disabled: this.customProps.disabled
      },
      staticClass: "custom-control-input",
      class: this.customProps.inputClass,
      on: {
        change: this.change
      },
      directives: [{
        name: "model",
        rawName: "v-model",
        value: this.checked,
        expression: "checked"
      }],
      domProps: {
        value: this.checked ? true : null,
        checked: this.checked
      }
    }), h("label", {
      staticClass: "custom-control-label",
      class: this.customProps.labelClass,
      attrs: {
        for: this.customProps.id
      }
    }, this.$slots.default)]);
  }
});
// CONCATENATED MODULE: ./src/components/switch/bootstrap-switch.js




var bootstrap_switch_name = "NlyBootstrapSwitch";
var bootstrapSwitchOptions = {
  xs: {
    class: "bootstrap-switch-mini",
    width: "70px",
    containerWidth: "104px",
    itemWidth: "34px"
  },
  sm: {
    class: "bootstrap-switch-small",
    width: "90px",
    containerWidth: "134px",
    itemWidth: "44px"
  },
  lg: {
    class: "bootstrap-switch-large",
    width: "130px",
    containerWidth: "194px",
    itemWidth: "64px"
  }
};
var NlyBootstrapSwitch = utils_vue.extend({
  name: bootstrap_switch_name,
  model: {
    prop: "checked",
    event: "change"
  },
  data: function data() {
    return {
      checkedStatus: null
    };
  },
  props: {
    // v-model绑定值
    checked: {
      type: [Boolean, String, Number],
      default: false
    },
    //内圆
    inverse: {
      type: Boolean,
      default: false
    },
    // onText
    onText: {
      type: String,
      default: "ON"
    },
    onVariant: {
      type: String,
      default: "default"
    },
    labelText: {
      type: String,
      default: ""
    },
    offVariant: {
      type: String,
      default: "default"
    },
    offText: {
      type: String,
      default: "OFF"
    },
    width: {
      type: [String, Number]
    },
    size: {
      type: String
    },
    disabled: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    animate: {
      type: Boolean,
      default: true
    },
    switchClass: {
      type: String
    },
    containerClass: {
      type: String
    },
    onClass: {
      type: String
    },
    labelClass: {
      type: String
    },
    offClass: {
      type: String
    }
  },
  computed: {
    customProps: function customProps() {
      if (toInteger(this.width)) {
        return {
          inverse: this.inverse,
          onText: this.onText,
          labelText: this.labelText,
          offText: this.offText,
          width: toInteger(this.width),
          disabled: this.disabled,
          readonly: this.readonly,
          size: "",
          animate: this.animate,
          onVariant: this.onVariant,
          offVariant: this.offVariant,
          switchClass: this.switchClass,
          containerClass: this.containerClass,
          onClass: this.onClass,
          labelClass: this.labelClass,
          offClass: this.offClass
        };
      } else {
        return {
          inverse: this.inverse,
          onText: this.onText,
          labelText: this.labelText,
          offText: this.offText,
          width: "",
          disabled: this.disabled,
          readonly: this.readonly,
          size: this.size,
          animate: this.animate,
          onVariant: this.onVariant,
          offVariant: this.offVariant,
          switchClass: this.switchClass,
          containerClass: this.containerClass,
          onClass: this.onClass,
          labelClass: this.labelClass,
          offClass: this.offClass
        };
      }
    }
  },
  created: function created() {
    this.checkedStatus = this.checked;
  },
  methods: {
    change: function change() {
      this.$emit("change", this.checkedStatus);
    },
    switchStauts: function switchStauts() {
      if (!this.customProps.disabled && !this.customProps.readonly) {
        this.checkedStatus = this.checkedStatus ? false : true;
        this.change();
      }
    },
    getSwitchClass: function getSwitchClass() {
      if (this.customProps.width) {
        return "";
      } else {
        if (this.customProps.size) {
          return nlyGetOptionsByKeyEqual(bootstrapSwitchOptions, this.customProps.size).class;
        } else {
          return "";
        }
      }
    },
    getSwitchWidth: function getSwitchWidth() {
      if (this.customProps.width) {
        return "".concat(this.customProps.width * 2 + 2, "px");
      } else {
        if (this.customProps.size) {
          return nlyGetOptionsByKeyEqual(bootstrapSwitchOptions, this.customProps.size).width;
        } else {
          return "110px";
        }
      }
    },
    getSwitchContainerWidth: function getSwitchContainerWidth() {
      if (this.customProps.width) {
        return "".concat(this.customProps.width * 3 + 2, "px");
      } else {
        if (this.customProps.size) {
          return nlyGetOptionsByKeyEqual(bootstrapSwitchOptions, this.customProps.size).containerWidth;
        } else {
          return "164px";
        }
      }
    },
    getSwitchItemWidth: function getSwitchItemWidth() {
      if (this.customProps.width) {
        return "".concat(this.customProps.width + 2, "px");
      } else {
        if (this.customProps.size) {
          return nlyGetOptionsByKeyEqual(bootstrapSwitchOptions, this.customProps.size).itemWidth;
        } else {
          return "54px";
        }
      }
    }
  },
  watch: {
    checked: function checked(newval, oldval) {
      if (newval != oldval) {
        this.checkedStatus = newval;
      }
    }
  },
  render: function render(h) {
    var _this = this;

    var switchContainer = function switchContainer() {
      return h("div", {
        staticClass: "bootstrap-switch-container",
        class: [_this.customProps.containerClass],
        style: {
          width: _this.getSwitchContainerWidth(),
          marginLeft: _this.checkedStatus ? "-" + _this.getSwitchItemWidth() : "0px"
        }
      }, [switchHandleOn(), switchLabel(), switchHandleOff(), inputArray()]);
    };

    var switchHandleOn = function switchHandleOn() {
      return h("span", {
        staticClass: "bootstrap-switch-handle-on",
        class: ["bootstrap-switch-".concat(_this.customProps.onVariant), _this.customProps.onClass],
        style: {
          width: _this.getSwitchItemWidth()
        }
      }, _this.customProps.onText);
    };

    var switchHandleOff = function switchHandleOff() {
      return h("span", {
        staticClass: "bootstrap-switch-handle-off",
        class: ["bootstrap-switch-".concat(_this.customProps.offVariant), _this.customProps.offClass],
        style: {
          width: _this.getSwitchItemWidth()
        }
      }, _this.customProps.offText);
    };

    var switchLabel = function switchLabel() {
      return h("span", {
        staticClass: "bootstrap-switch-label",
        class: [_this.customProps.labelClass],
        style: {
          width: _this.getSwitchItemWidth()
        }
      }, _this.customProps.labelText);
    };

    var inputArray = function inputArray() {
      return h("input", {
        attrs: {
          type: "checkbox"
        },
        domProps: {
          value: _this.checkedStatus,
          checked: _this.checkedStatus ? true : false
        }
      });
    };

    return h("div", {
      staticClass: "bootstrap-switch",
      class: [this.customProps.animate ? "bootstrap-switch-animate" : "", this.getSwitchClass(), this.customProps.disabled ? "bootstrap-switch-disabled" : "", this.customProps.inverse ? "bootstrap-switch-inverse" : "", this.customProps.readonly ? "bootstrap-switch-readonly" : "", this.customProps.switchClass],
      style: {
        width: this.getSwitchWidth()
      },
      on: {
        click: this.switchStauts
      }
    }, [switchContainer()]);
  }
});
// CONCATENATED MODULE: ./src/components/switch/index.js



var switchPlugin = plugins_nlyPluginFactory({
  components: {
    NlySwitch: NlySwitch,
    NlyBootstrapSwitch: NlyBootstrapSwitch
  }
});

// CONCATENATED MODULE: ./src/utils/props.js








 // Prefix a property

var props_prefixPropName = function prefixPropName(prefix, value) {
  return prefix + string_upperFirst(value);
}; // Remove a prefix from a property

var props_unprefixPropName = function unprefixPropName(prefix, value) {
  return string_lowerFirst(value.replace(prefix, ""));
}; // Suffix can be a falsey value so nothing is appended to string
// (helps when looping over props & some shouldn't change)
// Use data last parameters to allow for currying

var props_suffixPropName = function suffixPropName(suffix, str) {
  return str + (suffix ? string_upperFirst(suffix) : "");
}; // Copies props from one array/object to a new array/object
// Prop values are also cloned as new references to prevent possible
// mutation of original prop object values
// Optionally accepts a function to transform the prop name

var props_copyProps = function copyProps(props) {
  var transformFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : utils_identity;

  if (isArray(props)) {
    return props.map(transformFn);
  }

  var copied = {};

  for (var prop in props) {
    /* istanbul ignore else */
    if (object_hasOwnProperty(props, prop)) {
      // If the prop value is an object, do a shallow clone
      // to prevent potential mutations to the original object
      copied[transformFn(prop)] = object_isObject(props[prop]) ? object_clone(props[prop]) : props[prop];
    }
  }

  return copied;
}; // Given an array of properties or an object of property keys,
// plucks all the values off the target object, returning a new object
// that has props that reference the original prop values

var props_pluckProps = function pluckProps(keysToPluck, objToPluck) {
  var transformFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : utils_identity;
  return (isArray(keysToPluck) ? keysToPluck.slice() : keys(keysToPluck)).reduce(function (memo, prop) {
    memo[transformFn(prop)] = objToPluck[prop];
    return memo;
  }, {});
};
// CONCATENATED MODULE: ./src/components/toast/toaster.js






var toaster_NAME = "NlyToaster";
var toaster_props = {
  name: {
    type: String,
    required: true
  },
  ariaLive: {
    type: String,
    default: function _default() {
      return getComponentConfig(toaster_NAME, "ariaLive");
    }
  },
  ariaAtomic: {
    type: String,
    default: function _default() {
      return getComponentConfig(toaster_NAME, "ariaAtomic");
    } // Allowed: 'true' or 'false' or null

  },
  role: {
    type: String,
    default: function _default() {
      return getComponentConfig(toaster_NAME, "role");
    }
  }
};
var DefaultTransition = utils_vue.extend({
  data: function data() {
    return {
      name: "nly-toaster"
    };
  },
  methods: {
    onAfterEnter: function onAfterEnter(el) {
      var _this = this;

      requestAF(function () {
        removeClass(el, "".concat(_this.name, "-enter-to"));
      });
    }
  },
  render: function render(h) {
    return h("transition-group", {
      props: {
        tag: "div",
        name: this.name
      },
      on: {
        afterEnter: this.onAfterEnter
      }
    }, this.$slots.default);
  }
});
var NlyToaster = utils_vue.extend({
  name: toaster_NAME,
  props: toaster_props,
  data: function data() {
    return {
      doRender: false,
      dead: false,
      staticName: this.name
    };
  },
  beforeMount: function beforeMount() {
    var _this2 = this;

    this.staticName = this.name;

    if (portal_vue_common["Wormhole"].hasTarget(this.staticName)) {
      warn_warn("A \"<portal-target>\" with name \"".concat(this.name, "\" already exists in the document."), "NlyToaster");
      this.dead = true;
    } else {
      this.doRender = true;
      this.$once("hook:beforeDestroy", function () {
        _this2.$root.$emit("nlya::toaster::destroyed", _this2.staticName);
      });
    }
  },
  destroyed: function destroyed() {
    if (this.$el && this.$el.parentNode) {
      this.$el.parentNode.removeChild(this.$el);
    }
  },
  render: function render(h) {
    var $toaster = h("div", {
      class: ["d-none", {
        "nly-dead-toaster": this.dead
      }]
    });

    if (this.doRender) {
      var $target = h(portal_vue_common["PortalTarget"], {
        staticClass: "nly-toaster-slot",
        props: {
          name: this.staticName,
          multiple: true,
          tag: "div",
          slim: false,
          transition: DefaultTransition
        }
      });
      $toaster = h("div", {
        staticClass: "nly-toaster",
        class: [this.staticName],
        attrs: {
          id: this.staticName,
          role: this.role || null,
          "aria-live": this.ariaLive,
          "aria-atomic": this.ariaAtomic
        }
      }, [$target]);
    }

    return $toaster;
  }
});
// CONCATENATED MODULE: ./src/components/toast/toast.js























var toast_NAME = "NlyToast";
var MIN_DURATION = 1000;
var toast_linkProps = object_pick(link_props, ["href", "to"]);
var toast_props = Object(objectSpread2["a" /* default */])({
  id: {
    type: String,
    default: null
  },
  title: {
    type: String,
    default: null
  },
  toaster: {
    type: String,
    default: function _default() {
      return getComponentConfig(toast_NAME, "toaster");
    }
  },
  visible: {
    type: Boolean,
    default: false
  },
  variant: {
    type: String,
    default: function _default() {
      return getComponentConfig(toast_NAME, "variant");
    }
  },
  isStatus: {
    type: Boolean,
    default: false
  },
  appendToast: {
    type: Boolean,
    default: false
  },
  noAutoHide: {
    type: Boolean,
    default: false
  },
  autoHideDelay: {
    type: [Number, String],
    default: function _default() {
      return getComponentConfig(toast_NAME, "autoHideDelay");
    }
  },
  noCloseButton: {
    type: Boolean,
    default: false
  },
  noFade: {
    type: Boolean,
    default: false
  },
  noHoverPause: {
    type: Boolean,
    default: false
  },
  solid: {
    type: Boolean,
    default: false
  },
  toastClass: {
    type: [String, Object, Array],
    default: function _default() {
      return getComponentConfig(toast_NAME, "toastClass");
    }
  },
  headerClass: {
    type: [String, Object, Array],
    default: function _default() {
      return getComponentConfig(toast_NAME, "headerClass");
    }
  },
  bodyClass: {
    type: [String, Object, Array],
    default: function _default() {
      return getComponentConfig(toast_NAME, "bodyClass");
    }
  },
  static: {
    type: Boolean,
    default: false
  }
}, toast_linkProps);
var NlyToast = utils_vue.extend({
  name: toast_NAME,
  mixins: [mixins_attrs, mixins_id, listen_on_root, mixins_normalize_slot, scoped_style_attrs],
  inheritAttrs: false,
  model: {
    prop: "visible",
    event: "change"
  },
  props: toast_props,
  data: function data() {
    return {
      isMounted: false,
      doRender: false,
      localShow: false,
      isTransitioning: false,
      isHiding: false,
      order: 0,
      timer: null,
      dismissStarted: 0,
      resumeDismiss: 0
    };
  },
  computed: {
    customToastClasses: function customToastClasses() {
      return Object(defineProperty["a" /* default */])({
        "nly-toast-solid": this.solid,
        "nly-toast-append": this.appendToast,
        "nly-toast-prepend": !this.appendToast
      }, "nly-toast-".concat(this.variant), this.variant);
    },
    slotScope: function slotScope() {
      return {
        hide: this.hide
      };
    },
    computedDuration: function computedDuration() {
      return Math.max(toInteger(this.autoHideDelay) || 0, MIN_DURATION);
    },
    computedToaster: function computedToaster() {
      return String(this.toaster);
    },
    transitionHandlers: function transitionHandlers() {
      return {
        beforeEnter: this.onBeforeEnter,
        afterEnter: this.onAfterEnter,
        beforeLeave: this.onBeforeLeave,
        afterLeave: this.onAfterLeave
      };
    },
    computedAttrs: function computedAttrs() {
      return Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.nlyaAttrs), {}, {
        id: this.safeId(),
        tabindex: "0"
      });
    }
  },
  watch: {
    visible: function visible(newVal) {
      newVal ? this.show() : this.hide();
    },
    localShow: function localShow(newVal) {
      if (newVal !== this.visible) {
        this.$emit("change", newVal);
      }
    },
    // eslint-disable-next-line no-unused-vars
    toaster: function toaster(newVal) {
      this.$nextTick(this.ensureToaster);
    },
    static: function _static(newVal) {
      if (newVal && this.localShow) {
        this.ensureToaster();
      }
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.isMounted = true;
    this.$nextTick(function () {
      if (_this.visible) {
        requestAF(function () {
          _this.show();
        });
      }
    }); // Listen for global $root show events

    this.listenOnRoot("nlya::show::toast", function (id) {
      if (id === _this.safeId()) {
        _this.show();
      }
    }); // Listen for global $root hide events

    this.listenOnRoot("nlya::hide::toast", function (id) {
      if (!id || id === _this.safeId()) {
        _this.hide();
      }
    });
    this.listenOnRoot("nlya::toaster::destroyed", function (toaster) {
      if (toaster === _this.computedToaster) {
        _this.hide();
      }
    });
  },
  beforeDestroy: function beforeDestroy() {
    this.clearDismissTimer();
  },
  methods: {
    show: function show() {
      var _this2 = this;

      if (!this.localShow) {
        this.ensureToaster();
        var showEvt = this.buildEvent("show");
        this.emitEvent(showEvt);
        this.dismissStarted = this.resumeDismiss = 0;
        this.order = Date.now() * (this.appendToast ? 1 : -1);
        this.isHiding = false;
        this.doRender = true;
        this.$nextTick(function () {
          requestAF(function () {
            _this2.localShow = true;
          });
        });
      }
    },
    hide: function hide() {
      var _this3 = this;

      if (this.localShow) {
        var hideEvt = this.buildEvent("hide");
        this.emitEvent(hideEvt);
        this.setHoverHandler(false);
        this.dismissStarted = this.resumeDismiss = 0;
        this.clearDismissTimer();
        this.isHiding = true;
        requestAF(function () {
          _this3.localShow = false;
        });
      }
    },
    buildEvent: function buildEvent(type) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new nly_event_class_NlyEvent(type, Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({
        cancelable: false,
        target: this.$el || null,
        relatedTarget: null
      }, options), {}, {
        vueTarget: this,
        componentId: this.safeId()
      }));
    },
    emitEvent: function emitEvent(nlyaEvt) {
      var type = nlyaEvt.type;
      this.$root.$emit("nlya::toast:".concat(type), nlyaEvt);
      this.$emit(type, nlyaEvt);
    },
    ensureToaster: function ensureToaster() {
      if (this.static) {
        return;
      }

      if (!portal_vue_common["Wormhole"].hasTarget(this.computedToaster)) {
        var div = document.createElement("div");
        document.body.appendChild(div);
        var toaster = new NlyToaster({
          parent: this.$root,
          propsData: {
            name: this.computedToaster
          }
        });
        toaster.$mount(div);
      }
    },
    startDismissTimer: function startDismissTimer() {
      this.clearDismissTimer();

      if (!this.noAutoHide) {
        this.timer = setTimeout(this.hide, this.resumeDismiss || this.computedDuration);
        this.dismissStarted = Date.now();
        this.resumeDismiss = 0;
      }
    },
    clearDismissTimer: function clearDismissTimer() {
      clearTimeout(this.timer);
      this.timer = null;
    },
    setHoverHandler: function setHoverHandler(on) {
      var el = this.$refs["nly-toast"];
      eventOnOff(on, el, "mouseenter", this.onPause, EVENT_OPTIONS_NO_CAPTURE);
      eventOnOff(on, el, "mouseleave", this.onUnPause, EVENT_OPTIONS_NO_CAPTURE);
    },
    onPause: function onPause() {
      if (this.noAutoHide || this.noHoverPause || !this.timer || this.resumeDismiss) {
        return;
      }

      var passed = Date.now() - this.dismissStarted;

      if (passed > 0) {
        this.clearDismissTimer();
        this.resumeDismiss = mathMax(this.computedDuration - passed, MIN_DURATION);
      }
    },
    onUnPause: function onUnPause() {
      // Restart timer with max of time remaining or 1 second
      if (this.noAutoHide || this.noHoverPause || !this.resumeDismiss) {
        this.resumeDismiss = this.dismissStarted = 0;
        return;
      }

      this.startDismissTimer();
    },
    onLinkClick: function onLinkClick() {
      var _this4 = this;

      // We delay the close to allow time for the
      // browser to process the link click
      this.$nextTick(function () {
        requestAF(function () {
          _this4.hide();
        });
      });
    },
    onBeforeEnter: function onBeforeEnter() {
      this.isTransitioning = true;
    },
    onAfterEnter: function onAfterEnter() {
      this.isTransitioning = false;
      var hiddenEvt = this.buildEvent("shown");
      this.emitEvent(hiddenEvt);
      this.startDismissTimer();
      this.setHoverHandler(true);
    },
    onBeforeLeave: function onBeforeLeave() {
      this.isTransitioning = true;
    },
    onAfterLeave: function onAfterLeave() {
      this.isTransitioning = false;
      this.order = 0;
      this.resumeDismiss = this.dismissStarted = 0;
      var hiddenEvt = this.buildEvent("hidden");
      this.emitEvent(hiddenEvt);
      this.doRender = false;
    },
    makeToast: function makeToast(h) {
      var _this5 = this;

      var $headerContent = [];
      var $title = this.normalizeSlot("toast-title", this.slotScope);

      if ($title) {
        $headerContent.push($title);
      } else if (this.title) {
        $headerContent.push(h("strong", {
          staticClass: "mr-2"
        }, this.title));
      }

      if (!this.noCloseButton) {
        $headerContent.push(h(NlyButtonClose, {
          staticClass: "ml-auto mb-1",
          on: {
            click: function click() {
              _this5.hide();
            }
          }
        }));
      }

      var $header = h();

      if ($headerContent.length > 0) {
        $header = h("header", {
          staticClass: "toast-header",
          class: this.headerClass
        }, $headerContent);
      }

      var link = isLink(this);
      var $body = h(link ? NlyLink : "div", {
        staticClass: "toast-body",
        class: this.bodyClass,
        props: link ? props_pluckProps(toast_linkProps, this) : {},
        on: link ? {
          click: this.onLinkClick
        } : {}
      }, [this.normalizeSlot("default", this.slotScope) || h()]);
      var $toast = h("div", {
        key: "toast-".concat(this._uid),
        ref: "toast",
        staticClass: "toast",
        class: this.toastClass,
        attrs: this.computedAttrs
      }, [$header, $body]);
      return $toast;
    }
  },
  render: function render(h) {
    if (!this.doRender || !this.isMounted) {
      return h();
    }

    var name = "nly-toast-".concat(this._uid);
    var scopedStyleAttrs = !this.static ? this.scopedStyleAttrs : {};
    return h(portal_vue_common["Portal"], {
      props: {
        name: name,
        to: this.computedToaster,
        order: this.order,
        slim: true,
        disabled: this.static
      }
    }, [h("div", {
      key: name,
      ref: "nly-toast",
      staticClass: "nly-toast",
      class: this.customToastClasses,
      attrs: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, scopedStyleAttrs), {}, {
        id: this.safeId("_toast_outer"),
        role: this.isHiding ? null : this.isStatus ? "status" : "alert",
        "aria-live": this.isHiding ? null : this.isStatus ? "polite" : "assertive",
        "aria-atomic": this.isHiding ? null : "true"
      })
    }, [h(nly_toast_transition, {
      props: {
        noFade: this.noFade
      },
      on: this.transitionHandlers
    }, [this.localShow ? this.makeToast(h) : h()])])]);
  }
});
// CONCATENATED MODULE: ./src/components/toast/plugin/nlya-toast.js
















var nlya_toast_PROP_NAME = "$nlyaToast";
var nlya_toast_PROP_NAME_PRIV = "_nlya__toast";
var nlya_toast_BASE_PROPS = ["id"].concat(_toConsumableArray(keys(object_omit(toast_props, ["static", "visible"]))));
var nlya_toast_propsToSlots = {
  toastContent: "default",
  title: "toast-title"
};

var nlya_toast_filterOptions = function filterOptions(options) {
  return nlya_toast_BASE_PROPS.reduce(function (memo, key) {
    if (!isUndefined(options[key])) {
      memo[key] = options[key];
    }

    return memo;
  }, {});
};

var nlya_toast_plugin = function plugin(Vue) {
  var NlyToastPop = Vue.extend({
    name: "NlyToastPop",
    extends: NlyToast,
    destroyed: function destroyed() {
      if (this.$el && this.$el.parentNode) {
        this.$el.parentNode.removeChild(this.$el);
      }
    },
    mounted: function mounted() {
      var self = this;

      var handleDestroy = function handleDestroy() {
        self.localShow = false;
        self.doRender = false;
        self.$nextTick(function () {
          self.$nextTick(function () {
            requestAF(function () {
              self.$destroy();
            });
          });
        });
      };

      this.$parent.$once("hook:destroyed", handleDestroy);
      this.$once("hidden", handleDestroy);
      this.listenOnRoot("nlya::toaster::destroyed", function (toaster) {
        if (toaster === self.toaster) {
          handleDestroy();
        }
      });
    }
  });

  var makeToast = function makeToast(props, $parent) {
    if (warn_warnNotClient(nlya_toast_PROP_NAME)) {
      return;
    }

    var toast = new NlyToastPop({
      parent: $parent,
      propsData: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, nlya_toast_filterOptions(getComponentConfig("NlyToast") || {})), object_omit(props, keys(nlya_toast_propsToSlots))), {}, {
        static: false,
        visible: true
      })
    });
    keys(nlya_toast_propsToSlots).forEach(function (prop) {
      var value = props[prop];

      if (!isUndefined(value)) {
        if (prop === "title" && isString(value)) {
          value = [$parent.$createElement("strong", {
            class: "mr-2"
          }, value)];
        }

        toast.$slots[nlya_toast_propsToSlots[prop]] = concat(value);
      }
    });
    var div = document.createElement("div");
    document.body.appendChild(div);
    toast.$mount(div);
  };

  var NlyaToast = /*#__PURE__*/function () {
    function NlyaToast(vm) {
      _classCallCheck(this, NlyaToast);

      object_assign(this, {
        _vm: vm,
        _root: vm.$root
      });
      defineProperties(this, {
        _vm: readonlyDescriptor(),
        _root: readonlyDescriptor()
      });
    }

    _createClass(NlyaToast, [{
      key: "toast",
      value: function toast(content) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (!content || warn_warnNotClient(nlya_toast_PROP_NAME)) {
          return;
        }

        makeToast(Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, nlya_toast_filterOptions(options)), {}, {
          toastContent: content
        }), this._vm);
      }
    }, {
      key: "show",
      value: function show(id) {
        if (id) {
          this._root.$emit("nlya::show::toast", id);
        }
      }
    }, {
      key: "hide",
      value: function hide() {
        var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        this._root.$emit("nlya::hide::toast", id);
      }
    }]);

    return NlyaToast;
  }();

  Vue.mixin({
    beforeCreate: function beforeCreate() {
      this[nlya_toast_PROP_NAME_PRIV] = new NlyaToast(this);
    }
  }); // eslint-disable-next-line no-prototype-builtins

  if (!Vue.prototype.hasOwnProperty(nlya_toast_PROP_NAME)) {
    object_defineProperty(Vue.prototype, nlya_toast_PROP_NAME, {
      get: function get() {
        if (!this || !this[nlya_toast_PROP_NAME_PRIV]) {
          warn_warn("\"".concat(nlya_toast_PROP_NAME, "\" must be accessed from a Vue instance \"this\" context."), "NlyToast");
        }

        return this[nlya_toast_PROP_NAME_PRIV];
      }
    });
  }
};

var NLYAToastPlugin = plugins_nlyPluginFactory({
  plugins: {
    plugin: nlya_toast_plugin
  }
});
// CONCATENATED MODULE: ./src/components/toast/index.js




var toastPlugin = plugins_nlyInstallFactory({
  components: {
    NlyToast: NlyToast,
    NlyToaster: NlyToaster
  },
  plugins: {
    NLYAToastPlugin: NLYAToastPlugin
  }
});

// CONCATENATED MODULE: ./src/components/timeline/timeline.js

var timeline_name = "NlyTimeline";
var NlyTimeline = utils_vue.extend({
  name: timeline_name,
  props: {
    inverse: {
      type: Boolean,
      default: false
    },
    tag: {
      type: String,
      default: "div"
    }
  },
  computed: {
    customProps: function customProps() {
      return {
        inverse: this.inverse ? "timeline-inverse" : "",
        tag: this.tag
      };
    }
  },
  render: function render(h) {
    return h(this.customProps.tag, {
      staticClass: "timeline",
      class: [this.customProps.inverse]
    }, this.$slots.default);
  }
});
// CONCATENATED MODULE: ./src/components/timeline/timeline-label.js



var timeline_label_name = "NlyTimelineLabel";
var NlyTimelineLabel = utils_vue.extend({
  name: timeline_label_name,
  props: {
    bgVariant: {
      type: String
    },
    bgGradientVariant: {
      type: String
    },
    tag: {
      type: String,
      default: "div"
    },
    labelClass: {
      type: String
    },
    spanClass: {
      type: String
    }
  },
  computed: {
    customProps: function customProps() {
      return {
        bgVariant: nlyGetOptionsByKeyEqual(bgVariantOptions, this.bgVariant),
        bgGradientVariant: nlyGetOptionsByKeyEqual(bgGradientOptions, this.bgGradientVariant),
        tag: this.tag,
        labelClass: this.labelClass,
        spanClass: this.spanClass
      };
    }
  },
  render: function render(h) {
    return h(this.customProps.tag, {
      staticClass: "time-label",
      class: [this.customProps.labelClass]
    }, [h("span", {
      class: [this.customProps.bgVariant, this.customProps.bgGradientVariant, this.customProps.spanClass]
    }, this.$slots.default)]);
  }
});
// CONCATENATED MODULE: ./src/components/timeline/timeline-content.js



var timeline_content_name = "NlyTimelineContent";
var NlyTimelineContent = utils_vue.extend({
  name: timeline_content_name,
  inheritAttrs: false,
  props: {
    icon: {
      type: String
    },
    bgVariant: {
      type: String
    },
    bgGradientVariant: {
      type: String
    },
    iconClass: {
      type: String
    },
    timelineContentClass: {
      type: String
    }
  },
  computed: {
    customProps: function customProps() {
      return {
        bgVariant: nlyGetOptionsByKeyEqual(bgVariantOptions, this.bgVariant),
        bgGradientVariant: nlyGetOptionsByKeyEqual(bgGradientOptions, this.bgGradientVariant),
        icon: this.icon,
        iconClass: this.iconClass
      };
    }
  },
  render: function render(h) {
    var _this = this;

    var timelineContentArray = function timelineContentArray() {
      if (_this.icon) {
        return h("div", [h("i", {
          class: [_this.customProps.icon, _this.customProps.bgVariant, _this.customProps.bgGradientVariant, _this.customProps.iconClass]
        }), _this.$slots.default]);
      } else {
        return h("div", _this.$slots.default);
      }
    };

    return timelineContentArray();
  }
});
// CONCATENATED MODULE: ./src/components/timeline/timeline-item.js
{
  /* <div class="timeline-item">
  <span class="time">
    <i class="fas fa-clock"></i> 12:05
  </span>
  <h3 class="timeline-header">
    <a href="#">Support Team</a> sent you an email
  </h3>
    <div class="timeline-body">
    Etsy doostang zoodles disqus groupon greplin oooj voxy zoodles, weebly ning
    heekya handango imeem plugg dopplr jibjab, movity jajah plickers sifteo
    edmodo ifttt zimbra. Babblely odeo kaboodle quora plaxo ideeli hulu weebly
    balihoo...
  </div>
  <div class="timeline-footer">
    <a class="btn btn-primary btn-sm">Read more</a>
    <a class="btn btn-danger btn-sm">Delete</a>
  </div>
  </div>; */
}


var timeline_item_name = "NlyTimelineItem";
var NlyTimelineItem = utils_vue.extend({
  name: timeline_item_name,
  props: {
    time: {
      type: String
    },
    timeIcon: {
      type: String
    },
    timeTag: {
      type: String,
      default: "span"
    },
    itemTag: {
      type: String,
      default: "div"
    },
    itemClass: {
      type: String
    },
    timeClass: {
      type: String
    }
  },
  computed: {
    customProps: function customProps() {
      return {
        time: this.time,
        timeIcon: this.timeIcon,
        timeTag: this.timeTag,
        timeClass: this.timeClass,
        itemClass: this.itemClass,
        itemTag: this.itemTag
      };
    }
  },
  render: function render(h) {
    var _this = this;

    var timeArray = function timeArray() {
      if (_this.customProps.time) {
        if (_this.customProps.timeIcon) {
          return h(_this.customProps.timeTag, {
            staticClass: ["time"],
            class: [_this.customProps.timeClass]
          }, [h(NlyIcon, {
            props: {
              icon: _this.customProps.timeIcon
            }
          }), _this.customProps.time]);
        } else {
          return h(_this.customProps.timeTag, {
            staticClass: ["time"],
            class: [_this.customProps.timeClass]
          }, _this.customProps.time);
        }
      }
    };

    return h(this.customProps.itemTag, {
      staticClass: ["timeline-item"],
      class: [this.customProps.itemClass]
    }, [timeArray(), this.$slots.default]);
  }
});
// CONCATENATED MODULE: ./src/components/timeline/timeline-header.js

var timeline_header_name = "NlyTimelineHeader";
var NlyTimelineHeader = utils_vue.extend({
  name: timeline_header_name,
  props: {
    tag: {
      type: String,
      default: "h3"
    },
    timelineHeaderClass: {
      type: String
    }
  },
  computed: {
    customProps: function customProps() {
      return {
        tag: this.tag,
        timelineHeaderClass: this.timelineHeaderClass
      };
    }
  },
  render: function render(h) {
    return h(this.customProps.tag, {
      staticClass: "timeline-header",
      class: [this.customProps.timelineHeaderClass]
    }, this.$slots.default);
  }
});
// CONCATENATED MODULE: ./src/components/timeline/timeline-body.js

var timeline_body_name = "NlyTimelineBody";
var NlyTimelineBody = utils_vue.extend({
  name: timeline_body_name,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    timelineBodyClass: {
      type: String
    }
  },
  computed: {
    customProps: function customProps() {
      return {
        tag: this.tag,
        timelineBodyClass: this.timelineBodyClass
      };
    }
  },
  render: function render(h) {
    return h(this.customProps.tag, {
      staticClass: "timeline-body",
      class: [this.customProps.timelineBodyClass]
    }, this.$slots.default);
  }
});
// CONCATENATED MODULE: ./src/components/timeline/timeline-footer.js

var timeline_footer_name = "NlyTimelineFooter";
var NlyTimelineFooter = utils_vue.extend({
  name: timeline_footer_name,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    timelineFooterClass: {
      type: String
    }
  },
  computed: {
    customProps: function customProps() {
      return {
        tag: this.tag,
        timelineFooterClass: this.timelineFooterClass
      };
    }
  },
  render: function render(h) {
    return h(this.customProps.tag, {
      staticClass: "timeline-footer",
      class: [this.customProps.timelineFooterClass]
    }, this.$slots.default);
  }
});
// CONCATENATED MODULE: ./src/components/timeline/index.js








var timelinePlugin = plugins_nlyPluginFactory({
  components: {
    NlyTimeline: NlyTimeline,
    NlyTimelineLabel: NlyTimelineLabel,
    NlyTimelineContent: NlyTimelineContent,
    NlyTimelineItem: NlyTimelineItem,
    NlyTimelineHeader: NlyTimelineHeader,
    NlyTimelineBody: NlyTimelineBody,
    NlyTimelineFooter: NlyTimelineFooter
  }
});

// CONCATENATED MODULE: ./src/mixins/has-listener.js
// 检测监听事件是否已经注册
// 或者同一个名称的事件再父组件中已经注册

/* harmony default export */ var has_listener = ({
  methods: {
    hasListener: function hasListener(name) {
      // 监测只包括 v-on:这一类的
      var $listeners = this.$listeners || {}; // 包括 `v-on:name` and `this.$on('name')`两类

      var $events = this._events || {};
      return !isUndefined($listeners[name]) || isArray($events[name]) && $events[name].length > 0;
    }
  }
});
// CONCATENATED MODULE: ./src/utils/startcase.js


var RX_UNDERSCORE = /_/g;
var RX_LOWER_UPPER = /([a-z])([A-Z])/g;
var RX_START_SPACE_WORD = /(\s|^)(\w)/g;

var startCase = function startCase(str) {
  return str.replace(RX_UNDERSCORE, " ").replace(RX_LOWER_UPPER, function (str, $1, $2) {
    return $1 + " " + $2;
  }).replace(RX_START_SPACE_WORD, function (str, $1, $2) {
    return $1 + $2.toUpperCase();
  });
};

/* harmony default export */ var startcase = (startCase);
// CONCATENATED MODULE: ./src/components/table/plugin/constants.js

var IGNORED_FIELD_KEYS = {
  _rowVariant: true,
  _cellVariants: true,
  _showDetails: true
};
var EVENT_FILTER = ["a", "a *", // Include content inside links
"button", "button *", // Include content inside buttons
"input:not(.disabled):not([disabled])", "select:not(.disabled):not([disabled])", "textarea:not(.disabled):not([disabled])", '[role="link"]', '[role="link"] *', '[role="button"]', '[role="button"] *', "[tabindex]:not(.disabled):not([disabled])"].join(",");
// CONCATENATED MODULE: ./src/components/table/plugin/normalize-fields.js







 // Private function to massage field entry into common object format

var normalize_fields_processField = function processField(key, value) {
  var field = null;

  if (isString(value)) {
    // Label shortcut
    field = {
      key: key,
      label: value
    };
  } else if (isFunction(value)) {
    // Formatter shortcut
    field = {
      key: key,
      formatter: value
    };
  } else if (object_isObject(value)) {
    field = object_clone(value);
    field.key = field.key || key;
  } else if (value !== false) {
    // Fallback to just key

    /* istanbul ignore next */
    field = {
      key: key
    };
  }

  return field;
}; // We normalize fields into an array of objects
// [ { key:..., label:..., ...}, {...}, ..., {..}]


var normalize_fields_normalizeFields = function normalizeFields(origFields, items) {
  var fields = [];

  if (isArray(origFields)) {
    // Normalize array Form
    origFields.filter(utils_identity).forEach(function (f) {
      if (isString(f)) {
        fields.push({
          key: f,
          label: startcase(f)
        });
      } else if (object_isObject(f) && f.key && isString(f.key)) {
        // Full object definition. We use assign so that we don't mutate the original
        fields.push(object_clone(f));
      } else if (object_isObject(f) && keys(f).length === 1) {
        // Shortcut object (i.e. { 'foo_bar': 'This is Foo Bar' }
        var key = keys(f)[0];
        var field = normalize_fields_processField(key, f[key]);

        if (field) {
          fields.push(field);
        }
      }
    });
  } // If no field provided, take a sample from first record (if exits)


  if (fields.length === 0 && isArray(items) && items.length > 0) {
    var sample = items[0];
    keys(sample).forEach(function (k) {
      if (!IGNORED_FIELD_KEYS[k]) {
        fields.push({
          key: k,
          label: startcase(k)
        });
      }
    });
  } // Ensure we have a unique array of fields and that they have String labels


  var memo = {};
  return fields.filter(function (f) {
    if (!memo[f.key]) {
      memo[f.key] = true;
      f.label = isString(f.label) ? f.label : startcase(f.key);
      return true;
    }

    return false;
  });
};

/* harmony default export */ var normalize_fields = (normalize_fields_normalizeFields);
// CONCATENATED MODULE: ./src/components/table/plugin/mixin-items.js






/* harmony default export */ var mixin_items = ({
  props: {
    items: {
      // Provider mixin adds in `Function` type
      type: Array,
      default: function _default()
      /* istanbul ignore next */
      {
        return [];
      }
    },
    fields: {
      type: Array,
      default: null
    },
    primaryKey: {
      // Primary key for record
      // If provided the value in each row must be unique!
      type: String,
      default: null
    },
    value: {
      // `v-model` for retrieving the current displayed rows
      type: Array,
      default: function _default() {
        return [];
      }
    }
  },
  data: function data() {
    return {
      // Our local copy of the items
      // Must be an array
      localItems: isArray(this.items) ? this.items.slice() : []
    };
  },
  computed: {
    computedFields: function computedFields() {
      // We normalize fields into an array of objects
      // `[ { key:..., label:..., ...}, {...}, ..., {..}]`
      return normalize_fields(this.fields, this.localItems);
    },
    computedFieldsObj: function computedFieldsObj() {
      // Fields as a simple lookup hash object
      // Mainly for formatter lookup and use in `scopedSlots` for convenience
      // If the field has a formatter, it normalizes formatter to a
      // function ref or `undefined` if no formatter
      var parent = this.$parent;
      return this.computedFields.reduce(function (obj, f) {
        // We use object spread here so we don't mutate the original field object
        obj[f.key] = object_clone(f);

        if (f.formatter) {
          // Normalize formatter to a function ref or `undefined`
          var formatter = f.formatter;

          if (isString(formatter) && isFunction(parent[formatter])) {
            formatter = parent[formatter];
          } else if (!isFunction(formatter)) {
            /* istanbul ignore next */
            formatter = undefined;
          } // Return formatter function or `undefined` if none


          obj[f.key].formatter = formatter;
        }

        return obj;
      }, {});
    },
    computedItems: function computedItems() {
      // Fallback if various mixins not provided
      return (this.paginatedItems || this.sortedItems || this.filteredItems || this.localItems || []).slice();
    },
    context: function context() {
      // Current state of sorting, filtering and pagination props/values
      return {
        filter: this.localFilter,
        sortBy: this.localSortBy,
        sortDesc: this.localSortDesc,
        perPage: parseInt(this.perPage, 10) || 0,
        currentPage: parseInt(this.currentPage, 10) || 1,
        apiUrl: this.apiUrl
      };
    }
  },
  watch: {
    items: function items(newItems) {
      /* istanbul ignore else */
      if (isArray(newItems)) {
        // Set `localItems`/`filteredItems` to a copy of the provided array
        this.localItems = newItems.slice();
      } else if (isUndefinedOrNull(newItems)) {
        /* istanbul ignore next */
        this.localItems = [];
      }
    },
    // Watch for changes on `computedItems` and update the `v-model`
    computedItems: function computedItems(newVal) {
      this.$emit("input", newVal);
    },
    // Watch for context changes
    context: function context(newVal, oldVal) {
      // Emit context information for external paging/filtering/sorting handling
      if (!loose_equal(newVal, oldVal)) {
        this.$emit("context-changed", newVal);
      }
    }
  },
  mounted: function mounted() {
    // Initially update the `v-model` of displayed items
    this.$emit("input", this.computedItems);
  },
  methods: {
    // Method to get the formatter method for a given field key
    getFieldFormatter: function getFieldFormatter(key) {
      var field = this.computedFieldsObj[key]; // `this.computedFieldsObj` has pre-normalized the formatter to a
      // function ref if present, otherwise `undefined`

      return field ? field.formatter : undefined;
    }
  }
});
// CONCATENATED MODULE: ./src/components/table/plugin/mixin-stacked.js

/* harmony default export */ var mixin_stacked = ({
  props: {
    stacked: {
      type: [Boolean, String],
      default: false
    }
  },
  computed: {
    isStacked: function isStacked() {
      // `true` when always stacked, or returns breakpoint specified
      return this.stacked === "" ? true : this.stacked;
    },
    isStackedAlways: function isStackedAlways() {
      return this.isStacked === true;
    },
    stackedTableClasses: function stackedTableClasses() {
      return Object(defineProperty["a" /* default */])({
        "nly-table-stacked": this.isStackedAlways
      }, "nly-table-stacked-".concat(this.stacked), !this.isStackedAlways && this.isStacked);
    }
  }
});
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.constructor.js
var es_regexp_constructor = __webpack_require__("4d63");

// CONCATENATED MODULE: ./src/components/table/plugin/sanitize-row.js




 // Return a copy of a row after all reserved fields have been filtered out

var sanitize_row_sanitizeRow = function sanitizeRow(row, ignoreFields, includeFields) {
  var fieldsObj = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return keys(row).reduce(function (obj, key) {
    // Ignore special fields that start with `_`
    // Ignore fields in the `ignoreFields` array
    // Include only fields in the `includeFields` array
    if (!IGNORED_FIELD_KEYS[key] && !(ignoreFields && ignoreFields.length > 0 && arrayIncludes(ignoreFields, key)) && !(includeFields && includeFields.length > 0 && !arrayIncludes(includeFields, key))) {
      var f = fieldsObj[key] || {};
      var val = row[key]; // `f.filterByFormatted` will either be a function or boolean
      // `f.formater` will have already been noramlized into a function ref

      var filterByFormatted = f.filterByFormatted;
      var formatter = isFunction(filterByFormatted) ? filterByFormatted : filterByFormatted ? f.formatter : null;
      obj[key] = isFunction(formatter) ? formatter(val, key, row) : val;
    }

    return obj;
  }, {});
};

/* harmony default export */ var sanitize_row = (sanitize_row_sanitizeRow);
// CONCATENATED MODULE: ./src/components/table/plugin/stringify-object-values.js





 // Recursively stringifies the values of an object, space separated, in an
// SSR safe deterministic way (keys are sorted before stringification)
//
//   ex:
//     { b: 3, c: { z: 'zzz', d: null, e: 2 }, d: [10, 12, 11], a: 'one' }
//   becomes
//     'one 3 2 zzz 10 12 11'
//
// Primitives (numbers/strings) are returned as-is
// Null and undefined values are filtered out
// Dates are converted to their native string format

var stringify_object_values_stringifyObjectValues = function stringifyObjectValues(val) {
  if (isUndefinedOrNull(val)) {
    /* istanbul ignore next */
    return "";
  } // Arrays are also object, and keys just returns the array indexes
  // Date objects we convert to strings


  if (object_isObject(val) && !isDate(val)) {
    return keys(val).sort() // Sort to prevent SSR issues on pre-rendered sorted tables
    .filter(function (v) {
      return !isUndefinedOrNull(v);
    }) // Ignore undefined/null values
    .map(function (k) {
      return stringifyObjectValues(val[k]);
    }).join(" ");
  }

  return string_toString(val);
};

/* harmony default export */ var stringify_object_values = (stringify_object_values_stringifyObjectValues);
// CONCATENATED MODULE: ./src/components/table/plugin/stringify-record-values.js


 // Stringifies the values of a record, ignoring any special top level field keys
// TODO: Add option to stringify `scopedSlot` items

var stringify_record_values_stringifyRecordValues = function stringifyRecordValues(row, ignoreFields, includeFields, fieldsObj) {
  return object_isObject(row) ? stringify_object_values(sanitize_row(row, ignoreFields, includeFields, fieldsObj)) : "";
};

/* harmony default export */ var stringify_record_values = (stringify_record_values_stringifyRecordValues);
// CONCATENATED MODULE: ./src/components/table/plugin/mixin-filtering.js














var DEBOUNCE_DEPRECATED_MSG = 'Prop "filter-debounce" 不推荐使用. 请用 "<nly-form-input>" debounce prop 代替.';
var RX_SPACES = /[\s\uFEFF\xA0]+/g;
/* harmony default export */ var mixin_filtering = ({
  props: {
    filter: {
      type: [String, RegExp, Object, Array],
      default: null
    },
    filterFunction: {
      type: Function,
      default: null
    },
    filterIgnoredFields: {
      type: Array // default: undefined

    },
    filterIncludedFields: {
      type: Array // default: undefined

    },
    filterDebounce: {
      type: [Number, String],
      deprecated: DEBOUNCE_DEPRECATED_MSG,
      default: 0,
      validator: function validator(val) {
        return /^\d+/.test(String(val));
      }
    }
  },
  data: function data() {
    return {
      // Flag for displaying which empty slot to show and some event triggering
      isFiltered: false,
      // Where we store the copy of the filter criteria after debouncing
      // We pre-set it with the sanitized filter value
      localFilter: this.filterSanitize(this.filter)
    };
  },
  computed: {
    computedFilterIgnored: function computedFilterIgnored() {
      return this.filterIgnoredFields ? concat(this.filterIgnoredFields).filter(Boolean) : null;
    },
    computedFilterIncluded: function computedFilterIncluded() {
      return this.filterIncludedFields ? concat(this.filterIncludedFields).filter(Boolean) : null;
    },
    computedFilterDebounce: function computedFilterDebounce() {
      var ms = toInteger(this.filterDebounce) || 0;
      /* istanbul ignore next */

      if (ms > 0) {
        warn_warn(DEBOUNCE_DEPRECATED_MSG, "NlyTable");
      }

      return ms;
    },
    localFiltering: function localFiltering() {
      return this.hasProvider ? !!this.noProviderFiltering : true;
    },
    // For watching changes to `filteredItems` vs `localItems`
    filteredCheck: function filteredCheck() {
      return {
        filteredItems: this.filteredItems,
        localItems: this.localItems,
        localFilter: this.localFilter
      };
    },
    // Sanitized/normalize filter-function prop
    localFilterFn: function localFilterFn() {
      // Return `null` to signal to use internal filter function
      return isFunction(this.filterFunction) ? this.filterFunction : null;
    },
    // Returns the records in `localItems` that match the filter criteria
    // Returns the original `localItems` array if not sorting
    filteredItems: function filteredItems() {
      var items = this.localItems || []; // Note the criteria is debounced and sanitized

      var criteria = this.localFilter; // Resolve the filtering function, when requested
      // We prefer the provided filtering function and fallback to the internal one
      // When no filtering criteria is specified the filtering factories will return `null`

      var filterFn = this.localFiltering ? this.filterFnFactory(this.localFilterFn, criteria) || this.defaultFilterFnFactory(criteria) : null; // We only do local filtering when requested and there are records to filter

      return filterFn && items.length > 0 ? items.filter(filterFn) : items;
    }
  },
  watch: {
    // Watch for debounce being set to 0
    computedFilterDebounce: function computedFilterDebounce(newVal) {
      if (!newVal && this.$_filterTimer) {
        clearTimeout(this.$_filterTimer);
        this.$_filterTimer = null;
        this.localFilter = this.filterSanitize(this.filter);
      }
    },
    // Watch for changes to the filter criteria, and debounce if necessary
    filter: {
      // We need a deep watcher in case the user passes
      // an object when using `filter-function`
      deep: true,
      handler: function handler(newCriteria) {
        var _this = this;

        var timeout = this.computedFilterDebounce;
        clearTimeout(this.$_filterTimer);
        this.$_filterTimer = null;

        if (timeout && timeout > 0) {
          // If we have a debounce time, delay the update of `localFilter`
          this.$_filterTimer = setTimeout(function () {
            _this.localFilter = _this.filterSanitize(newCriteria);
          }, timeout);
        } else {
          // Otherwise, immediately update `localFilter` with `newFilter` value
          this.localFilter = this.filterSanitize(newCriteria);
        }
      }
    },
    // Watch for changes to the filter criteria and filtered items vs `localItems`
    // Set visual state and emit events as required
    filteredCheck: function filteredCheck(_ref) {
      var filteredItems = _ref.filteredItems,
          localFilter = _ref.localFilter;
      // Determine if the dataset is filtered or not
      var isFiltered = false;

      if (!localFilter) {
        // If filter criteria is falsey
        isFiltered = false;
      } else if (loose_equal(localFilter, []) || loose_equal(localFilter, {})) {
        // If filter criteria is an empty array or object
        isFiltered = false;
      } else if (localFilter) {
        // If filter criteria is truthy
        isFiltered = true;
      }

      if (isFiltered) {
        this.$emit("filtered", filteredItems, filteredItems.length);
      }

      this.isFiltered = isFiltered;
    },
    isFiltered: function isFiltered(newVal, oldVal) {
      if (newVal === false && oldVal === true) {
        // We need to emit a filtered event if isFiltered transitions from true to
        // false so that users can update their pagination controls.
        this.$emit("filtered", this.localItems, this.localItems.length);
      }
    }
  },
  created: function created() {
    var _this2 = this;

    // Create non-reactive prop where we store the debounce timer id
    this.$_filterTimer = null; // If filter is "pre-set", set the criteria
    // This will trigger any watchers/dependents
    // this.localFilter = this.filterSanitize(this.filter)
    // Set the initial filtered state in a `$nextTick()` so that
    // we trigger a filtered event if needed

    this.$nextTick(function () {
      _this2.isFiltered = Boolean(_this2.localFilter);
    });
  },
  beforeDestroy: function beforeDestroy()
  /* istanbul ignore next */
  {
    clearTimeout(this.$_filterTimer);
    this.$_filterTimer = null;
  },
  methods: {
    filterSanitize: function filterSanitize(criteria) {
      // Sanitizes filter criteria based on internal or external filtering
      if (this.localFiltering && !this.localFilterFn && !(isString(criteria) || isRegExp(criteria))) {
        // If using internal filter function, which only accepts string or RegExp,
        // return '' to signify no filter
        return "";
      } // Could be a string, object or array, as needed by external filter function
      // We use `cloneDeep` to ensure we have a new copy of an object or array
      // without Vue's reactive observers


      return clone_deep(criteria);
    },
    // Filter Function factories
    filterFnFactory: function filterFnFactory(filterFn, criteria) {
      // Wrapper factory for external filter functions
      // Wrap the provided filter-function and return a new function
      // Returns `null` if no filter-function defined or if criteria is falsey
      // Rather than directly grabbing `this.computedLocalFilterFn` or `this.filterFunction`
      // we have it passed, so that the caller computed prop will be reactive to changes
      // in the original filter-function (as this routine is a method)
      if (!filterFn || !isFunction(filterFn) || !criteria || loose_equal(criteria, []) || loose_equal(criteria, {})) {
        return null;
      } // Build the wrapped filter test function, passing the criteria to the provided function


      var fn = function fn(item) {
        // Generated function returns true if the criteria matches part
        // of the serialized data, otherwise false
        return filterFn(item, criteria);
      }; // Return the wrapped function


      return fn;
    },
    defaultFilterFnFactory: function defaultFilterFnFactory(criteria) {
      var _this3 = this;

      // Generates the default filter function, using the given filter criteria
      // Returns `null` if no criteria or criteria format not supported
      if (!criteria || !(isString(criteria) || isRegExp(criteria))) {
        // Built in filter can only support strings or RegExp criteria (at the moment)
        return null;
      } // Build the RegExp needed for filtering


      var regExp = criteria;

      if (isString(regExp)) {
        // Escape special RegExp characters in the string and convert contiguous
        // whitespace to \s+ matches
        var pattern = escapeRegExp(criteria).replace(RX_SPACES, "\\s+"); // Build the RegExp (no need for global flag, as we only need
        // to find the value once in the string)

        regExp = new RegExp(".*".concat(pattern, ".*"), "i");
      } // Generate the wrapped filter test function to use


      var fn = function fn(item) {
        // This searches all row values (and sub property values) in the entire (excluding
        // special `_` prefixed keys), because we convert the record to a space-separated
        // string containing all the value properties (recursively), even ones that are
        // not visible (not specified in this.fields)
        // Users can ignore filtering on specific fields, or on only certain fields,
        // and can optionall specify searching results of fields with formatter
        //
        // TODO: Enable searching on scoped slots (optional, as it will be SLOW)
        //
        // Generated function returns true if the criteria matches part of
        // the serialized data, otherwise false
        //
        // We set `lastIndex = 0` on the `RegExp` in case someone specifies the `/g` global flag
        regExp.lastIndex = 0;
        return regExp.test(stringify_record_values(item, _this3.computedFilterIgnored, _this3.computedFilterIncluded, _this3.computedFieldsObj));
      }; // Return the generated function


      return fn;
    }
  }
});
// CONCATENATED MODULE: ./src/utils/stable-sort.js


var stableSort = function stableSort(array, compareFn) {
  return array.map(function (a, index) {
    return [index, a];
  }).sort(function (a, b) {
    return this(a[1], b[1]) || a[0] - b[0];
  }.bind(compareFn)).map(function (e) {
    return e[1];
  });
};

/* harmony default export */ var stable_sort = (stableSort);
// CONCATENATED MODULE: ./src/components/table/plugin/default-sort-compare.js




var default_sort_compare_defaultSortCompare = function defaultSortCompare(a, b, sortBy, sortDesc, formatter, localeOpts, locale, nullLast) {
  var aa = utils_get(a, sortBy, null);
  var bb = utils_get(b, sortBy, null);

  if (isFunction(formatter)) {
    aa = formatter(aa, sortBy, a);
    bb = formatter(bb, sortBy, b);
  }

  aa = isUndefinedOrNull(aa) ? "" : aa;
  bb = isUndefinedOrNull(bb) ? "" : bb;

  if (isDate(aa) && isDate(bb) || isNumber(aa) && isNumber(bb)) {
    // Special case for comparing dates and numbers
    // Internally dates are compared via their epoch number values
    return aa < bb ? -1 : aa > bb ? 1 : 0;
  } else if (nullLast && aa === "" && bb !== "") {
    // Special case when sorting null/undefined/empty string last
    return 1;
  } else if (nullLast && aa !== "" && bb === "") {
    // Special case when sorting null/undefined/empty string last
    return -1;
  } // Do localized string comparison


  return stringify_object_values(aa).localeCompare(stringify_object_values(bb), locale, localeOpts);
};

/* harmony default export */ var default_sort_compare = (default_sort_compare_defaultSortCompare);
// CONCATENATED MODULE: ./src/components/table/plugin/mixin-sorting.js








/* harmony default export */ var mixin_sorting = ({
  props: {
    sortBy: {
      type: String,
      default: ""
    },
    sortDesc: {
      // TODO: Make this tri-state: true, false, null
      type: Boolean,
      default: false
    },
    sortDirection: {
      // This prop is named incorrectly
      // It should be `initialSortDirection` as it is a bit misleading
      // (not to mention it screws up the ARIA label on the headers)
      type: String,
      default: "asc",
      validator: function validator(direction) {
        return arrayIncludes(["asc", "desc", "last"], direction);
      }
    },
    sortCompare: {
      type: Function,
      default: null
    },
    sortCompareOptions: {
      // Supported localCompare options, see `options` section of:
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare
      type: Object,
      default: function _default() {
        return {
          numeric: true
        };
      }
    },
    sortCompareLocale: {
      // String: locale code
      // Array: array of Locale strings
      type: [String, Array] // default: undefined

    },
    sortNullLast: {
      // Sort null and undefined to appear last
      type: Boolean,
      default: false
    },
    noSortReset: {
      // Another prop that should have had a better name.
      // It should be noSortClear (on non-sortable headers).
      // We will need to make sure the documentation is clear on what
      // this prop does (as well as in the code for future reference)
      type: Boolean,
      default: false
    },
    labelSortAsc: {
      type: String,
      default: "Click to sort Ascending"
    },
    labelSortDesc: {
      type: String,
      default: "Click to sort Descending"
    },
    labelSortClear: {
      type: String,
      default: "Click to clear sorting"
    },
    noLocalSorting: {
      type: Boolean,
      default: false
    },
    noFooterSorting: {
      type: Boolean,
      default: false
    },
    sortIconLeft: {
      // Place the sorting icon on the left of the header cells
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      localSortBy: this.sortBy || "",
      localSortDesc: this.sortDesc || false
    };
  },
  computed: {
    localSorting: function localSorting() {
      return this.hasProvider ? !!this.noProviderSorting : !this.noLocalSorting;
    },
    isSortable: function isSortable() {
      return this.computedFields.some(function (f) {
        return f.sortable;
      });
    },
    sortedItems: function sortedItems() {
      // Sorts the filtered items and returns a new array of the sorted items
      // or the original items array if not sorted.
      var items = (this.filteredItems || this.localItems || []).slice();
      var sortBy = this.localSortBy;
      var sortDesc = this.localSortDesc;
      var sortCompare = this.sortCompare;
      var localSorting = this.localSorting;

      var sortOptions = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.sortCompareOptions), {}, {
        usage: "sort"
      });

      var sortLocale = this.sortCompareLocale || undefined;
      var nullLast = this.sortNullLast;

      if (sortBy && localSorting) {
        var field = this.computedFieldsObj[sortBy] || {};
        var sortByFormatted = field.sortByFormatted;
        var formatter = isFunction(sortByFormatted) ? sortByFormatted : sortByFormatted ? this.getFieldFormatter(sortBy) : undefined; // `stableSort` returns a new array, and leaves the original array intact

        return stable_sort(items, function (a, b) {
          var result = null;

          if (isFunction(sortCompare)) {
            // Call user provided sortCompare routine
            result = sortCompare(a, b, sortBy, sortDesc, formatter, sortOptions, sortLocale);
          }

          if (isUndefinedOrNull(result) || result === false) {
            // Fallback to built-in defaultSortCompare if sortCompare
            // is not defined or returns null/false
            result = default_sort_compare(a, b, sortBy, sortDesc, formatter, sortOptions, sortLocale, nullLast);
          } // Negate result if sorting in descending order


          return (result || 0) * (sortDesc ? -1 : 1);
        });
      }

      return items;
    }
  },
  watch: {
    isSortable: function isSortable(newVal)
    /* istanbul ignore next: pain in the butt to test */
    {
      if (newVal) {
        if (this.isSortable) {
          this.$on("head-clicked", this.handleSort);
        }
      } else {
        this.$off("head-clicked", this.handleSort);
      }
    },
    sortDesc: function sortDesc(newVal) {
      if (newVal === this.localSortDesc) {
        /* istanbul ignore next */
        return;
      }

      this.localSortDesc = newVal || false;
    },
    sortBy: function sortBy(newVal) {
      if (newVal === this.localSortBy) {
        /* istanbul ignore next */
        return;
      }

      this.localSortBy = newVal || "";
    },
    // Update .sync props
    localSortDesc: function localSortDesc(newVal, oldVal) {
      // Emit update to sort-desc.sync
      if (newVal !== oldVal) {
        this.$emit("update:sortDesc", newVal);
      }
    },
    localSortBy: function localSortBy(newVal, oldVal) {
      if (newVal !== oldVal) {
        this.$emit("update:sortBy", newVal);
      }
    }
  },
  created: function created() {
    if (this.isSortable) {
      this.$on("head-clicked", this.handleSort);
    }
  },
  methods: {
    // Handlers
    // Need to move from thead-mixin
    handleSort: function handleSort(key, field, evt, isFoot) {
      var _this = this;

      if (!this.isSortable) {
        /* istanbul ignore next */
        return;
      }

      if (isFoot && this.noFooterSorting) {
        return;
      } // TODO: make this tri-state sorting
      // cycle desc => asc => none => desc => ...


      var sortChanged = false;

      var toggleLocalSortDesc = function toggleLocalSortDesc() {
        var sortDirection = field.sortDirection || _this.sortDirection;

        if (sortDirection === "asc") {
          _this.localSortDesc = false;
        } else if (sortDirection === "desc") {
          _this.localSortDesc = true;
        } else {// sortDirection === 'last'
          // Leave at last sort direction from previous column
        }
      };

      if (field.sortable) {
        if (key === this.localSortBy) {
          // Change sorting direction on current column
          this.localSortDesc = !this.localSortDesc;
        } else {
          // Start sorting this column ascending
          this.localSortBy = key; // this.localSortDesc = false

          toggleLocalSortDesc();
        }

        sortChanged = true;
      } else if (this.localSortBy && !this.noSortReset) {
        this.localSortBy = "";
        toggleLocalSortDesc();
        sortChanged = true;
      }

      if (sortChanged) {
        // Sorting parameters changed
        this.$emit("sort-changed", this.context);
      }
    },
    // methods to compute classes and attrs for thead>th cells
    sortTheadThClasses: function sortTheadThClasses(key, field, isFoot) {
      return {
        // If sortable and sortIconLeft are true, then place sort icon on the left
        "nly-table-sort-icon-left": field.sortable && this.sortIconLeft && !(isFoot && this.noFooterSorting)
      };
    },
    sortTheadThAttrs: function sortTheadThAttrs(key, field, isFoot) {
      if (!this.isSortable || isFoot && this.noFooterSorting) {
        // No attributes if not a sortable table
        return {};
      }

      var sortable = field.sortable; // Assemble the aria-sort attribute value

      var ariaSort = sortable && this.localSortBy === key ? this.localSortDesc ? "descending" : "ascending" : sortable ? "none" : null; // Return the attribute

      return {
        "aria-sort": ariaSort
      };
    },
    sortTheadThLabel: function sortTheadThLabel(key, field, isFoot) {
      // A label to be placed in an `.sr-only` element in the header cell
      if (!this.isSortable || isFoot && this.noFooterSorting) {
        // No label if not a sortable table
        return null;
      }

      var sortable = field.sortable; // The correctness of these labels is very important for screen-reader users.

      var labelSorting = "";

      if (sortable) {
        if (this.localSortBy === key) {
          // currently sorted sortable column.
          labelSorting = this.localSortDesc ? this.labelSortAsc : this.labelSortDesc;
        } else {
          // Not currently sorted sortable column.
          // Not using nested ternary's here for clarity/readability
          // Default for ariaLabel
          labelSorting = this.localSortDesc ? this.labelSortDesc : this.labelSortAsc; // Handle sortDirection setting

          var sortDirection = this.sortDirection || field.sortDirection;

          if (sortDirection === "asc") {
            labelSorting = this.labelSortAsc;
          } else if (sortDirection === "desc") {
            labelSorting = this.labelSortDesc;
          }
        }
      } else if (!this.noSortReset) {
        // Non sortable column
        labelSorting = this.localSortBy ? this.labelSortClear : "";
      } // Return the sr-only sort label or null if no label


      return trim(labelSorting) || null;
    }
  }
});
// CONCATENATED MODULE: ./src/components/table/plugin/mixin-pagination.js


/* harmony default export */ var mixin_pagination = ({
  props: {
    perPage: {
      type: [Number, String],
      default: 0
    },
    currentPage: {
      type: [Number, String],
      default: 1
    }
  },
  computed: {
    localPaging: function localPaging() {
      return this.hasProvider ? !!this.noProviderPaging : true;
    },
    paginatedItems: function paginatedItems() {
      var items = this.sortedItems || this.filteredItems || this.localItems || [];
      var currentPage = Math.max(parseInt(this.currentPage, 10) || 1, 1);
      var perPage = Math.max(parseInt(this.perPage, 10) || 0, 0); // Apply local pagination

      if (this.localPaging && !!perPage) {
        // Grab the current page of data (which may be past filtered items limit)
        items = items.slice((currentPage - 1) * perPage, currentPage * perPage);
      } // Return the items to display in the table


      return items;
    }
  }
});
// CONCATENATED MODULE: ./src/components/table/plugin/mixin-caption.js

/* harmony default export */ var mixin_caption = ({
  props: {
    // `caption-top` is part of table-redere mixin (styling)
    // captionTop: {
    //   type: Boolean,
    //   default: false
    // },
    caption: {
      type: String,
      default: null
    },
    captionHtml: {
      type: String
    }
  },
  computed: {
    captionId: function captionId() {
      // Even though `this.safeId` looks like a method, it is a computed prop
      // that returns a new function if the underlying ID changes
      return this.isStacked ? this.safeId("_caption_") : null;
    }
  },
  methods: {
    renderCaption: function renderCaption() {
      var h = this.$createElement; // Build the caption

      var $captionSlot = this.normalizeSlot("table-caption");
      var $caption = h();

      if ($captionSlot || this.caption || this.captionHtml) {
        var data = {
          key: "caption",
          attrs: {
            id: this.captionId
          }
        };

        if (!$captionSlot) {
          data.domProps = htmlOrText(this.captionHtml, this.caption);
        }

        $caption = h("caption", data, [$captionSlot]);
      }

      return $caption;
    }
  }
});
// CONCATENATED MODULE: ./src/components/table/plugin/mixin-colgroup.js
/* harmony default export */ var mixin_colgroup = ({
  methods: {
    renderColgroup: function renderColgroup() {
      var h = this.$createElement;
      var fields = this.computedFields;
      var $colgroup = h();

      if (this.hasNormalizedSlot("table-colgroup")) {
        $colgroup = h("colgroup", {
          key: "colgroup"
        }, [this.normalizeSlot("table-colgroup", {
          columns: fields.length,
          fields: fields
        })]);
      }

      return $colgroup;
    }
  }
});
// CONCATENATED MODULE: ./src/components/table/plugin/filter-event.js



var TABLE_TAG_NAMES = ["TD", "TH", "TR"]; // Returns `true` if we should ignore the click/double-click/keypress event
// Avoids having the user need to use `@click.stop` on the form control

var filter_event_filterEvent = function filterEvent(evt) {
  // Exit early when we don't have a target element
  if (!evt || !evt.target) {
    /* istanbul ignore next */
    return false;
  }

  var el = evt.target; // Exit early when element is disabled or a table element

  if (el.disabled || TABLE_TAG_NAMES.indexOf(el.tagName) !== -1) {
    return false;
  } // Ignore the click when it was inside a dropdown menu


  if (closest(".dropdown-menu", el)) {
    return true;
  }

  var label = el.tagName === "LABEL" ? el : closest("label", el); // If the label's form control is not disabled then we don't propagate event
  // Modern browsers have `label.control` that references the associated input, but IE 11
  // does not have this property on the label element, so we resort to DOM lookups

  if (label) {
    var labelFor = getAttr(label, "for");
    var input = labelFor ? getById(labelFor) : dom_select("input, select, textarea", label);

    if (input && !input.disabled) {
      return true;
    }
  } // Otherwise check if the event target matches one of the selectors in the
  // event filter (i.e. anchors, non disabled inputs, etc.)
  // Return `true` if we should ignore the event


  return matches(el, EVENT_FILTER);
};

/* harmony default export */ var filter_event = (filter_event_filterEvent);
// CONCATENATED MODULE: ./src/components/table/plugin/text-selection-active.js



 // Helper to determine if a there is an active text selection on the document page
// Used to filter out click events caused by the mouse up at end of selection
//
// Accepts an element as only argument to test to see if selection overlaps or is
// contained within the element

var text_selection_active_textSelectionActive = function textSelectionActive() {
  var el = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
  var sel = dom_getSel();
  return sel && sel.toString().trim() !== "" && sel.containsNode && isElement(el) ? sel.containsNode(el, true) : false;
};

/* harmony default export */ var text_selection_active = (text_selection_active_textSelectionActive);
// CONCATENATED MODULE: ./src/components/table/thead.js



var thead_props = {
  headVariant: {
    // Also sniffed by <nly-tr> / <nly-td> / <nly-th>
    type: String,
    // supported values: 'lite', 'dark', or null
    default: null
  }
};
var thead_name = "NlyThead";
var NlyThead = utils_vue.extend({
  name: thead_name,
  mixins: [mixins_normalize_slot],
  inheritAttrs: false,
  provide: function provide() {
    return {
      nlyaTableRowGroup: this
    };
  },
  inject: {
    nlyaTable: {
      // Sniffed by <nly-tr> / <nly-td> / <nly-th>
      default: function _default()
      /* istanbul ignore next */
      {
        return {};
      }
    }
  },
  props: thead_props,
  computed: {
    isThead: function isThead() {
      return true;
    },
    isDark: function isDark() {
      return this.nlyaTable.dark;
    },
    isStacked: function isStacked() {
      return this.nlyaTable.isStacked;
    },
    isResponsive: function isResponsive() {
      return this.nlyaTable.isResponsive;
    },
    isStickyHeader: function isStickyHeader() {
      // Needed to handle header background classes, due to lack of
      // background color inheritance with Bootstrap v4 table CSS
      // Sticky headers only apply to cells in table `thead`
      return !this.isStacked && this.nlyaTable.stickyHeader;
    },
    hasStickyHeader: function hasStickyHeader() {
      // Sniffed by <nly-tr> / <nly-td> / <nly-th>
      // Needed to handle header background classes, due to lack of
      // background color inheritance with Bootstrap v4 table CSS
      return !this.isStacked && this.nlyaTable.stickyHeader;
    },
    tableVariant: function tableVariant() {
      // Sniffed by <nly-tr> / <nly-td> / <nly-th>
      return this.nlyaTable.tableVariant;
    },
    theadClasses: function theadClasses() {
      return [this.headVariant ? "thead-".concat(this.headVariant) : null];
    },
    theadAttrs: function theadAttrs() {
      return Object(objectSpread2["a" /* default */])({
        role: "rowgroup"
      }, this.$attrs);
    }
  },
  render: function render(h) {
    return h("thead", {
      class: this.theadClasses,
      attrs: this.theadAttrs,
      // Pass down any native listeners
      on: this.$listeners
    }, this.normalizeSlot("default"));
  }
});
// CONCATENATED MODULE: ./src/components/table/tfoot.js



var tfoot_props = {
  footVariant: {
    type: String,
    // supported values: 'lite', 'dark', or null
    default: null
  }
};
var tfoot_name = "NlyTfoot"; // @vue/component

var NlyTfoot = utils_vue.extend({
  name: tfoot_name,
  mixins: [mixins_normalize_slot],
  inheritAttrs: false,
  provide: function provide() {
    return {
      nlyaTableRowGroup: this
    };
  },
  inject: {
    nlyaTable: {
      // Sniffed by <nly-tr> / <nly-td> / <nly-th>
      default: function _default()
      /* istanbul ignore next */
      {
        return {};
      }
    }
  },
  props: tfoot_props,
  computed: {
    isTfoot: function isTfoot() {
      // Sniffed by <nly-tr> / <nly-td> / <nly-th>
      return true;
    },
    isDark: function isDark()
    /* istanbul ignore next: Not currently sniffed in tests */
    {
      // Sniffed by <nly-tr> / <nly-td> / <nly-th>
      return this.nlyaTable.dark;
    },
    isStacked: function isStacked() {
      // Sniffed by <nly-tr> / <nly-td> / <nly-th>
      return this.nlyaTable.isStacked;
    },
    isResponsive: function isResponsive() {
      // Sniffed by <nly-tr> / <nly-td> / <nly-th>
      return this.nlyaTable.isResponsive;
    },
    isStickyHeader: function isStickyHeader() {
      // Sniffed by <nly-tr> / <nly-td> / <nly-th>
      // Sticky headers are only supported in thead
      return false;
    },
    hasStickyHeader: function hasStickyHeader() {
      // Sniffed by <nly-tr> / <nly-td> / <nly-th>
      // Needed to handle header background classes, due to lack of
      // background color inheritance with Bootstrap v4 table CSS
      return !this.isStacked && this.nlyaTable.stickyHeader;
    },
    tableVariant: function tableVariant()
    /* istanbul ignore next: Not currently sniffed in tests */
    {
      // Sniffed by <nly-tr> / <nly-td> / <nly-th>
      return this.nlyaTable.tableVariant;
    },
    tfootClasses: function tfootClasses() {
      return [this.footVariant ? "thead-".concat(this.footVariant) : null];
    },
    tfootAttrs: function tfootAttrs() {
      return Object(objectSpread2["a" /* default */])({
        role: "rowgroup"
      }, this.$attrs);
    }
  },
  render: function render(h) {
    return h("tfoot", {
      class: this.tfootClasses,
      attrs: this.tfootAttrs,
      // Pass down any native listeners
      on: this.$listeners
    }, this.normalizeSlot("default"));
  }
});
// CONCATENATED MODULE: ./src/components/table/tr.js




var tr_props = {
  variant: {
    type: String,
    default: null
  }
};
var LIGHT = "light";
var DARK = "dark";
var tr_name = "NlyTr";
var NlyTr = utils_vue.extend({
  name: tr_name,
  mixins: [mixins_normalize_slot],
  inheritAttrs: false,
  provide: function provide() {
    return {
      nlyaTableTr: this
    };
  },
  inject: {
    nlyaTableRowGroup: {
      default: function _default()
      /* istanbul ignore next */
      {
        return {};
      }
    }
  },
  props: tr_props,
  computed: {
    inTbody: function inTbody() {
      // Sniffed by <nly-td> / <nly-th>
      return this.nlyaTableRowGroup.isTbody;
    },
    inThead: function inThead() {
      // Sniffed by <nly-td> / <nly-th>
      return this.nlyaTableRowGroup.isThead;
    },
    inTfoot: function inTfoot() {
      // Sniffed by <nly-td> / <nly-th>
      return this.nlyaTableRowGroup.isTfoot;
    },
    isDark: function isDark() {
      // Sniffed by <nly-td> / <nly-th>
      return this.nlyaTableRowGroup.isDark;
    },
    isStacked: function isStacked() {
      return this.nlyaTableRowGroup.isStacked;
    },
    isResponsive: function isResponsive() {
      // Sniffed by <nly-td> / <nly-th>
      return this.nlyaTableRowGroup.isResponsive;
    },
    isStickyHeader: function isStickyHeader() {
      return this.nlyaTableRowGroup.isStickyHeader;
    },
    hasStickyHeader: function hasStickyHeader() {
      return !this.isStacked && this.nlyaTableRowGroup.hasStickyHeader;
    },
    tableVariant: function tableVariant() {
      // Sniffed by <nly-td> / <nly-th>
      return this.nlyaTableRowGroup.tableVariant;
    },
    headVariant: function headVariant() {
      // Sniffed by <nly-td> / <nly-th>
      return this.inThead ? this.nlyaTableRowGroup.headVariant : null;
    },
    footVariant: function footVariant() {
      // Sniffed by <nly-td> / <nly-th>
      return this.inTfoot ? this.nlyaTableRowGroup.footVariant : null;
    },
    isRowDark: function isRowDark() {
      return this.headVariant === LIGHT || this.footVariant === LIGHT ? false : this.headVariant === DARK || this.footVariant === DARK ? true : this.isDark;
    },
    trClasses: function trClasses() {
      return [this.variant ? "".concat(this.isRowDark ? "bg" : "table", "-").concat(this.variant) : null];
    },
    trAttrs: function trAttrs() {
      return Object(objectSpread2["a" /* default */])({
        role: "row"
      }, this.$attrs);
    }
  },
  render: function render(h) {
    return h("tr", {
      class: this.trClasses,
      attrs: this.trAttrs,
      // Pass native listeners to child
      on: this.$listeners
    }, this.normalizeSlot("default"));
  }
});
// CONCATENATED MODULE: ./src/components/table/td.js







var digitsRx = /^\d+$/;

var parseSpan = function parseSpan(val) {
  val = parseInt(val, 10);
  return digitsRx.test(String(val)) && val > 0 ? val : null;
};

var td_spanValidator = function spanValidator(val) {
  return isUndefinedOrNull(val) || parseSpan(val) > 0;
};

var td_props = {
  variant: {
    type: String,
    default: null
  },
  colspan: {
    type: [Number, String],
    default: null,
    validator: td_spanValidator
  },
  rowspan: {
    type: [Number, String],
    default: null,
    validator: td_spanValidator
  },
  stackedHeading: {
    type: String,
    default: null
  },
  stickyColumn: {
    type: Boolean,
    default: false
  }
};
var td_name = "NlyTabelCell";
var NlyTd = utils_vue.extend({
  name: td_name,
  mixins: [mixins_normalize_slot],
  inheritAttrs: false,
  inject: {
    nlyaTableTr: {
      default: function _default() {
        return {};
      }
    }
  },
  props: td_props,
  computed: {
    tag: function tag() {
      return "td";
    },
    inTbody: function inTbody() {
      return this.nlyaTableTr.inTbody;
    },
    inThead: function inThead() {
      return this.nlyaTableTr.inThead;
    },
    inTfoot: function inTfoot() {
      return this.nlyaTableTr.inTfoot;
    },
    isDark: function isDark() {
      return this.nlyaTableTr.isDark;
    },
    isStacked: function isStacked() {
      return this.nlyaTableTr.isStacked;
    },
    isStackedCell: function isStackedCell() {
      // We only support stacked-heading in tbody in stacked mode
      return this.inTbody && this.isStacked;
    },
    isResponsive: function isResponsive() {
      return this.nlyaTableTr.isResponsive;
    },
    isStickyHeader: function isStickyHeader() {
      return this.nlyaTableTr.isStickyHeader;
    },
    hasStickyHeader: function hasStickyHeader() {
      return this.nlyaTableTr.hasStickyHeader;
    },
    isStickyColumn: function isStickyColumn() {
      return !this.isStacked && (this.isResponsive || this.hasStickyHeader) && this.stickyColumn;
    },
    rowVariant: function rowVariant() {
      return this.nlyaTableTr.variant;
    },
    headVariant: function headVariant() {
      return this.nlyaTableTr.headVariant;
    },
    footVariant: function footVariant() {
      return this.nlyaTableTr.footVariant;
    },
    tableVariant: function tableVariant() {
      return this.nlyaTableTr.tableVariant;
    },
    computedColspan: function computedColspan() {
      return parseSpan(this.colspan);
    },
    computedRowspan: function computedRowspan() {
      return parseSpan(this.rowspan);
    },
    cellClasses: function cellClasses() {
      var variant = this.variant;

      if (!variant && this.isStickyHeader && !this.headVariant || !variant && this.isStickyColumn) {
        variant = this.rowVariant || this.tableVariant || "nly-table-default";
      }

      return [variant ? "".concat(this.isDark ? "bg" : "table", "-").concat(variant) : null, this.isStickyColumn ? "nly-table-sticky-column" : null];
    },
    cellAttrs: function cellAttrs() {
      var headOrFoot = this.inThead || this.inTfoot;
      var colspan = this.computedColspan;
      var rowspan = this.computedRowspan;
      var role = "cell";
      var scope = null;

      if (headOrFoot) {
        role = "columnheader";
        scope = colspan > 0 ? "colspan" : "col";
      } else if (this.tag === "th") {
        role = "rowheader";
        scope = rowspan > 0 ? "rowgroup" : "row";
      }

      return Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({
        colspan: colspan,
        rowspan: rowspan,
        role: role,
        scope: scope
      }, this.$attrs), {}, {
        "data-label": this.isStackedCell && !isUndefinedOrNull(this.stackedHeading) ? string_toString(this.stackedHeading) : null
      });
    }
  },
  render: function render(h) {
    var content = [this.normalizeSlot("default")];
    return h(this.tag, {
      class: this.cellClasses,
      attrs: this.cellAttrs,
      on: this.$listeners
    }, [this.isStackedCell ? h("div", [content]) : content]);
  }
});
// CONCATENATED MODULE: ./src/components/table/th.js


var th_name = "NlyTh";
var NlyTh = utils_vue.extend({
  name: th_name,
  extends: NlyTd,
  computed: {
    tag: function tag() {
      return "th";
    }
  }
});
// CONCATENATED MODULE: ./src/components/table/plugin/mixin-thead.js


















/* harmony default export */ var mixin_thead = ({
  props: {
    headVariant: {
      type: String,
      // 'light', 'dark' or `null` (or custom)
      default: function _default() {
        return getComponentConfig("NlyTable", "headVariant");
      }
    },
    headRowVariant: {
      type: String,
      // Any Bootstrap theme variant (or custom)
      default: null
    },
    theadClass: {
      type: [String, Array, Object] // default: undefined

    },
    theadTrClass: {
      type: [String, Array, Object] // default: undefined

    }
  },
  methods: {
    fieldClasses: function fieldClasses(field) {
      // Header field (<th>) classes
      return [field.class ? field.class : "", field.thClass ? field.thClass : ""];
    },
    headClicked: function headClicked(evt, field, isFoot) {
      if (this.stopIfBusy && this.stopIfBusy(evt)) {
        // If table is busy (via provider) then don't propagate
        return;
      } else if (filter_event(evt)) {
        // Clicked on a non-disabled control so ignore
        return;
      } else if (text_selection_active(this.$el)) {
        // User is selecting text, so ignore

        /* istanbul ignore next: JSDOM doesn't support getSelection() */
        return;
      }

      evt.stopPropagation();
      evt.preventDefault();
      this.$emit("head-clicked", field.key, field, evt, isFoot);
    },
    renderThead: function renderThead() {
      var _this = this;

      var isFoot = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var h = this.$createElement;
      var fields = this.computedFields || [];

      if (this.isStackedAlways || fields.length === 0) {
        // In always stacked mode, we don't bother rendering the head/foot
        // Or if no field headings (empty table)
        return h();
      } // Reference to `selectAllRows` and `clearSelected()`, if table is selectable


      var selectAllRows = this.isSelectable ? this.selectAllRows : function () {};
      var clearSelected = this.isSelectable ? this.clearSelected : function () {}; // Helper function to generate a field <th> cell

      var makeCell = function makeCell(field, colIndex) {
        var ariaLabel = null;

        if (!field.label.trim() && !field.headerTitle) {
          // In case field's label and title are empty/blank
          // We need to add a hint about what the column is about for non-sighted users

          /* istanbul ignore next */
          ariaLabel = startcase(field.key);
        }

        var hasHeadClickListener = _this.hasListener("head-clicked") || _this.isSortable;

        var handlers = {};

        if (hasHeadClickListener) {
          handlers.click = function (evt) {
            _this.headClicked(evt, field, isFoot);
          };

          handlers.keydown = function (evt) {
            var keyCode = evt.keyCode;

            if (keyCode === key_codes.ENTER || keyCode === key_codes.SPACE) {
              _this.headClicked(evt, field, isFoot);
            }
          };
        }

        var sortAttrs = _this.isSortable ? _this.sortTheadThAttrs(field.key, field, isFoot) : {};
        var sortClass = _this.isSortable ? _this.sortTheadThClasses(field.key, field, isFoot) : null;
        var sortLabel = _this.isSortable ? _this.sortTheadThLabel(field.key, field, isFoot) : null;
        var data = {
          key: field.key,
          class: [_this.fieldClasses(field), sortClass],
          props: {
            variant: field.variant,
            stickyColumn: field.stickyColumn
          },
          style: field.thStyle || {},
          attrs: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({
            // We only add a tabindex of 0 if there is a head-clicked listener
            tabindex: hasHeadClickListener ? "0" : null,
            abbr: field.headerAbbr || null,
            title: field.headerTitle || null,
            "aria-colindex": colIndex + 1,
            "aria-label": ariaLabel
          }, _this.getThValues(null, field.key, field.thAttr, isFoot ? "foot" : "head", {})), sortAttrs),
          on: handlers
        }; // Handle edge case where in-document templates are used with new
        // `v-slot:name` syntax where the browser lower-cases the v-slot's
        // name (attributes become lower cased when parsed by the browser)
        // We have replaced the square bracket syntax with round brackets
        // to prevent confusion with dynamic slot names

        var slotNames = ["head(".concat(field.key, ")"), "head(".concat(field.key.toLowerCase(), ")"), "head()"];

        if (isFoot) {
          // Footer will fallback to header slot names
          slotNames = ["foot(".concat(field.key, ")"), "foot(".concat(field.key.toLowerCase(), ")"), "foot()"].concat(_toConsumableArray(slotNames));
        }

        var scope = {
          label: field.label,
          column: field.key,
          field: field,
          isFoot: isFoot,
          // Add in row select methods
          selectAllRows: selectAllRows,
          clearSelected: clearSelected
        };
        var content = _this.normalizeSlot(slotNames, scope) || (field.labelHtml ? h("div", {
          domProps: htmlOrText(field.labelHtml)
        }) : field.label);
        var srLabel = sortLabel ? h("span", {
          staticClass: "sr-only"
        }, " (".concat(sortLabel, ")")) : null; // Return the header cell

        return h(NlyTh, data, [content, srLabel].filter(utils_identity));
      }; // Generate the array of <th> cells


      var $cells = fields.map(makeCell).filter(utils_identity); // Genrate the row(s)

      var $trs = [];

      if (isFoot) {
        var trProps = {
          variant: isUndefinedOrNull(this.footRowVariant) ? this.headRowVariant : this.footRowVariant
        };
        $trs.push(h(NlyTr, {
          class: this.tfootTrClass,
          props: trProps
        }, $cells));
      } else {
        var scope = {
          columns: fields.length,
          fields: fields,
          // Add in row select methods
          selectAllRows: selectAllRows,
          clearSelected: clearSelected
        };
        $trs.push(this.normalizeSlot("thead-top", scope) || h());
        $trs.push(h(NlyTr, {
          class: this.theadTrClass,
          props: {
            variant: this.headRowVariant
          }
        }, $cells));
      }

      return h(isFoot ? NlyTfoot : NlyThead, {
        key: isFoot ? "nly-tfoot" : "nly-thead",
        class: (isFoot ? this.tfootClass : this.theadClass) || null,
        props: isFoot ? {
          footVariant: this.footVariant || this.headVariant || null
        } : {
          headVariant: this.headVariant || null
        }
      }, $trs);
    }
  }
});
// CONCATENATED MODULE: ./src/components/table/plugin/mixin-tfoot.js



/* harmony default export */ var mixin_tfoot = ({
  props: {
    footClone: {
      type: Boolean,
      default: false
    },
    footVariant: {
      type: String,
      // 'dark', 'light', or `null` (or custom)
      default: function _default() {
        return getComponentConfig("NlyTable", "footVariant");
      }
    },
    footRowVariant: {
      type: String,
      // Any Bootstrap theme variant (or custom). Falls back to `headRowVariant`
      default: null
    },
    tfootClass: {
      type: [String, Array, Object],
      default: null
    },
    tfootTrClass: {
      type: [String, Array, Object],
      default: null
    }
  },
  methods: {
    renderTFootCustom: function renderTFootCustom() {
      var h = this.$createElement;

      if (this.hasNormalizedSlot("custom-foot")) {
        return h(NlyTfoot, {
          key: "nly-tfoot-custom",
          class: this.tfootClass || null,
          props: {
            footVariant: this.footVariant || this.headVariant || null
          }
        }, this.normalizeSlot("custom-foot", {
          items: this.computedItems.slice(),
          fields: this.computedFields.slice(),
          columns: this.computedFields.length
        }));
      } else {
        return h();
      }
    },
    renderTfoot: function renderTfoot() {
      // Passing true to renderThead will make it render a tfoot
      return this.footClone ? this.renderThead(true) : this.renderTFootCustom();
    }
  }
});
// CONCATENATED MODULE: ./src/components/table/tbody.js



var tbody_props = {
  tbodyTransitionProps: {
    type: Object // default: undefined

  },
  tbodyTransitionHandlers: {
    type: Object // default: undefined

  }
};
var tbody_name = "NlyTbody";
var NlyTbody = utils_vue.extend({
  name: tbody_name,
  mixins: [mixins_normalize_slot],
  inheritAttrs: false,
  provide: function provide() {
    return {
      nlyaTableRowGroup: this
    };
  },
  inject: {
    nlyaTable: {
      default: function _default()
      /* istanbul ignore next */
      {
        return {};
      }
    }
  },
  props: tbody_props,
  computed: {
    isTbody: function isTbody() {
      return true;
    },
    isDark: function isDark() {
      return this.nlyaTable.dark;
    },
    isStacked: function isStacked() {
      return this.nlyaTable.isStacked;
    },
    isResponsive: function isResponsive() {
      return this.nlyaTable.isResponsive;
    },
    isStickyHeader: function isStickyHeader() {
      // Sticky headers are only supported in thead
      return false;
    },
    hasStickyHeader: function hasStickyHeader() {
      // Needed to handle header background classes, due to lack of
      // background color inheritance with Bootstrap v4 table CSS
      return !this.isStacked && this.nlyaTable.stickyHeader;
    },
    tableVariant: function tableVariant()
    /* istanbul ignore next: Not currently sniffed in tests */
    {
      return this.nlyaTable.tableVariant;
    },
    isTransitionGroup: function isTransitionGroup() {
      return this.tbodyTransitionProps || this.tbodyTransitionHandlers;
    },
    tbodyAttrs: function tbodyAttrs() {
      return Object(objectSpread2["a" /* default */])({
        role: "rowgroup"
      }, this.$attrs);
    },
    tbodyProps: function tbodyProps() {
      return this.tbodyTransitionProps ? Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.tbodyTransitionProps), {}, {
        tag: "tbody"
      }) : {};
    }
  },
  render: function render(h) {
    var data = {
      props: this.tbodyProps,
      attrs: this.tbodyAttrs
    };

    if (this.isTransitionGroup) {
      // We use native listeners if a transition group
      // for any delegated events
      data.on = this.tbodyTransitionHandlers || {};
      data.nativeOn = this.$listeners || {};
    } else {
      // Otherwise we place any listeners on the tbody element
      data.on = this.$listeners || {};
    }

    return h(this.isTransitionGroup ? "transition-group" : "tbody", data, this.normalizeSlot("default"));
  }
});
// CONCATENATED MODULE: ./src/components/table/plugin/mixin-tbody-row.js









var detailsSlotName = "row-details";
/* harmony default export */ var mixin_tbody_row = ({
  props: {
    tbodyTrClass: {
      type: [String, Array, Object, Function],
      default: null
    },
    tbodyTrAttr: {
      type: [Object, Function],
      default: null
    },
    detailsTdClass: {
      type: [String, Array, Object],
      default: null
    }
  },
  methods: {
    // Methods for computing classes, attributes and styles for table cells
    getTdValues: function getTdValues(item, key, tdValue, defValue) {
      var parent = this.$parent;

      if (tdValue) {
        var value = utils_get(item, key, "");

        if (isFunction(tdValue)) {
          return tdValue(value, key, item);
        } else if (isString(tdValue) && isFunction(parent[tdValue])) {
          return parent[tdValue](value, key, item);
        }

        return tdValue;
      }

      return defValue;
    },
    getThValues: function getThValues(item, key, thValue, type, defValue) {
      var parent = this.$parent;

      if (thValue) {
        var value = utils_get(item, key, "");

        if (isFunction(thValue)) {
          return thValue(value, key, item, type);
        } else if (isString(thValue) && isFunction(parent[thValue])) {
          return parent[thValue](value, key, item, type);
        }

        return thValue;
      }

      return defValue;
    },
    // Method to get the value for a field
    getFormattedValue: function getFormattedValue(item, field) {
      var key = field.key;
      var formatter = this.getFieldFormatter(key);
      var value = utils_get(item, key, null);

      if (isFunction(formatter)) {
        value = formatter(value, key, item);
      }

      return isUndefinedOrNull(value) ? "" : value;
    },
    // Factory function methods
    toggleDetailsFactory: function toggleDetailsFactory(hasDetailsSlot, item) {
      var _this = this;

      // Returns a function to toggle a row's details slot
      return function () {
        if (hasDetailsSlot) {
          _this.$set(item, "_showDetails", !item._showDetails);
        }
      };
    },
    // Row event handlers
    rowHovered: function rowHovered(evt) {
      // `mouseenter` handler (non-bubbling)
      // `this.tbodyRowEvtStopped` from tbody mixin
      if (!this.tbodyRowEvtStopped(evt)) {
        // `this.emitTbodyRowEvent` from tbody mixin
        this.emitTbodyRowEvent("row-hovered", evt);
      }
    },
    rowUnhovered: function rowUnhovered(evt) {
      // `mouseleave` handler (non-bubbling)
      // `this.tbodyRowEvtStopped` from tbody mixin
      if (!this.tbodyRowEvtStopped(evt)) {
        // `this.emitTbodyRowEvent` from tbody mixin
        this.emitTbodyRowEvent("row-unhovered", evt);
      }
    },
    // Render helpers
    renderTbodyRowCell: function renderTbodyRowCell(field, colIndex, item, rowIndex) {
      var _this2 = this;

      // Renders a TD or TH for a row's field
      var h = this.$createElement;
      var hasDetailsSlot = this.hasNormalizedSlot(detailsSlotName);
      var formatted = this.getFormattedValue(item, field);
      var key = field.key;
      var stickyColumn = !this.isStacked && (this.isResponsive || this.stickyHeader) && field.stickyColumn; // We only uses the helper components for sticky columns to
      // improve performance of BTable/BTableLite by reducing the
      // total number of vue instances created during render

      var cellTag = stickyColumn ? field.isRowHeader ? NlyTh : NlyTd : field.isRowHeader ? "th" : "td";
      var cellVariant = item._cellVariants && item._cellVariants[key] ? item._cellVariants[key] : field.variant || null;
      var data = {
        // For the Vue key, we concatenate the column index and
        // field key (as field keys could be duplicated)
        // TODO: Although we do prevent duplicate field keys...
        //   So we could change this to: `row-${rowIndex}-cell-${key}`
        key: "row-".concat(rowIndex, "-cell-").concat(colIndex, "-").concat(key),
        class: [field.class ? field.class : "", this.getTdValues(item, key, field.tdClass, "")],
        props: {},
        attrs: Object(objectSpread2["a" /* default */])({
          "aria-colindex": String(colIndex + 1)
        }, field.isRowHeader ? this.getThValues(item, key, field.thAttr, "row", {}) : this.getTdValues(item, key, field.tdAttr, {}))
      };

      if (stickyColumn) {
        // We are using the helper BTd or BTh
        data.props = {
          stackedHeading: this.isStacked ? field.label : null,
          stickyColumn: true,
          variant: cellVariant
        };
      } else {
        // Using native TD or TH element, so we need to
        // add in the attributes and variant class
        data.attrs["data-label"] = this.isStacked && !isUndefinedOrNull(field.label) ? string_toString(field.label) : null;
        data.attrs.role = field.isRowHeader ? "rowheader" : "cell";
        data.attrs.scope = field.isRowHeader ? "row" : null; // Add in the variant class

        if (cellVariant) {
          data.class.push("".concat(this.dark ? "bg" : "table", "-").concat(cellVariant));
        }
      }

      var slotScope = {
        item: item,
        index: rowIndex,
        field: field,
        unformatted: utils_get(item, key, ""),
        value: formatted,
        toggleDetails: this.toggleDetailsFactory(hasDetailsSlot, item),
        detailsShowing: Boolean(item._showDetails)
      }; // If table supports selectable mode, then add in the following scope
      // this.supportsSelectableRows will be undefined if mixin isn't loaded

      if (this.supportsSelectableRows) {
        slotScope.rowSelected = this.isRowSelected(rowIndex);

        slotScope.selectRow = function () {
          return _this2.selectRow(rowIndex);
        };

        slotScope.unselectRow = function () {
          return _this2.unselectRow(rowIndex);
        };
      } // The new `v-slot` syntax doesn't like a slot name starting with
      // a square bracket and if using in-document HTML templates, the
      // v-slot attributes are lower-cased by the browser.
      // Switched to round bracket syntax to prevent confusion with
      // dynamic slot name syntax.
      // We look for slots in this order: `cell(${key})`, `cell(${key.toLowerCase()})`, 'cell()'
      // Slot names are now cached by mixin tbody in `this.$_bodyFieldSlotNameCache`
      // Will be `null` if no slot (or fallback slot) exists


      var slotName = this.$_bodyFieldSlotNameCache[key];
      var $childNodes = slotName ? this.normalizeSlot(slotName, slotScope) : string_toString(formatted);

      if (this.isStacked) {
        // We wrap in a DIV to ensure rendered as a single cell when visually stacked!
        $childNodes = [h("div", [$childNodes])];
      } // Render either a td or th cell


      return h(cellTag, data, [$childNodes]);
    },
    renderTbodyRow: function renderTbodyRow(item, rowIndex) {
      var _this3 = this;

      // Renders an item's row (or rows if details supported)
      var h = this.$createElement;
      var fields = this.computedFields;
      var tableStriped = this.striped;
      var hasDetailsSlot = this.hasNormalizedSlot(detailsSlotName);
      var rowShowDetails = item._showDetails && hasDetailsSlot;
      var hasRowClickHandler = this.$listeners["row-clicked"] || this.hasSelectableRowClick; // We can return more than one TR if rowDetails enabled

      var $rows = []; // Details ID needed for `aria-details` when details showing
      // We set it to `null` when not showing so that attribute
      // does not appear on the element

      var detailsId = rowShowDetails ? this.safeId("_details_".concat(rowIndex, "_")) : null; // For each item data field in row

      var $tds = fields.map(function (field, colIndex) {
        return _this3.renderTbodyRowCell(field, colIndex, item, rowIndex);
      }); // Calculate the row number in the dataset (indexed from 1)

      var ariaRowIndex = null;

      if (this.currentPage && this.perPage && this.perPage > 0) {
        ariaRowIndex = String((this.currentPage - 1) * this.perPage + rowIndex + 1);
      } // Create a unique :key to help ensure that sub components are re-rendered rather than
      // re-used, which can cause issues. If a primary key is not provided we use the rendered
      // rows index within the tbody.
      // See: https://github.com/bootstrap-vue/bootstrap-vue/issues/2410


      var primaryKey = this.primaryKey;
      var primaryKeyValue = string_toString(utils_get(item, primaryKey)) || null;
      var rowKey = primaryKeyValue || string_toString(rowIndex); // If primary key is provided, use it to generate a unique ID on each tbody > tr
      // In the format of '{tableId}__row_{primaryKeyValue}'

      var rowId = primaryKeyValue ? this.safeId("_row_".concat(primaryKeyValue)) : null; // Selectable classes and attributes

      var selectableClasses = this.selectableRowClasses ? this.selectableRowClasses(rowIndex) : {};
      var selectableAttrs = this.selectableRowAttrs ? this.selectableRowAttrs(rowIndex) : {}; // Additional classes and attributes

      var userTrClasses = isFunction(this.tbodyTrClass) ? this.tbodyTrClass(item, "row") : this.tbodyTrClass;
      var userTrAttrs = isFunction(this.tbodyTrAttr) ? this.tbodyTrAttr(item, "row") : this.tbodyTrAttr; // Add the item row

      $rows.push(h(NlyTr, {
        key: "__nly-table-row-".concat(rowKey, "__"),
        ref: "itemRows",
        refInFor: true,
        class: [userTrClasses, selectableClasses, rowShowDetails ? "nly-table-has-details" : ""],
        props: {
          variant: item._rowVariant || null
        },
        attrs: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({
          id: rowId
        }, userTrAttrs), {}, {
          // Users cannot override the following attributes
          tabindex: hasRowClickHandler ? "0" : null,
          "data-pk": primaryKeyValue || null,
          "aria-details": detailsId,
          "aria-owns": detailsId,
          "aria-rowindex": ariaRowIndex
        }, selectableAttrs),
        on: {
          // Note: These events are not A11Y friendly!
          mouseenter: this.rowHovered,
          mouseleave: this.rowUnhovered
        }
      }, $tds)); // Row Details slot

      if (rowShowDetails) {
        var detailsScope = {
          item: item,
          index: rowIndex,
          fields: fields,
          toggleDetails: this.toggleDetailsFactory(hasDetailsSlot, item)
        }; // If table supports selectable mode, then add in the following scope
        // this.supportsSelectableRows will be undefined if mixin isn't loaded

        if (this.supportsSelectableRows) {
          detailsScope.rowSelected = this.isRowSelected(rowIndex);

          detailsScope.selectRow = function () {
            return _this3.selectRow(rowIndex);
          };

          detailsScope.unselectRow = function () {
            return _this3.unselectRow(rowIndex);
          };
        } // Render the details slot in a TD


        var $details = h(NlyTd, {
          props: {
            colspan: fields.length
          },
          class: this.detailsTdClass
        }, [this.normalizeSlot(detailsSlotName, detailsScope)]); // Add a hidden row to keep table row striping consistent when details showing
        // Only added if the table is striped

        if (tableStriped) {
          $rows.push( // We don't use `BTr` here as we don't need the extra functionality
          h("tr", {
            key: "__nly-table-details-stripe__".concat(rowKey),
            staticClass: "d-none",
            attrs: {
              "aria-hidden": "true",
              role: "presentation"
            }
          }));
        } // Add the actual details row


        var userDetailsTrClasses = isFunction(this.tbodyTrClass) ? this.tbodyTrClass(item, detailsSlotName) : this.tbodyTrClass;
        var userDetailsTrAttrs = isFunction(this.tbodyTrAttr) ? this.tbodyTrAttr(item, detailsSlotName) : this.tbodyTrAttr;
        $rows.push(h(NlyTr, {
          key: "__nly-table-details__".concat(rowKey),
          staticClass: "nly-table-details",
          class: [userDetailsTrClasses],
          props: {
            variant: item._rowVariant || null
          },
          attrs: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, userDetailsTrAttrs), {}, {
            // Users cannot override the following attributes
            id: detailsId,
            tabindex: "-1"
          })
        }, [$details]));
      } else if (hasDetailsSlot) {
        // Only add the placeholder if a the table has a row-details slot defined (but not shown)
        $rows.push(h());

        if (tableStriped) {
          // Add extra placeholder if table is striped
          $rows.push(h());
        }
      } // Return the row(s)


      return $rows;
    }
  }
});
// CONCATENATED MODULE: ./src/components/table/plugin/mixin-tbody.js














var mixin_tbody_props = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, tbody_props), {}, {
  tbodyClass: {
    type: [String, Array, Object] // default: undefined

  }
});

/* harmony default export */ var mixin_tbody = ({
  mixins: [mixin_tbody_row],
  props: mixin_tbody_props,
  methods: {
    // Helper methods
    getTbodyTrs: function getTbodyTrs() {
      // Returns all the item TR elements (excludes detail and spacer rows)
      // `this.$refs.itemRows` is an array of item TR components/elements
      // Rows should all be nly-TR components, but we map to TR elements
      // Also note that `this.$refs.itemRows` may not always be in document order
      var refs = this.$refs || {};
      var tbody = refs.tbody ? refs.tbody.$el || refs.tbody : null;
      var trs = (refs.itemRows || []).map(function (tr) {
        return tr.$el || tr;
      });
      return tbody && tbody.children && tbody.children.length > 0 && trs && trs.length > 0 ? from(tbody.children).filter(function (tr) {
        return arrayIncludes(trs, tr);
      }) : [];
    },
    getTbodyTrIndex: function getTbodyTrIndex(el) {
      // Returns index of a particular TBODY item TR
      // We set `true` on closest to include self in result

      /* istanbul ignore next: should not normally happen */
      if (!isElement(el)) {
        return -1;
      }

      var tr = el.tagName === "TR" ? el : closest("tr", el, true);
      return tr ? this.getTbodyTrs().indexOf(tr) : -1;
    },
    emitTbodyRowEvent: function emitTbodyRowEvent(type, evt) {
      // Emits a row event, with the item object, row index and original event
      if (type && this.hasListener(type) && evt && evt.target) {
        var rowIndex = this.getTbodyTrIndex(evt.target);

        if (rowIndex > -1) {
          // The array of TRs correlate to the `computedItems` array
          var item = this.computedItems[rowIndex];
          this.$emit(type, item, rowIndex, evt);
        }
      }
    },
    tbodyRowEvtStopped: function tbodyRowEvtStopped(evt) {
      return this.stopIfBusy && this.stopIfBusy(evt);
    },
    // Delegated row event handlers
    onTbodyRowKeydown: function onTbodyRowKeydown(evt) {
      // Keyboard navigation and row click emulation
      var target = evt.target;

      if (this.tbodyRowEvtStopped(evt) || target.tagName !== "TR" || target !== document.activeElement || target.tabIndex !== 0) {
        // Early exit if not an item row TR
        return;
      }

      var keyCode = evt.keyCode;

      if (arrayIncludes([key_codes.ENTER, key_codes.SPACE], keyCode)) {
        // Emulated click for keyboard users, transfer to click handler
        evt.stopPropagation();
        evt.preventDefault();
        this.onTBodyRowClicked(evt);
      } else if (arrayIncludes([key_codes.UP, key_codes.DOWN, key_codes.HOME, key_codes.END], keyCode)) {
        // Keyboard navigation
        var rowIndex = this.getTbodyTrIndex(target);

        if (rowIndex > -1) {
          evt.stopPropagation();
          evt.preventDefault();
          var trs = this.getTbodyTrs();
          var shift = evt.shiftKey;

          if (keyCode === key_codes.HOME || shift && keyCode === key_codes.UP) {
            // Focus first row
            trs[0].focus();
          } else if (keyCode === key_codes.END || shift && keyCode === key_codes.DOWN) {
            // Focus last row
            trs[trs.length - 1].focus();
          } else if (keyCode === key_codes.UP && rowIndex > 0) {
            // Focus previous row
            trs[rowIndex - 1].focus();
          } else if (keyCode === key_codes.DOWN && rowIndex < trs.length - 1) {
            // Focus next row
            trs[rowIndex + 1].focus();
          }
        }
      }
    },
    onTBodyRowClicked: function onTBodyRowClicked(evt) {
      if (this.tbodyRowEvtStopped(evt)) {
        // If table is busy, then don't propagate
        return;
      } else if (filter_event(evt) || text_selection_active(this.$el)) {
        // Clicked on a non-disabled control so ignore
        // Or user is selecting text, so ignore
        return;
      }

      this.emitTbodyRowEvent("row-clicked", evt);
    },
    onTbodyRowMiddleMouseRowClicked: function onTbodyRowMiddleMouseRowClicked(evt) {
      if (!this.tbodyRowEvtStopped(evt) && evt.which === 2) {
        this.emitTbodyRowEvent("row-middle-clicked", evt);
      }
    },
    onTbodyRowContextmenu: function onTbodyRowContextmenu(evt) {
      if (!this.tbodyRowEvtStopped(evt)) {
        this.emitTbodyRowEvent("row-contextmenu", evt);
      }
    },
    onTbodyRowDblClicked: function onTbodyRowDblClicked(evt) {
      if (!this.tbodyRowEvtStopped(evt) && !filter_event(evt)) {
        this.emitTbodyRowEvent("row-dblclicked", evt);
      }
    },
    // Note: Row hover handlers are handled by the tbody-row mixin
    // As mouseenter/mouseleave events do not bubble
    //
    // Render Helper
    renderTbody: function renderTbody() {
      var _this = this;

      // Render the tbody element and children
      var items = this.computedItems; // Shortcut to `createElement` (could use `this._c()` instead)

      var h = this.$createElement;
      var hasRowClickHandler = this.hasListener("row-clicked") || this.hasSelectableRowClick; // Prepare the tbody rows

      var $rows = []; // Add the item data rows or the busy slot

      var $busy = this.renderBusy ? this.renderBusy() : null;

      if ($busy) {
        // If table is busy and a busy slot, then return only the busy "row" indicator
        $rows.push($busy);
      } else {
        // Table isn't busy, or we don't have a busy slot
        // Create a slot cache for improved performance when looking up cell slot names
        // Values will be keyed by the field's `key` and will store the slot's name
        // Slots could be dynamic (i.e. `v-if`), so we must compute on each render
        // Used by tbody-row mixin render helper
        var cache = {};
        var defaultSlotName = this.hasNormalizedSlot("cell()") ? "cell()" : null;
        this.computedFields.forEach(function (field) {
          var key = field.key;
          var fullName = "cell(".concat(key, ")");
          var lowerName = "cell(".concat(key.toLowerCase(), ")");
          cache[key] = _this.hasNormalizedSlot(fullName) ? fullName : _this.hasNormalizedSlot(lowerName) ? lowerName : defaultSlotName;
        }); // Created as a non-reactive property so to not trigger component updates
        // Must be a fresh object each render

        this.$_bodyFieldSlotNameCache = cache; // Add static top row slot (hidden in visibly stacked mode
        // as we can't control `data-label` attr)

        $rows.push(this.renderTopRow ? this.renderTopRow() : h()); // Render the rows

        items.forEach(function (item, rowIndex) {
          // Render the individual item row (rows if details slot)
          $rows.push(_this.renderTbodyRow(item, rowIndex));
        }); // Empty items / empty filtered row slot (only shows if `items.length < 1`)

        $rows.push(this.renderEmpty ? this.renderEmpty() : h()); // Static bottom row slot (hidden in visibly stacked mode
        // as we can't control `data-label` attr)

        $rows.push(this.renderBottomRow ? this.renderBottomRow() : h());
      } // Note: these events will only emit if a listener is registered


      var handlers = {
        auxclick: this.onTbodyRowMiddleMouseRowClicked,
        // TODO:
        //   Perhaps we do want to automatically prevent the
        //   default context menu from showing if there is a
        //   `row-contextmenu` listener registered
        contextmenu: this.onTbodyRowContextmenu,
        // The following event(s) is not considered A11Y friendly
        dblclick: this.onTbodyRowDblClicked // Hover events (`mouseenter`/`mouseleave`) are handled by `tbody-row` mixin

      }; // Add in click/keydown listeners if needed

      if (hasRowClickHandler) {
        handlers.click = this.onTBodyRowClicked;
        handlers.keydown = this.onTbodyRowKeydown;
      } // Assemble rows into the tbody


      var $tbody = h(NlyTbody, {
        ref: "tbody",
        class: this.tbodyClass || null,
        props: {
          tbodyTransitionProps: this.tbodyTransitionProps,
          tbodyTransitionHandlers: this.tbodyTransitionHandlers
        },
        // BTbody transfers all native event listeners to the root element
        // TODO: Only set the handlers if the table is not busy
        on: handlers
      }, $rows); // Return the assembled tbody

      return $tbody;
    }
  }
});
// CONCATENATED MODULE: ./src/components/table/plugin/mixin-empty.js




/* harmony default export */ var mixin_empty = ({
  props: {
    showEmpty: {
      type: Boolean,
      default: false
    },
    emptyText: {
      type: String,
      default: "There are no records to show"
    },
    emptyHtml: {
      type: String
    },
    emptyFilteredText: {
      type: String,
      default: "There are no records matching your request"
    },
    emptyFilteredHtml: {
      type: String
    }
  },
  methods: {
    renderEmpty: function renderEmpty() {
      var h = this.$createElement;
      var items = this.computedItems;
      var $empty;

      if (this.showEmpty && (!items || items.length === 0) && !(this.computedBusy && this.hasNormalizedSlot("table-busy"))) {
        $empty = this.normalizeSlot(this.isFiltered ? "emptyfiltered" : "empty", {
          emptyFilteredHtml: this.emptyFilteredHtml,
          emptyFilteredText: this.emptyFilteredText,
          emptyHtml: this.emptyHtml,
          emptyText: this.emptyText,
          fields: this.computedFields,
          // Not sure why this is included, as it will always be an empty array
          items: this.computedItems
        });

        if (!$empty) {
          $empty = h("div", {
            class: ["text-center", "my-2"],
            domProps: this.isFiltered ? htmlOrText(this.emptyFilteredHtml, this.emptyFilteredText) : htmlOrText(this.emptyHtml, this.emptyText)
          });
        }

        $empty = h(NlyTd, {
          props: {
            colspan: this.computedFields.length || null
          }
        }, [h("div", {
          attrs: {
            role: "alert",
            "aria-live": "polite"
          }
        }, [$empty])]);
        $empty = h(NlyTr, {
          key: this.isFiltered ? "nly-empty-filtered-row" : "nly-empty-row",
          staticClass: "nly-table-empty-row",
          class: [isFunction(this.tbodyTrClass) ? this.tbodyTrClass(null, "row-empty") : this.tbodyTrClass],
          attrs: isFunction(this.tbodyTrAttr) ? this.tbodyTrAttr(null, "row-empty") : this.tbodyTrAttr
        }, [$empty]);
      }

      return $empty || h();
    }
  }
});
// CONCATENATED MODULE: ./src/components/table/plugin/mixin-top-row.js


var mixin_top_row_slotName = "top-row";
/* harmony default export */ var mixin_top_row = ({
  methods: {
    renderTopRow: function renderTopRow() {
      var h = this.$createElement; // Add static Top Row slot (hidden in visibly stacked mode as we can't control the data-label)
      // If in *always* stacked mode, we don't bother rendering the row

      if (!this.hasNormalizedSlot(mixin_top_row_slotName) || this.stacked === true || this.stacked === "") {
        return h();
      }

      var fields = this.computedFields;
      return h(NlyTr, {
        key: "nly-top-row",
        staticClass: "nly-table-top-row",
        class: [isFunction(this.tbodyTrClass) ? this.tbodyTrClass(null, "row-top") : this.tbodyTrClass],
        attrs: isFunction(this.tbodyTrAttr) ? this.tbodyTrAttr(null, "row-top") : this.tbodyTrAttr
      }, [this.normalizeSlot(mixin_top_row_slotName, {
        columns: fields.length,
        fields: fields
      })]);
    }
  }
});
// CONCATENATED MODULE: ./src/components/table/plugin/mixin-bottom-row.js


var mixin_bottom_row_slotName = "bottom-row";
/* harmony default export */ var mixin_bottom_row = ({
  methods: {
    renderBottomRow: function renderBottomRow() {
      var h = this.$createElement; // Static bottom row slot (hidden in visibly stacked mode as we can't control the data-label)
      // If in *always* stacked mode, we don't bother rendering the row

      if (!this.hasNormalizedSlot(mixin_bottom_row_slotName) || this.stacked === true || this.stacked === "") {
        return h();
      }

      var fields = this.computedFields;
      return h(NlyTr, {
        key: "nly-bottom-row",
        staticClass: "nly-table-bottom-row",
        class: [isFunction(this.tbodyTrClass) ? this.tbodyTrClass(null, "row-bottom") : this.tbodyTrClass],
        attrs: isFunction(this.tbodyTrAttr) ? this.tbodyTrAttr(null, "row-bottom") : this.tbodyTrAttr
      }, this.normalizeSlot(mixin_bottom_row_slotName, {
        columns: fields.length,
        fields: fields
      }));
    }
  }
});
// CONCATENATED MODULE: ./src/components/table/plugin/mixin-busy.js



var busySlotName = "table-busy";
/* harmony default export */ var mixin_busy = ({
  props: {
    busy: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      localBusy: false
    };
  },
  computed: {
    computedBusy: function computedBusy() {
      return this.busy || this.localBusy;
    }
  },
  watch: {
    localBusy: function localBusy(newVal, oldVal) {
      if (newVal !== oldVal) {
        this.$emit("update:busy", newVal);
      }
    }
  },
  methods: {
    // Event handler helper
    stopIfBusy: function stopIfBusy(evt) {
      if (this.computedBusy) {
        // If table is busy (via provider) then don't propagate
        evt.preventDefault();
        evt.stopPropagation();
        return true;
      }

      return false;
    },
    // Render the busy indicator or return `null` if not busy
    renderBusy: function renderBusy() {
      var h = this.$createElement; // Return a busy indicator row, or `null` if not busy

      if (this.computedBusy && this.hasNormalizedSlot(busySlotName)) {
        // Show the busy slot
        return h(NlyTr, {
          key: "table-busy-slot",
          staticClass: "nly-table-busy-slot",
          class: [isFunction(this.tbodyTrClass) ? this.tbodyTrClass(null, busySlotName) : this.tbodyTrClass],
          attrs: isFunction(this.tbodyTrAttr) ? this.tbodyTrAttr(null, busySlotName) : this.tbodyTrAttr
        }, [h(NlyTd, {
          props: {
            colspan: this.computedFields.length || null
          }
        }, [this.normalizeSlot(busySlotName)])]);
      } else {
        // We return `null` here so that we can determine if we need to
        // render the table items rows or not
        return null;
      }
    }
  }
});
// CONCATENATED MODULE: ./src/components/table/plugin/mixin-selectable.js














/* harmony default export */ var mixin_selectable = ({
  props: {
    selectable: {
      type: Boolean,
      default: false
    },
    selectMode: {
      type: String,
      default: "multi",
      validator: function validator(val) {
        return arrayIncludes(["range", "multi", "single"], val);
      }
    },
    selectedVariant: {
      type: String,
      default: function _default() {
        return getComponentConfig("NlyTable", "selectedVariant");
      }
    },
    noSelectOnClick: {
      // Disable use of click handlers for row selection
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      selectedRows: [],
      selectedLastRow: -1
    };
  },
  computed: {
    isSelectable: function isSelectable() {
      return this.selectable && this.selectMode;
    },
    hasSelectableRowClick: function hasSelectableRowClick() {
      return this.isSelectable && !this.noSelectOnClick;
    },
    supportsSelectableRows: function supportsSelectableRows() {
      return true;
    },
    selectableHasSelection: function selectableHasSelection() {
      return this.isSelectable && this.selectedRows && this.selectedRows.length > 0 && this.selectedRows.some(utils_identity);
    },
    selectableIsMultiSelect: function selectableIsMultiSelect() {
      return this.isSelectable && arrayIncludes(["range", "multi"], this.selectMode);
    },
    selectableTableClasses: function selectableTableClasses() {
      var _ref;

      return _ref = {
        "nly-table-selectable": this.isSelectable
      }, Object(defineProperty["a" /* default */])(_ref, "nly-table-select-".concat(this.selectMode), this.isSelectable), Object(defineProperty["a" /* default */])(_ref, "nly-table-selecting", this.selectableHasSelection), Object(defineProperty["a" /* default */])(_ref, "nly-table-selectable-no-click", this.isSelectable && !this.hasSelectableRowClick), _ref;
    },
    selectableTableAttrs: function selectableTableAttrs() {
      return {
        // TODO:
        //   Should this attribute not be included when no-select-on-click is set
        //   since this attribute implies keyboard navigation?
        "aria-multiselectable": !this.isSelectable ? null : this.selectableIsMultiSelect ? "true" : "false"
      };
    }
  },
  watch: {
    computedItems: function computedItems(newVal, oldVal) {
      // Reset for selectable
      var equal = false;

      if (this.isSelectable && this.selectedRows.length > 0) {
        // Quick check against array length
        equal = isArray(newVal) && isArray(oldVal) && newVal.length === oldVal.length;

        for (var i = 0; equal && i < newVal.length; i++) {
          // Look for the first non-loosely equal row, after ignoring reserved fields
          equal = loose_equal(sanitize_row(newVal[i]), sanitize_row(oldVal[i]));
        }
      }

      if (!equal) {
        this.clearSelected();
      }
    },
    selectable: function selectable(newVal) {
      this.clearSelected();
      this.setSelectionHandlers(newVal);
    },
    selectMode: function selectMode() {
      this.clearSelected();
    },
    hasSelectableRowClick: function hasSelectableRowClick(newVal) {
      this.clearSelected();
      this.setSelectionHandlers(!newVal);
    },
    selectedRows: function selectedRows(_selectedRows, oldVal) {
      var _this = this;

      if (this.isSelectable && !loose_equal(_selectedRows, oldVal)) {
        var items = []; // `.forEach()` skips over non-existent indices (on sparse arrays)

        _selectedRows.forEach(function (v, idx) {
          if (v) {
            items.push(_this.computedItems[idx]);
          }
        });

        this.$emit("row-selected", items);
      }
    }
  },
  beforeMount: function beforeMount() {
    // Set up handlers if needed
    if (this.isSelectable) {
      this.setSelectionHandlers(true);
    }
  },
  methods: {
    // Public methods
    selectRow: function selectRow(index) {
      // Select a particular row (indexed based on computedItems)
      if (this.isSelectable && isNumber(index) && index >= 0 && index < this.computedItems.length && !this.isRowSelected(index)) {
        var selectedRows = this.selectableIsMultiSelect ? this.selectedRows.slice() : [];
        selectedRows[index] = true;
        this.selectedLastClicked = -1;
        this.selectedRows = selectedRows;
      }
    },
    unselectRow: function unselectRow(index) {
      // Un-select a particular row (indexed based on `computedItems`)
      if (this.isSelectable && isNumber(index) && this.isRowSelected(index)) {
        var selectedRows = this.selectedRows.slice();
        selectedRows[index] = false;
        this.selectedLastClicked = -1;
        this.selectedRows = selectedRows;
      }
    },
    selectAllRows: function selectAllRows() {
      var length = this.computedItems.length;

      if (this.isSelectable && length > 0) {
        this.selectedLastClicked = -1;
        this.selectedRows = this.selectableIsMultiSelect ? utils_range(length).map(function () {
          return true;
        }) : [true];
      }
    },
    isRowSelected: function isRowSelected(index) {
      // Determine if a row is selected (indexed based on `computedItems`)
      return !!(isNumber(index) && this.selectedRows[index]);
    },
    clearSelected: function clearSelected() {
      // Clear any active selected row(s)
      this.selectedLastClicked = -1;
      this.selectedRows = [];
    },
    // Internal private methods
    selectableRowClasses: function selectableRowClasses(index) {
      if (this.isSelectable && this.isRowSelected(index)) {
        var variant = this.selectedVariant;
        return Object(defineProperty["a" /* default */])({
          "nly-table-row-selected": true
        }, "".concat(this.dark ? "bg" : "table", "-").concat(variant), variant);
      } else {
        return {};
      }
    },
    selectableRowAttrs: function selectableRowAttrs(index) {
      return {
        "aria-selected": !this.isSelectable ? null : this.isRowSelected(index) ? "true" : "false"
      };
    },
    setSelectionHandlers: function setSelectionHandlers(on) {
      var method = on && !this.noSelectOnClick ? "$on" : "$off"; // Handle row-clicked event

      this[method]("row-clicked", this.selectionHandler); // Clear selection on filter, pagination, and sort changes

      this[method]("filtered", this.clearSelected);
      this[method]("context-changed", this.clearSelected);
    },
    selectionHandler: function selectionHandler(item, index, evt) {
      /* istanbul ignore if: should never happen */
      if (!this.isSelectable || this.noSelectOnClick) {
        // Don't do anything if table is not in selectable mode
        this.clearSelected();
        return;
      }

      var selectMode = this.selectMode;
      var selectedRows = this.selectedRows.slice();
      var selected = !selectedRows[index]; // Note 'multi' mode needs no special event handling

      if (selectMode === "single") {
        selectedRows = [];
      } else if (selectMode === "range") {
        if (this.selectedLastRow > -1 && evt.shiftKey) {
          // range
          for (var idx = Math.min(this.selectedLastRow, index); idx <= Math.max(this.selectedLastRow, index); idx++) {
            selectedRows[idx] = true;
          }

          selected = true;
        } else {
          if (!(evt.ctrlKey || evt.metaKey)) {
            // Clear range selection if any
            selectedRows = [];
            selected = true;
          }

          this.selectedLastRow = selected ? index : -1;
        }
      }

      selectedRows[index] = selected;
      this.selectedRows = selectedRows;
    }
  }
});
// CONCATENATED MODULE: ./src/components/table/plugin/mixin-provider.js









/* harmony default export */ var mixin_provider = ({
  mixins: [listen_on_root],
  props: {
    // Prop override(s)
    items: {
      // Adds in 'Function' support
      type: [Array, Function],
      default: function _default()
      /* istanbul ignore next */
      {
        return [];
      }
    },
    // Additional props
    noProviderPaging: {
      type: Boolean,
      default: false
    },
    noProviderSorting: {
      type: Boolean,
      default: false
    },
    noProviderFiltering: {
      type: Boolean,
      default: false
    },
    apiUrl: {
      // Passthrough prop. Passed to the context object. Not used by nly-table directly
      type: String,
      default: ""
    }
  },
  computed: {
    hasProvider: function hasProvider() {
      return isFunction(this.items);
    },
    providerTriggerContext: function providerTriggerContext() {
      // Used to trigger the provider function via a watcher. Only the fields that
      // are needed for triggering a provider update are included. Note that the
      // regular this.context is sent to the provider during fetches though, as they
      // may need all the prop info.
      var ctx = {
        apiUrl: this.apiUrl,
        filter: null,
        sortBy: null,
        sortDesc: null,
        perPage: null,
        currentPage: null
      };

      if (!this.noProviderFiltering) {
        // Either a string, or could be an object or array.
        ctx.filter = this.localFilter;
      }

      if (!this.noProviderSorting) {
        ctx.sortBy = this.localSortBy;
        ctx.sortDesc = this.localSortDesc;
      }

      if (!this.noProviderPaging) {
        ctx.perPage = this.perPage;
        ctx.currentPage = this.currentPage;
      }

      return object_clone(ctx);
    }
  },
  watch: {
    // Provider update triggering
    items: function items(newVal) {
      // If a new provider has been specified, trigger an update
      if (this.hasProvider || isFunction(newVal)) {
        this.$nextTick(this._providerUpdate);
      }
    },
    providerTriggerContext: function providerTriggerContext(newVal, oldVal) {
      // Trigger the provider to update as the relevant context values have changed.
      if (!loose_equal(newVal, oldVal)) {
        this.$nextTick(this._providerUpdate);
      }
    }
  },
  mounted: function mounted() {
    var _this = this;

    // Call the items provider if necessary
    if (this.hasProvider && (!this.localItems || this.localItems.length === 0)) {
      // Fetch on mount if localItems is empty
      this._providerUpdate();
    } // Listen for global messages to tell us to force refresh the table


    this.listenOnRoot("nlya::refresh::table", function (id) {
      if (id === _this.id || id === _this) {
        _this.refresh();
      }
    });
  },
  methods: {
    refresh: function refresh() {
      // Public Method: Force a refresh of the provider function
      this.$off("refreshed", this.refresh);

      if (this.computedBusy) {
        // Can't force an update when forced busy by user (busy prop === true)
        if (this.localBusy && this.hasProvider) {
          // But if provider running (localBusy), re-schedule refresh once `refreshed` emitted
          this.$on("refreshed", this.refresh);
        }
      } else {
        this.clearSelected();

        if (this.hasProvider) {
          this.$nextTick(this._providerUpdate);
        } else {
          /* istanbul ignore next */
          this.localItems = isArray(this.items) ? this.items.slice() : [];
        }
      }
    },
    // Provider related methods
    _providerSetLocal: function _providerSetLocal(items) {
      this.localItems = isArray(items) ? items.slice() : [];
      this.localBusy = false;
      this.$emit("refreshed"); // New root emit

      if (this.id) {
        this.emitOnRoot("nlya::table::refreshed", this.id);
      }
    },
    _providerUpdate: function _providerUpdate() {
      var _this2 = this;

      // Refresh the provider function items.
      if (!this.hasProvider) {
        // Do nothing if no provider
        return;
      } // If table is busy, wait until refreshed before calling again


      if (this.computedBusy) {
        // Schedule a new refresh once `refreshed` is emitted
        this.$nextTick(this.refresh);
        return;
      } // Set internal busy state


      this.localBusy = true; // Call provider function with context and optional callback after DOM is fully updated

      this.$nextTick(function () {
        try {
          // Call provider function passing it the context and optional callback
          var data = _this2.items(_this2.context, _this2._providerSetLocal);

          if (isPromise(data)) {
            // Provider returned Promise
            data.then(function (items) {
              // Provider resolved with items
              _this2._providerSetLocal(items);
            });
          } else if (isArray(data)) {
            // Provider returned Array data
            _this2._providerSetLocal(data);
          } else {
            /* istanbul ignore if */
            if (_this2.items.length !== 2) {
              // Check number of arguments provider function requested
              // Provider not using callback (didn't request second argument), so we clear
              // busy state as most likely there was an error in the provider function

              /* istanbul ignore next */
              warn_warn("Provider function didn't request callback and did not return a promise or data.", "NlyTable");
              _this2.localBusy = false;
            }
          }
        } catch (e)
        /* istanbul ignore next */
        {
          // Provider function borked on us, so we spew out a warning
          // and clear the busy state
          warn_warn("Provider function error [".concat(e.name, "] ").concat(e.message, "."), "NlyTable");
          _this2.localBusy = false;

          _this2.$off("refreshed", _this2.refresh);
        }
      });
    }
  }
});
// CONCATENATED MODULE: ./src/components/table/plugin/mixin-table-renderer.js









/* harmony default export */ var mixin_table_renderer = ({
  inheritAttrs: false,
  provide: function provide() {
    return {
      nlyaTable: this
    };
  },
  props: {
    striped: {
      type: Boolean,
      default: false
    },
    bordered: {
      type: Boolean,
      default: false
    },
    borderless: {
      type: Boolean,
      default: false
    },
    outlined: {
      type: Boolean,
      default: false
    },
    dark: {
      type: Boolean,
      default: false
    },
    hover: {
      type: Boolean,
      default: false
    },
    small: {
      type: Boolean,
      default: false
    },
    fixed: {
      type: Boolean,
      default: false
    },
    responsive: {
      type: [Boolean, String],
      default: false
    },
    stickyHeader: {
      // If a string, it is assumed to be the table `max-height` value
      type: [Boolean, String],
      default: false
    },
    noBorderCollapse: {
      type: Boolean,
      default: false
    },
    captionTop: {
      type: Boolean,
      default: false
    },
    tableVariant: {
      type: String,
      default: null
    },
    tableClass: {
      type: [String, Array, Object],
      default: null
    }
  },
  computed: {
    // Layout related computed props
    isResponsive: function isResponsive() {
      var responsive = this.responsive === "" ? true : this.responsive;
      return this.isStacked ? false : responsive;
    },
    isStickyHeader: function isStickyHeader() {
      var stickyHeader = this.stickyHeader === "" ? true : this.stickyHeader;
      return this.isStacked ? false : stickyHeader;
    },
    wrapperClasses: function wrapperClasses() {
      return [this.isStickyHeader ? "nly-table-sticky-header" : "", this.isResponsive === true ? "table-responsive" : this.isResponsive ? "table-responsive-".concat(this.responsive) : ""].filter(utils_identity);
    },
    wrapperStyles: function wrapperStyles() {
      return this.isStickyHeader && !isBoolean(this.isStickyHeader) ? {
        maxHeight: this.isStickyHeader
      } : {};
    },
    tableClasses: function tableClasses() {
      var hover = this.isTableSimple ? this.hover : this.hover && this.computedItems.length > 0 && !this.computedBusy;
      return [// User supplied classes
      this.tableClass, // Styling classes
      {
        "table-striped": this.striped,
        "table-hover": hover,
        "table-dark": this.dark,
        "table-bordered": this.bordered,
        "table-borderless": this.borderless,
        "table-sm": this.small,
        // The following are nly-table custom styles
        border: this.outlined,
        "nly-table-fixed": this.fixed,
        "nly-table-caption-top": this.captionTop,
        "nly-table-no-border-collapse": this.noBorderCollapse
      }, this.tableVariant ? "".concat(this.dark ? "bg" : "table", "-").concat(this.tableVariant) : "", // Stacked table classes
      this.stackedTableClasses, // Selectable classes
      this.selectableTableClasses];
    },
    tableAttrs: function tableAttrs() {
      // Preserve user supplied aria-describedby, if provided in `$attrs`
      var adb = [(this.$attrs || {})["aria-describedby"], this.captionId].filter(utils_identity).join(" ") || null;
      var items = this.computedItems;
      var filteredItems = this.filteredItems;
      var fields = this.computedFields;
      var selectableAttrs = this.selectableTableAttrs || {};
      var ariaAttrs = this.isTableSimple ? {} : {
        "aria-busy": this.computedBusy ? "true" : "false",
        "aria-colcount": string_toString(fields.length),
        "aria-describedby": adb
      };
      var rowCount = items && filteredItems && filteredItems.length > items.length ? string_toString(filteredItems.length) : null;
      return Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({
        // We set `aria-rowcount` before merging in `$attrs`,
        // in case user has supplied their own
        "aria-rowcount": rowCount
      }, this.$attrs), {}, {
        // Now we can override any `$attrs` here
        id: this.safeId(),
        role: "table"
      }, ariaAttrs), selectableAttrs);
    }
  },
  render: function render(h) {
    var $content = [];

    if (this.isTableSimple) {
      $content.push(this.normalizeSlot("default"));
    } else {
      // Build the `<caption>` (from caption mixin)
      $content.push(this.renderCaption ? this.renderCaption() : null); // Build the `<colgroup>`

      $content.push(this.renderColgroup ? this.renderColgroup() : null); // Build the `<thead>`

      $content.push(this.renderThead ? this.renderThead() : null); // Build the `<tbody>`

      $content.push(this.renderTbody ? this.renderTbody() : null); // Build the `<tfoot>`

      $content.push(this.renderTfoot ? this.renderTfoot() : null);
    } // Assemble `<table>`


    var $table = h("table", {
      key: "nly-table",
      staticClass: "table nly-table",
      class: this.tableClasses,
      attrs: this.tableAttrs
    }, $content.filter(utils_identity)); // Add responsive/sticky wrapper if needed and return table

    return this.wrapperClasses.length > 0 ? h("div", {
      key: "wrap",
      class: this.wrapperClasses,
      style: this.wrapperStyles
    }, [$table]) : $table;
  }
});
// CONCATENATED MODULE: ./src/components/table/table.js
 // Mixins



 // Table helper Mixins
















 // table 渲染mixins


var table_name = "NlyTable";
var NlyTable = utils_vue.extend({
  name: table_name,
  // Order of mixins is important!
  // They are merged from first to last, followed by this component.
  mixins: [// Required Mixins
  has_listener, mixins_id, mixins_normalize_slot, mixin_items, mixin_table_renderer, mixin_stacked, mixin_thead, mixin_tfoot, mixin_tbody, // Features Mixins
  mixin_stacked, mixin_filtering, mixin_sorting, mixin_pagination, mixin_caption, mixin_colgroup, mixin_selectable, mixin_empty, mixin_top_row, mixin_bottom_row, mixin_busy, mixin_provider] // render function provided by table-renderer mixin

});
// CONCATENATED MODULE: ./src/components/table/table-lite.js
 // Mixins



 // Table helper Mixins







 // Main table renderer mixin

 // @vue/component

var table_lite_name = "NlyTableLite";
var NlyTableLite = utils_vue.extend({
  name: table_lite_name,
  // Order of mixins is important!
  // They are merged from first to last, followed by this component.
  mixins: [// Required mixins
  has_listener, mixins_id, mixins_normalize_slot, mixin_items, mixin_table_renderer, mixin_stacked, mixin_thead, mixin_tfoot, mixin_tbody, // Features Mixins
  // These are pretty lightweight, and are useful for lightweight tables
  mixin_caption, mixin_colgroup] // render function provided by table-renderer mixin

});
// CONCATENATED MODULE: ./src/components/table/table-simple.js
 // Mixins


 // Main table renderer mixin

 // Feature miins

 // @vue/component

var table_simple_name = "NlyTableSimple";
var NlyTableSimple = /*#__PURE__*/utils_vue.extend({
  name: table_simple_name,
  // Order of mixins is important!
  // They are merged from first to last, followed by this component.
  mixins: [// Required mixins
  mixins_id, mixins_normalize_slot, mixin_table_renderer, // feature mixin
  // Stacked requires extra handling by users via
  // the table cell `stacked-heading` prop
  mixin_stacked],
  computed: {
    isTableSimple: function isTableSimple() {
      return true;
    }
  } // render function provided by table-renderer mixin

});
// CONCATENATED MODULE: ./src/components/table/index.js










var TableLitePlugin = plugins_nlyPluginFactory({
  components: {
    NlyTableLite: NlyTableLite
  }
});
var TableSimplePlugin = plugins_nlyPluginFactory({
  components: {
    NlyTableSimple: NlyTableSimple,
    NlyTbody: NlyTbody,
    NlyThead: NlyThead,
    NlyTfoot: NlyTfoot,
    NlyTr: NlyTr,
    NlyTd: NlyTd,
    NlyTh: NlyTh
  }
});
var TablePlugin = plugins_nlyPluginFactory({
  components: {
    NlyTable: NlyTable
  },
  plugins: {
    TableLitePlugin: TableLitePlugin,
    TableSimplePlugin: TableSimplePlugin
  }
});

// CONCATENATED MODULE: ./src/directives/tooltip/tooltip.js

















 // Key which we use to store tooltip object on element

var Nlya_TOOLTIP = "__Nlya_Tooltip__"; // Default trigger

var tooltip_DefaultTrigger = "hover focus"; // Valid event triggers

var tooltip_validTriggers = {
  focus: true,
  hover: true,
  click: true,
  blur: true,
  manual: true
}; // Directive modifier test regular expressions. Pre-compile for performance

var tooltip_htmlRE = /^html$/i;
var noninteractiveRE = /^noninteractive$/i;
var tooltip_noFadeRE = /^nofade$/i;
var tooltip_placementRE = /^(auto|top(left|right)?|bottom(left|right)?|left(top|bottom)?|right(top|bottom)?)$/i;
var tooltip_boundaryRE = /^(window|viewport|scrollParent)$/i;
var tooltip_delayRE = /^d\d+$/i;
var tooltip_delayShowRE = /^ds\d+$/i;
var tooltip_delayHideRE = /^dh\d+$/i;
var tooltip_offsetRE = /^o-?\d+$/i;
var tooltip_variantRE = /^v-.+$/i;
var tooltip_spacesRE = /\s+/; // Build a Tooltip config based on bindings (if any)
// Arguments and modifiers take precedence over passed value config object

var tooltip_parseBindings = function parseBindings(bindings, vnode)
/* istanbul ignore next: not easy to test */
{
  // We start out with a basic config
  var NAME = "NlyTooltip"; // Default config

  var config = {
    title: undefined,
    trigger: "",
    // Default set below if needed
    placement: "top",
    fallbackPlacement: "flip",
    container: false,
    // Default of body
    animation: true,
    offset: 0,
    id: null,
    html: false,
    interactive: true,
    disabled: false,
    delay: getComponentConfig(NAME, "delay"),
    boundary: String(getComponentConfig(NAME, "boundary")),
    boundaryPadding: parseInt(getComponentConfig(NAME, "boundaryPadding"), 10) || 0,
    variant: getComponentConfig(NAME, "variant"),
    customClass: getComponentConfig(NAME, "customClass")
  }; // Process `bindings.value`

  if (isString(bindings.value) || isNumber(bindings.value)) {
    // Value is tooltip content (HTML optionally supported)
    config.title = bindings.value;
  } else if (isFunction(bindings.value)) {
    // Title generator function
    config.title = bindings.value;
  } else if (isPlainObject(bindings.value)) {
    // Value is config object, so merge
    config = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, config), bindings.value);
  } // If title is not provided, try title attribute


  if (isUndefined(config.title)) {
    // Try attribute
    var data = vnode.data || {};
    config.title = data.attrs && !isUndefinedOrNull(data.attrs.title) ? data.attrs.title : undefined;
  } // Normalize delay


  if (!isPlainObject(config.delay)) {
    config.delay = {
      show: parseInt(config.delay, 10) || 0,
      hide: parseInt(config.delay, 10) || 0
    };
  } // If argument, assume element ID of container element


  if (bindings.arg) {
    // Element ID specified as arg
    // We must prepend '#' to become a CSS selector
    config.container = "#".concat(bindings.arg);
  } // Process modifiers


  keys(bindings.modifiers).forEach(function (mod) {
    if (tooltip_htmlRE.test(mod)) {
      // Title allows HTML
      config.html = true;
    } else if (noninteractiveRE.test(mod)) {
      // Noninteractive
      config.interactive = false;
    } else if (tooltip_noFadeRE.test(mod)) {
      // No animation
      config.animation = false;
    } else if (tooltip_placementRE.test(mod)) {
      // Placement of tooltip
      config.placement = mod;
    } else if (tooltip_boundaryRE.test(mod)) {
      // Boundary of tooltip
      mod = mod === "scrollparent" ? "scrollParent" : mod;
      config.boundary = mod;
    } else if (tooltip_delayRE.test(mod)) {
      // Delay value
      var delay = parseInt(mod.slice(1), 10) || 0;
      config.delay.show = delay;
      config.delay.hide = delay;
    } else if (tooltip_delayShowRE.test(mod)) {
      // Delay show value
      config.delay.show = parseInt(mod.slice(2), 10) || 0;
    } else if (tooltip_delayHideRE.test(mod)) {
      // Delay hide value
      config.delay.hide = parseInt(mod.slice(2), 10) || 0;
    } else if (tooltip_offsetRE.test(mod)) {
      // Offset value, negative allowed
      config.offset = parseInt(mod.slice(1), 10) || 0;
    } else if (tooltip_variantRE.test(mod)) {
      // Variant
      config.variant = mod.slice(2) || null;
    }
  }); // Special handling of event trigger modifiers trigger is
  // a space separated list

  var selectedTriggers = {}; // Parse current config object trigger

  concat(config.trigger || "").filter(utils_identity).join(" ").trim().toLowerCase().split(tooltip_spacesRE).forEach(function (trigger) {
    if (tooltip_validTriggers[trigger]) {
      selectedTriggers[trigger] = true;
    }
  }); // Parse modifiers for triggers

  keys(bindings.modifiers).forEach(function (mod) {
    mod = mod.toLowerCase();

    if (tooltip_validTriggers[mod]) {
      // If modifier is a valid trigger
      selectedTriggers[mod] = true;
    }
  }); // Sanitize triggers

  config.trigger = keys(selectedTriggers).join(" ");

  if (config.trigger === "blur") {
    // Blur by itself is useless, so convert it to 'focus'
    config.trigger = "focus";
  }

  if (!config.trigger) {
    // Use default trigger
    config.trigger = tooltip_DefaultTrigger;
  } // Return the config


  return config;
}; // Add/update Tooltip on our element


var tooltip_applyTooltip = function applyTooltip(el, bindings, vnode) {
  if (!env["g" /* isBrowser */]) {
    /* istanbul ignore next */
    return;
  }

  var config = tooltip_parseBindings(bindings, vnode);

  if (!el[Nlya_TOOLTIP]) {
    var $parent = vnode.context;
    el[Nlya_TOOLTIP] = new NlyaTooltip({
      parent: $parent,
      // Add the parent's scoped style attribute data
      _scopeId: get_scope_id($parent, undefined)
    });
    el[Nlya_TOOLTIP].__nlya_prev_data__ = {};
    el[Nlya_TOOLTIP].$on("show", function ()
    /* istanbul ignore next: for now */
    {
      // Before showing the tooltip, we update the title if it is a function
      if (isFunction(config.title)) {
        el[Nlya_TOOLTIP].updateData({
          title: config.title(el)
        });
      }
    });
  }

  var data = {
    title: config.title,
    triggers: config.trigger,
    placement: config.placement,
    fallbackPlacement: config.fallbackPlacement,
    variant: config.variant,
    customClass: config.customClass,
    container: config.container,
    boundary: config.boundary,
    delay: config.delay,
    offset: config.offset,
    noFade: !config.animation,
    id: config.id,
    interactive: config.interactive,
    disabled: config.disabled,
    html: config.html
  };
  var oldData = el[Nlya_TOOLTIP].__nlya_prev_data__;
  el[Nlya_TOOLTIP].__nlya_prev_data__ = data;

  if (!loose_equal(data, oldData)) {
    // We only update the instance if data has changed
    var newData = {
      target: el
    };
    keys(data).forEach(function (prop) {
      // We only pass data properties that have changed
      if (data[prop] !== oldData[prop]) {
        // if title is a function, we execute it here
        newData[prop] = prop === "title" && isFunction(data[prop]) ? data[prop](el) : data[prop];
      }
    });
    el[Nlya_TOOLTIP].updateData(newData);
  }
}; // Remove Tooltip on our element


var removeTooltip = function removeTooltip(el) {
  if (el[Nlya_TOOLTIP]) {
    el[Nlya_TOOLTIP].$destroy();
    el[Nlya_TOOLTIP] = null;
  }

  delete el[Nlya_TOOLTIP];
}; // Export our directive


var VNlyTooltip = {
  bind: function bind(el, bindings, vnode) {
    tooltip_applyTooltip(el, bindings, vnode);
  },
  // We use `componentUpdated` here instead of `update`, as the former
  // waits until the containing component and children have finished updating
  componentUpdated: function componentUpdated(el, bindings, vnode) {
    // Performed in a `$nextTick()` to prevent render update loops
    vnode.context.$nextTick(function () {
      tooltip_applyTooltip(el, bindings, vnode);
    });
  },
  unbind: function unbind(el) {
    removeTooltip(el);
  }
};
// CONCATENATED MODULE: ./src/directives/tooltip/index.js


var VNlyTooltipPlugin = plugins_nlyPluginFactory({
  directives: {
    VNlyTooltip: VNlyTooltip
  }
});

// CONCATENATED MODULE: ./src/components/tooltip/index.js



var TooltipPlugin = plugins_nlyPluginFactory({
  components: {
    NlyTooltip: NlyTooltip
  },
  plugins: {
    VNlyTooltipPlugin: VNlyTooltipPlugin
  }
});

// CONCATENATED MODULE: ./src/components/render-function/index.js


var RenderFunctionPlugin = plugins_nlyPluginFactory({
  components: {
    NlyRenderFunction: NlyRenderFunction
  }
});

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.link.js
var es_string_link = __webpack_require__("9911");

// CONCATENATED MODULE: ./src/components/tabs/tabs.js






























 // -- Constants --

var navProps = object_omit(nav_props, ["tabs", "isNavBar", "cardHeader"]); // -- Utils --
// Filter function to filter out disabled tabs

var notDisabled = function notDisabled(tab) {
  return !tab.disabled;
}; // --- Helper components ---
// @vue/component


var BTabButtonHelper = /*#__PURE__*/utils_vue.extend({
  name: "BTabButtonHelper",
  inject: {
    nlyaTabls: {
      /* istanbul ignore next */
      default: function _default()
      /* istanbul ignore next */
      {
        return {};
      }
    }
  },
  props: {
    // Reference to the child <b-tab> instance
    tab: {
      default: null
    },
    tabs: {
      type: Array,

      /* istanbul ignore next */
      default: function _default()
      /* istanbul ignore next */
      {
        return [];
      }
    },
    id: {
      type: String,
      default: null
    },
    controls: {
      type: String,
      default: null
    },
    tabIndex: {
      type: Number,
      default: null
    },
    posInSet: {
      type: Number,
      default: null
    },
    setSize: {
      type: Number,
      default: null
    },
    noKeyNav: {
      type: Boolean,
      default: false
    }
  },
  methods: {
    focus: function focus() {
      if (this.$refs && this.$refs.link && this.$refs.link.focus) {
        this.$refs.link.focus();
      }
    },
    handleEvt: function handleEvt(evt) {
      var stop = function stop() {
        evt.preventDefault();
        evt.stopPropagation();
      };

      if (this.tab.disabled) {
        /* istanbul ignore next */
        return;
      }

      var type = evt.type;
      var key = evt.keyCode;
      var shift = evt.shiftKey;

      if (type === "click") {
        stop();
        this.$emit("click", evt);
      } else if (type === "keydown" && key === key_codes.SPACE) {
        // For ARIA tabs the SPACE key will also trigger a click/select
        // Even with keyboard navigation disabled, SPACE should "click" the button
        // See: https://github.com/bootstrap-vue/bootstrap-vue/issues/4323
        stop();
        this.$emit("click", evt);
      } else if (type === "keydown" && !this.noKeyNav) {
        // For keyboard navigation
        if (key === key_codes.UP || key === key_codes.LEFT || key === key_codes.HOME) {
          stop();

          if (shift || key === key_codes.HOME) {
            this.$emit("first", evt);
          } else {
            this.$emit("prev", evt);
          }
        } else if (key === key_codes.DOWN || key === key_codes.RIGHT || key === key_codes.END) {
          stop();

          if (shift || key === key_codes.END) {
            this.$emit("last", evt);
          } else {
            this.$emit("next", evt);
          }
        }
      }
    }
  },
  render: function render(h) {
    var link = h(NlyLink, {
      ref: "link",
      staticClass: "nav-link",
      class: [{
        active: this.tab.localActive && !this.tab.disabled,
        disabled: this.tab.disabled
      }, this.tab.titleLinkClass, // Apply <b-tabs> `activeNavItemClass` styles when the tab is active
      this.tab.localActive ? this.nlyaTabls.activeNavItemClass : null],
      props: {
        disabled: this.tab.disabled
      },
      attrs: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.tab.titleLinkAttributes), {}, {
        role: "tab",
        id: this.id,
        // Roving tab index when keynav enabled
        tabindex: this.tabIndex,
        "aria-selected": this.tab.localActive && !this.tab.disabled ? "true" : "false",
        "aria-setsize": this.setSize,
        "aria-posinset": this.posInSet,
        "aria-controls": this.controls
      }),
      on: {
        click: this.handleEvt,
        keydown: this.handleEvt
      }
    }, [this.tab.normalizeSlot("title") || this.tab.title]);
    return h("li", {
      staticClass: "nav-item",
      class: [this.tab.titleItemClass],
      attrs: {
        role: "presentation"
      }
    }, [link]);
  }
}); // @vue/component

var NlyTabs = /*#__PURE__*/utils_vue.extend({
  name: "NlyTabs",
  mixins: [mixins_id, mixins_normalize_slot],
  provide: function provide() {
    return {
      nlyaTabls: this
    };
  },
  model: {
    prop: "value",
    event: "input"
  },
  props: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, navProps), {}, {
    tag: {
      type: String,
      default: "div"
    },
    card: {
      type: Boolean,
      default: false
    },
    end: {
      // Synonym for 'bottom'
      type: Boolean,
      default: false
    },
    noFade: {
      type: Boolean,
      default: false
    },
    noNavStyle: {
      type: Boolean,
      default: false
    },
    noKeyNav: {
      type: Boolean,
      default: false
    },
    lazy: {
      // This prop is sniffed by the <b-tab> child
      type: Boolean,
      default: false
    },
    contentClass: {
      type: [String, Array, Object] // default: null

    },
    navClass: {
      type: [String, Array, Object] // default: null

    },
    navWrapperClass: {
      type: [String, Array, Object] // default: null

    },
    activeNavItemClass: {
      // Only applied to the currently active <b-nav-item>
      type: [String, Array, Object] // default: null

    },
    activeTabClass: {
      // Only applied to the currently active <b-tab>
      // This prop is sniffed by the <b-tab> child
      type: [String, Array, Object] // default: null

    },
    value: {
      // v-model
      type: Number,
      default: null
    }
  }),
  data: function data() {
    return {
      // Index of current tab
      currentTab: toInteger(this.value, -1),
      // Array of direct child <b-tab> instances, in DOM order
      tabs: [],
      // Array of child instances registered (for triggering reactive updates)
      registeredTabs: [],
      // Flag to know if we are mounted or not
      isMounted: false
    };
  },
  computed: {
    fade: function fade() {
      // This computed prop is sniffed by the tab child
      return !this.noFade;
    },
    localNavClass: function localNavClass() {
      var classes = [];

      if (this.card && this.vertical) {
        classes.push("card-header", "h-100", "border-bottom-0", "rounded-0");
      }

      return [].concat(classes, [this.navClass]);
    }
  },
  watch: {
    currentTab: function currentTab(newVal) {
      var index = -1; // Ensure only one tab is active at most

      this.tabs.forEach(function (tab, idx) {
        if (newVal === idx && !tab.disabled) {
          tab.localActive = true;
          index = idx;
        } else {
          tab.localActive = false;
        }
      }); // Update the v-model

      this.$emit("input", index);
    },
    value: function value(newVal, oldVal) {
      if (newVal !== oldVal) {
        newVal = toInteger(newVal, -1);
        oldVal = toInteger(oldVal, 0);
        var tabs = this.tabs;

        if (tabs[newVal] && !tabs[newVal].disabled) {
          this.activateTab(tabs[newVal]);
        } else {
          // Try next or prev tabs
          if (newVal < oldVal) {
            this.previousTab();
          } else {
            this.nextTab();
          }
        }
      }
    },
    registeredTabs: function registeredTabs() {
      var _this = this;

      // Each b-tab will register/unregister itself.
      // We use this to detect when tabs are added/removed
      // to trigger the update of the tabs.
      this.$nextTick(function () {
        requestAF(function () {
          _this.updateTabs();
        });
      });
    },
    tabs: function tabs(newVal, oldVal) {
      var _this2 = this;

      // If tabs added, removed, or re-ordered, we emit a `changed` event.
      // We use `tab._uid` instead of `tab.safeId()`, as the later is changed
      // in a nextTick if no explicit ID is provided, causing duplicate emits.
      if (!loose_equal(newVal.map(function (t) {
        return t._uid;
      }), oldVal.map(function (t) {
        return t._uid;
      }))) {
        // In a nextTick to ensure currentTab has been set first.
        this.$nextTick(function () {
          // We emit shallow copies of the new and old arrays of tabs, to
          // prevent users from potentially mutating the internal arrays.
          _this2.$emit("changed", newVal.slice(), oldVal.slice());
        });
      }
    },
    isMounted: function isMounted(newVal) {
      var _this3 = this;

      // Trigger an update after mounted.  Needed for tabs inside lazy modals.
      if (newVal) {
        requestAF(function () {
          _this3.updateTabs();
        });
      } // Enable or disable the observer


      this.setObserver(newVal);
    }
  },
  created: function created() {
    var _this4 = this;

    this.currentTab = toInteger(this.value, -1);
    this._nlyaObserver = null; // For SSR and to make sure only a single tab is shown on mount
    // We wrap this in a `$nextTick()` to ensure the child tabs have been created

    this.$nextTick(function () {
      _this4.updateTabs();
    });
  },
  mounted: function mounted() {
    var _this5 = this;

    // Call `updateTabs()` just in case...
    this.updateTabs();
    this.$nextTick(function () {
      // Flag we are now mounted and to switch to DOM for tab probing.
      // As this.$slots.default appears to lie about component instances
      // after b-tabs is destroyed and re-instantiated.
      // And this.$children does not respect DOM order.
      _this5.isMounted = true;
    });
  },

  /* istanbul ignore next */
  deactivated: function deactivated()
  /* istanbul ignore next */
  {
    this.isMounted = false;
  },

  /* istanbul ignore next */
  activated: function activated()
  /* istanbul ignore next */
  {
    var _this6 = this;

    this.currentTab = toInteger(this.value, -1);
    this.$nextTick(function () {
      _this6.updateTabs();

      _this6.isMounted = true;
    });
  },
  beforeDestroy: function beforeDestroy() {
    this.isMounted = false;
  },
  destroyed: function destroyed() {
    // Ensure no references to child instances exist
    this.tabs = [];
  },
  methods: {
    registerTab: function registerTab(tab) {
      var _this7 = this;

      if (!arrayIncludes(this.registeredTabs, tab)) {
        this.registeredTabs.push(tab);
        tab.$once("hook:destroyed", function () {
          _this7.unregisterTab(tab);
        });
      }
    },
    unregisterTab: function unregisterTab(tab) {
      this.registeredTabs = this.registeredTabs.slice().filter(function (t) {
        return t !== tab;
      });
    },
    setObserver: function setObserver(on) {
      // DOM observer is needed to detect changes in order of tabs
      if (on) {
        // Make sure no existing observer running
        this.setObserver(false);
        var self = this;
        /* istanbul ignore next: difficult to test mutation observer in JSDOM */

        var handler = function handler() {
          // We delay the update to ensure that `tab.safeId()` has
          // updated with the final ID value.
          self.$nextTick(function () {
            requestAF(function () {
              self.updateTabs();
            });
          });
        }; // Watch for changes to <b-tab> sub components


        this._nlyaObserver = observe_dom(this.$refs.tabsContainer, handler, {
          childList: true,
          subtree: false,
          attributes: true,
          attributeFilter: ["id"]
        });
      } else {
        if (this._nlyaObserver && this._nlyaObserver.disconnect) {
          this._nlyaObserver.disconnect();
        }

        this._nlyaObserver = null;
      }
    },
    getTabs: function getTabs() {
      // We use registeredTabs as the source of truth for child tab components. And we
      // filter out any BTab components that are extended BTab with a root child BTab.
      // https://github.com/bootstrap-vue/bootstrap-vue/issues/3260
      var tabs = this.registeredTabs.filter(function (tab) {
        return tab.$children.filter(function (t) {
          return t._isTab;
        }).length === 0;
      }); // DOM Order of Tabs

      var order = [];

      if (this.isMounted && tabs.length > 0) {
        // We rely on the DOM when mounted to get the 'true' order of the b-tab children.
        // querySelectorAll(...) always returns elements in document order, regardless of
        // order specified in the selector.
        var selector = tabs.map(function (tab) {
          return "#".concat(tab.safeId());
        }).join(", ");
        order = dom_selectAll(selector, this.$el).map(function (el) {
          return el.id;
        }).filter(utils_identity);
      } // Stable sort keeps the original order if not found in the
      // `order` array, which will be an empty array before mount.


      return stable_sort(tabs, function (a, b) {
        return order.indexOf(a.safeId()) - order.indexOf(b.safeId());
      });
    },
    // Update list of <b-tab> children
    updateTabs: function updateTabs() {
      // Probe tabs
      var tabs = this.getTabs(); // Find *last* active non-disabled tab in current tabs
      // We trust tab state over currentTab, in case tabs were added/removed/re-ordered

      var tabIndex = tabs.indexOf(tabs.slice().reverse().find(function (tab) {
        return tab.localActive && !tab.disabled;
      })); // Else try setting to currentTab

      if (tabIndex < 0) {
        var currentTab = this.currentTab;

        if (currentTab >= tabs.length) {
          // Handle last tab being removed, so find the last non-disabled tab
          tabIndex = tabs.indexOf(tabs.slice().reverse().find(notDisabled));
        } else if (tabs[currentTab] && !tabs[currentTab].disabled) {
          // Current tab is not disabled
          tabIndex = currentTab;
        }
      } // Else find *first* non-disabled tab in current tabs


      if (tabIndex < 0) {
        tabIndex = tabs.indexOf(tabs.find(notDisabled));
      } // Set the current tab state to active


      tabs.forEach(function (tab) {
        // tab.localActive = idx === tabIndex && !tab.disabled
        tab.localActive = false;
      });

      if (tabs[tabIndex]) {
        tabs[tabIndex].localActive = true;
      } // Update the array of tab children


      this.tabs = tabs; // Set the currentTab index (can be -1 if no non-disabled tabs)

      this.currentTab = tabIndex;
    },
    // Find a button that controls a tab, given the tab reference
    // Returns the button vm instance
    getButtonForTab: function getButtonForTab(tab) {
      return (this.$refs.buttons || []).find(function (btn) {
        return btn.tab === tab;
      });
    },
    // Force a button to re-render its content, given a <b-tab> instance
    // Called by <b-tab> on `update()`
    updateButton: function updateButton(tab) {
      var button = this.getButtonForTab(tab);

      if (button && button.$forceUpdate) {
        button.$forceUpdate();
      }
    },
    // Activate a tab given a <b-tab> instance
    // Also accessed by <b-tab>
    activateTab: function activateTab(tab) {
      var result = false;

      if (tab) {
        var index = this.tabs.indexOf(tab);

        if (!tab.disabled && index > -1 && index !== this.currentTab) {
          var tabEvt = new nly_event_class_NlyEvent("activate-tab", {
            cancelable: true,
            vueTarget: this,
            componentId: this.safeId()
          });
          this.$emit(tabEvt.type, index, this.currentTab, tabEvt);

          if (!tabEvt.defaultPrevented) {
            result = true;
            this.currentTab = index;
          }
        }
      } // Couldn't set tab, so ensure v-model is set to `this.currentTab`

      /* istanbul ignore next: should rarely happen */


      if (!result && this.currentTab !== this.value) {
        this.$emit("input", this.currentTab);
      }

      return result;
    },
    // Deactivate a tab given a <b-tab> instance
    // Accessed by <b-tab>
    deactivateTab: function deactivateTab(tab) {
      if (tab) {
        // Find first non-disabled tab that isn't the one being deactivated
        // If no tabs are available, then don't deactivate current tab
        return this.activateTab(this.tabs.filter(function (t) {
          return t !== tab;
        }).find(notDisabled));
      }
      /* istanbul ignore next: should never/rarely happen */


      return false;
    },
    // Focus a tab button given its <b-tab> instance
    focusButton: function focusButton(tab) {
      var _this8 = this;

      // Wrap in `$nextTick()` to ensure DOM has completed rendering/updating before focusing
      this.$nextTick(function () {
        var button = _this8.getButtonForTab(tab);

        if (button && button.focus) {
          button.focus();
        }
      });
    },
    // Emit a click event on a specified <b-tab> component instance
    emitTabClick: function emitTabClick(tab, evt) {
      if (isEvent(evt) && tab && tab.$emit && !tab.disabled) {
        tab.$emit("click", evt);
      }
    },
    // Click handler
    clickTab: function clickTab(tab, evt) {
      this.activateTab(tab);
      this.emitTabClick(tab, evt);
    },
    // Move to first non-disabled tab
    firstTab: function firstTab(focus) {
      var tab = this.tabs.find(notDisabled);

      if (this.activateTab(tab) && focus) {
        this.focusButton(tab);
        this.emitTabClick(tab, focus);
      }
    },
    // Move to previous non-disabled tab
    previousTab: function previousTab(focus) {
      var currentIndex = mathMax(this.currentTab, 0);
      var tab = this.tabs.slice(0, currentIndex).reverse().find(notDisabled);

      if (this.activateTab(tab) && focus) {
        this.focusButton(tab);
        this.emitTabClick(tab, focus);
      }
    },
    // Move to next non-disabled tab
    nextTab: function nextTab(focus) {
      var currentIndex = mathMax(this.currentTab, -1);
      var tab = this.tabs.slice(currentIndex + 1).find(notDisabled);

      if (this.activateTab(tab) && focus) {
        this.focusButton(tab);
        this.emitTabClick(tab, focus);
      }
    },
    // Move to last non-disabled tab
    lastTab: function lastTab(focus) {
      var tab = this.tabs.slice().reverse().find(notDisabled);

      if (this.activateTab(tab) && focus) {
        this.focusButton(tab);
        this.emitTabClick(tab, focus);
      }
    }
  },
  render: function render(h) {
    var _this9 = this;

    var tabs = this.tabs; // Currently active tab

    var activeTab = tabs.find(function (tab) {
      return tab.localActive && !tab.disabled;
    }); // Tab button to allow focusing when no active tab found (keynav only)

    var fallbackTab = tabs.find(function (tab) {
      return !tab.disabled;
    }); // For each <b-tab> found create the tab buttons

    var buttons = tabs.map(function (tab, index) {
      var tabIndex = null; // Ensure at least one tab button is focusable when keynav enabled (if possible)

      if (!_this9.noKeyNav) {
        // Buttons are not in tab index unless active, or a fallback tab
        tabIndex = -1;

        if (activeTab === tab || !activeTab && fallbackTab === tab) {
          // Place tab button in tab sequence
          tabIndex = null;
        }
      }

      return h(BTabButtonHelper, {
        key: tab._uid || index,
        ref: "buttons",
        // Needed to make `this.$refs.buttons` an array
        refInFor: true,
        props: {
          tab: tab,
          tabs: tabs,
          id: tab.controlledBy || (tab.safeId ? tab.safeId("_NLYA_tab_button_") : null),
          controls: tab.safeId ? tab.safeId() : null,
          tabIndex: tabIndex,
          setSize: tabs.length,
          posInSet: index + 1,
          noKeyNav: _this9.noKeyNav
        },
        on: {
          click: function click(evt) {
            _this9.clickTab(tab, evt);
          },
          first: _this9.firstTab,
          prev: _this9.previousTab,
          next: _this9.nextTab,
          last: _this9.lastTab
        }
      });
    }); // Nav

    var nav = h(NlyNav, {
      ref: "nav",
      class: this.localNavClass,
      attrs: {
        role: "tablist",
        id: this.safeId("_NLYA_tab_controls_")
      },
      props: {
        fill: this.fill,
        justified: this.justified,
        align: this.align,
        tabs: !this.noNavStyle && !this.pills,
        pills: !this.noNavStyle && this.pills,
        vertical: this.vertical,
        small: this.small,
        cardHeader: this.card && !this.vertical
      }
    }, [this.normalizeSlot("tabs-start") || h(), buttons, this.normalizeSlot("tabs-end") || h()]);
    nav = h("div", {
      key: "nlya-tabs-nav",
      class: [{
        "card-header": this.card && !this.vertical && !this.end,
        "card-footer": this.card && !this.vertical && this.end,
        "col-auto": this.vertical
      }, this.navWrapperClass]
    }, [nav]);
    var empty = h();

    if (!tabs || tabs.length === 0) {
      empty = h("div", {
        key: "nlya-empty-tab",
        class: ["tab-pane", "active", {
          "card-body": this.card
        }]
      }, this.normalizeSlot("empty"));
    } // Main content section


    var content = h("div", {
      ref: "tabsContainer",
      key: "nly-tabs-container",
      staticClass: "tab-content",
      class: [{
        col: this.vertical
      }, this.contentClass],
      attrs: {
        id: this.safeId("_NLY_tab_container_")
      }
    }, concat(this.normalizeSlot("default"), empty)); // Render final output

    return h(this.tag, {
      staticClass: "tabs",
      class: {
        row: this.vertical,
        "no-gutters": this.vertical && this.card
      },
      attrs: {
        id: this.safeId()
      }
    }, [this.end ? content : h(), [nav], this.end ? h() : content]);
  }
});
// CONCATENATED MODULE: ./src/components/tabs/tab.js



 // @vue/component

var NlyTab = /*#__PURE__*/utils_vue.extend({
  name: "NlyTab",
  mixins: [mixins_id, mixins_normalize_slot],
  inject: {
    nlyaTabls: {
      default: function _default() {
        return {};
      }
    }
  },
  props: {
    active: {
      type: Boolean,
      default: false
    },
    tag: {
      type: String,
      default: "div"
    },
    buttonId: {
      type: String // default: ''

    },
    title: {
      type: String,
      default: ""
    },
    titleItemClass: {
      // Sniffed by tabs.js and added to nav 'li.nav-item'
      type: [String, Array, Object] // default: null

    },
    titleLinkClass: {
      // Sniffed by tabs.js and added to nav 'a.nav-link'
      type: [String, Array, Object] // default: null

    },
    titleLinkAttributes: {
      type: Object // default: null

    },
    disabled: {
      type: Boolean,
      default: false
    },
    noBody: {
      type: Boolean,
      default: false
    },
    lazy: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      localActive: this.active && !this.disabled,
      show: false
    };
  },
  computed: {
    tabClasses: function tabClasses() {
      return [{
        active: this.localActive,
        disabled: this.disabled,
        "card-body": this.nlyaTabls.card && !this.noBody
      }, // Apply <b-tabs> `activeTabClass` styles when this tab is active
      this.localActive ? this.nlyaTabls.activeTabClass : null];
    },
    controlledBy: function controlledBy() {
      return this.buttonId || this.safeId("__Nly_tab_button__");
    },
    computedNoFade: function computedNoFade() {
      return !(this.nlyaTabls.fade || false);
    },
    computedLazy: function computedLazy() {
      return this.nlyaTabls.lazy || this.lazy;
    },
    _isTab: function _isTab() {
      // For parent sniffing of child
      return true;
    }
  },
  watch: {
    localActive: function localActive(newVal) {
      // Make 'active' prop work with `.sync` modifier
      this.$emit("update:active", newVal);
    },
    active: function active(newVal, oldVal) {
      if (newVal !== oldVal) {
        if (newVal) {
          // If activated post mount
          this.activate();
        } else {
          /* istanbul ignore next */
          if (!this.deactivate()) {
            // Tab couldn't be deactivated, so we reset the synced active prop
            // Deactivation will fail if no other tabs to activate
            this.$emit("update:active", this.localActive);
          }
        }
      }
    },
    disabled: function disabled(newVal, oldVal) {
      if (newVal !== oldVal) {
        if (newVal && this.localActive && this.nlyaTabls.firstTab) {
          this.localActive = false;
          this.nlyaTabls.firstTab();
        }
      }
    }
  },
  mounted: function mounted() {
    // Inform b-tabs of our presence
    this.registerTab(); // Initially show on mount if active and not disabled

    this.show = this.localActive;
  },
  updated: function updated() {
    // Force the tab button content to update (since slots are not reactive)
    // Only done if we have a title slot, as the title prop is reactive
    if (this.hasNormalizedSlot("title") && this.nlyaTabls.updateButton) {
      this.nlyaTabls.updateButton(this);
    }
  },
  destroyed: function destroyed() {
    // inform b-tabs of our departure
    this.unregisterTab();
  },
  methods: {
    // Private methods
    registerTab: function registerTab() {
      // Inform `b-tabs` of our presence
      this.nlyaTabls.registerTab && this.nlyaTabls.registerTab(this);
    },
    unregisterTab: function unregisterTab() {
      // Inform `b-tabs` of our departure
      this.nlyaTabls.unregisterTab && this.nlyaTabls.unregisterTab(this);
    },
    // Public methods
    activate: function activate() {
      if (this.nlyaTabls.activateTab && !this.disabled) {
        return this.nlyaTabls.activateTab(this);
      } else {
        // Not inside a <b-tabs> component or tab is disabled
        return false;
      }
    },
    deactivate: function deactivate() {
      if (this.nlyaTabls.deactivateTab && this.localActive) {
        return this.nlyaTabls.deactivateTab(this);
      } else {
        // Not inside a <b-tabs> component or not active to begin with
        return false;
      }
    }
  },
  render: function render(h) {
    var content = h(this.tag, {
      ref: "panel",
      staticClass: "tab-pane",
      class: this.tabClasses,
      directives: [{
        name: "show",
        rawName: "v-show",
        value: this.localActive,
        expression: "localActive"
      }],
      attrs: {
        role: "tabpanel",
        id: this.safeId(),
        "aria-hidden": this.localActive ? "false" : "true",
        "aria-labelledby": this.controlledBy || null
      }
    }, // Render content lazily if requested
    [this.localActive || !this.computedLazy ? this.normalizeSlot("default") : h()]);
    return h(nly_toast_transition, {
      props: {
        mode: "out-in",
        noFade: this.computedNoFade
      }
    }, [content]);
  }
});
// CONCATENATED MODULE: ./src/components/tabs/index.js



var TabsPlugin = plugins_nlyPluginFactory({
  components: {
    NlyTabs: NlyTabs,
    NlyTab: NlyTab
  }
});

// CONCATENATED MODULE: ./src/components/wrapper/wrapper.js






var wrapper_name = "NlyWrapper";
var NlyWrapper = utils_vue.extend({
  name: wrapper_name,
  props: {
    //边侧栏最小化
    sideMini: {
      type: Boolean,
      default: false
    },
    //layout fixed or boxed
    layout: {
      type: String
    },
    // navbar fixed
    navbarFixed: {
      type: Boolean,
      default: false
    },
    //footer fixed
    footerFixed: {
      type: Boolean,
      default: false
    },
    //top nav
    topNav: {
      type: Boolean,
      default: false
    },
    wrapperClass: {
      type: String
    },
    containerClass: {
      type: String
    }
  },
  computed: {
    breakPointNumber: function breakPointNumber() {
      return nlyGetOptionsByKeyEqual(breakPointOptions, this.breakPoint);
    },
    sideMiniClass: function sideMiniClass() {
      return this.sideMini ? "sidebar-mini" : "";
    },
    layoutClass: function layoutClass() {
      return this.layout == "fixed" ? "layout-fixed" : this.layout ? "layout-boxed" : "";
    },
    navbarFixedClass: function navbarFixedClass() {
      return this.navbarFixed ? "layout-navbar-fixed" : "";
    },
    footerFixedClass: function footerFixedClass() {
      return this.footerFixed ? "layout-footer-fixed" : "";
    },
    topNavClass: function topNavClass() {
      return this.topNav ? "layout-top-nav" : "";
    },
    containerWrapperClass: function containerWrapperClass() {
      return this.wrapperClass;
    },
    containerBodyClass: function containerBodyClass() {
      return this.containerClass;
    }
  },
  methods: {
    setBodyCollapseClassName: function setBodyCollapseClassName() {
      if (this.sideMini) {
        var bodyWidth = document.body.clientWidth;
        var bodyClassName = document.body.className;

        if (bodyWidth < 992) {
          if (bodyClassName.indexOf("sidebar-collapse") == -1) {
            document.body.classList.add("sidebar-collapse");
          }
        } else {
          if (bodyClassName.indexOf("sidebar-open") !== -1) {
            document.body.classList.remove("sidebar-open");
          }
        }
      }
    },
    setBodyClassName: function setBodyClassName(newval, oldval) {
      if (newval != oldval) {
        if (newval && oldval) {
          document.body.classList.add(newval);
          document.body.classList.remove(oldval);
        } else if (newval && oldval == "") {
          document.body.classList.add(newval);
        } else if (newval == "" && oldval) {
          document.body.classList.remove(oldval);
        }
      }
    }
  },
  mounted: function mounted() {
    var _this = this;

    window.addEventListener("resize", function () {
      return _this.setBodyCollapseClassName();
    }, false);
  },
  created: function created() {
    var createdBodyClassList = [this.sideMiniClass, this.layoutClass, this.navbarFixedClass, this.footerFixed, this.topNavClass, this.containerBodyClass];
    createdBodyClassList.forEach(function (item) {
      if (item) {
        document.body.classList.add(item);
      }
    });
    this.setBodyCollapseClassName();
  },
  beforeDestroy: function beforeDestroy() {
    window.removeEventListener("resize", this.setBodyCollapseClassName(), false);
  },
  watch: {
    sideMiniClass: function sideMiniClass(newval, oldval) {
      this.setBodyClassName(newval, oldval);
    },
    layoutClass: function layoutClass(newval, oldval) {
      this.setBodyClassName(newval, oldval);
    },
    navbarFixedClass: function navbarFixedClass(newval, oldval) {
      this.setBodyClassName(newval, oldval);
    },
    footerFixedClass: function footerFixedClass(newval, oldval) {
      this.setBodyClassName(newval, oldval);
    },
    topNavClass: function topNavClass(newval, oldval) {
      this.setBodyClassName(newval, oldval);
    },
    containerBodyClass: function containerBodyClass(newval, oldval) {
      this.setBodyClassName(newval, oldval);
    },
    containerWrapperClass: function containerWrapperClass(newval, oldval) {
      this.setBodyClassName(newval, oldval);
    }
  },
  render: function render(h) {
    return h("div", {
      staticClass: "wrapper",
      class: [this.containerWrapperClass]
    }, this.$slots.default);
  }
});
// CONCATENATED MODULE: ./src/components/wrapper/wrapper-footer.js




var wrapper_footer_props = {
  size: {
    type: String
  },
  bgVariant: {
    type: String
  },
  bgGradientVariant: {
    type: String
  },
  wrapperFooterClass: {
    type: String
  },
  tag: {
    type: String,
    default: "footer"
  }
};

var wrapper_footer_customClass = function customClass(props) {
  var size = props.size == "sm" ? "text-sm" : props.size == "lg" ? "text-lg" : "";

  var bgVariant = function bgVariant() {
    return nlyGetOptionsByKeyEqual(bgVariantOptions, props.bgVariant);
  };

  var bgGradientVariant = function bgGradientVariant() {
    return nlyGetOptionsByKeyEqual(bgGradientOptions, props.bgGradientVariant);
  };

  var mainFooterClass = props.mainFooterClass;
  return [size, bgVariant(), bgGradientVariant(), mainFooterClass];
};

var wrapper_footer_name = "NlyWrapperFooter";
var NlyWrapperFooter = utils_vue.extend({
  name: wrapper_footer_name,
  props: wrapper_footer_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "main-footer",
      class: wrapper_footer_customClass(props)
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/wrapper/wrapper-header.js




var wrapper_header_props = {
  expand: {
    type: String
  },
  variant: {
    type: String,
    default: "white"
  },
  dark: {
    type: Boolean,
    default: false
  },
  size: {
    type: String,
    default: ""
  },
  border: {
    type: Boolean,
    default: true
  },
  wrapperHeaderClass: {
    type: String
  },
  tag: {
    type: String,
    default: "header"
  },
  nav: {
    type: Boolean,
    default: false
  }
};

var wrapper_header_customClass = function customClass(props) {
  var customNavbarExpand = function customNavbarExpand() {
    if (props.nav) {
      return props.expand == "xl" ? "navbar-expand-xl" : props.expand == "lg" ? "navbar-expand-lg" : props.expand == "md" ? "navbar-expand-md" : props.expand == "sm" ? "navbar-expand-sm" : props.expand == "no" ? "navbar-no-expand" : props.expand == "expand" ? "navbar-expand" : "";
    } else {
      return "";
    }
  };

  var customnNvbarVariant = function customnNvbarVariant() {
    if (props.nav) {
      return nlyGetOptionsByKeyEqual(navbarVariantOpitons, props.variant);
    } else {
      return "";
    }
  };

  var customNavbarFontSize = function customNavbarFontSize() {
    if (props.nav) {
      return nlyGetOptionsByKeyEqual(textSizeOptions, props.size);
    } else {
      return "";
    }
  };

  var customNavbarBorder = function customNavbarBorder() {
    if (props.nav) {
      return props.border ? "" : "border-bottom-0";
    } else {
      return "";
    }
  };

  var customWrapperHeaderClass = function customWrapperHeaderClass() {
    return props.wrapperHeaderClass;
  };

  var customNavbarDark = function customNavbarDark() {
    if (props.nav) {
      return props.dark ? "navbar-dark" : "navbar-light";
    } else {
      return "";
    }
  };

  return [customNavbarExpand(), customnNvbarVariant(), customNavbarFontSize(), customNavbarBorder(), customWrapperHeaderClass(), customNavbarDark()];
};

var wrapper_header_name = "NlyWrapperHeader";
var NlyWrapperHeader = utils_vue.extend({
  name: wrapper_header_name,
  props: wrapper_header_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.nav ? "nav" : props.tag, lib_esm_a(data, {
      staticClass: props.nav ? "navbar" : "main-header",
      class: wrapper_header_customClass(props)
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/wrapper/wrapper-sidebar.js




var wrapper_sidebar_props = {
  variant: {
    type: String,
    default: "darkPrimary"
  },
  hover: {
    type: Boolean,
    default: true
  },
  elevation: {
    type: String,
    default: "xl"
  },
  tag: {
    type: String,
    default: "aside"
  },
  wrapperSidebarClass: {
    type: String
  }
};

var wrapper_sidebar_customClass = function customClass(props) {
  var customVariant = function customVariant() {
    return nlyGetOptionsByKeyEqual(sidebarContainerVariantOpitons, props.variant);
  };

  var customHover = props.hover ? "" : "sidebar-no-expand";

  var customElevation = function customElevation() {
    return nlyGetOptionsByKeyEqual(sidebarElevationOptions, props.elevation);
  };

  return [customVariant(), customHover, customElevation(), props.wrapperSidebarClass];
};

var wrapper_sidebar_name = "NlyWrapperSidebar";
var NlyWrapperSidebar = utils_vue.extend({
  name: wrapper_sidebar_name,
  props: wrapper_sidebar_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "main-sidebar",
      class: wrapper_sidebar_customClass(props)
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/wrapper/wrapper-control-sidebar.js





var wrapper_control_sidebar_props = {
  light: {
    type: Boolean,
    default: false
  },
  bgVariant: {
    type: String
  },
  bgGradientVariant: {
    type: String
  },
  size: {
    type: String
  },
  wrapperControlSidebarClass: {
    type: String
  },
  tag: {
    type: String,
    default: "aside"
  }
};

var wrapper_control_sidebar_customClass = function customClass(props) {
  var light = function light() {
    if (!props.bgVariant && !props.bgGradientVariant) {
      return props.light ? "control-sidebar-light" : "control-sidebar-dark";
    } else {
      return null;
    }
  };

  var bgVariant = function bgVariant() {
    return !props.bgGradientVariant ? nlyGetOptionsByKeyEqual(bgVariantOptions, props.bgVariant) : null;
  };

  var bgGradientVariant = function bgGradientVariant() {
    return nlyGetOptionsByKeyEqual(bgGradientOptions, props.bgGradientVariant);
  };

  var size = function size() {
    return props.size ? nlyGetOptionsByKeyEqual(textSizeOptions, props.size) : "";
  };

  return [light(), bgVariant(), bgGradientVariant(), size(), props.controlSidebarContainerClass];
};

var wrapper_control_sidebar_name = "NlyWrapperControlSidebar";
var NlyWrapperControlSidebar = utils_vue.extend({
  name: wrapper_control_sidebar_name,
  props: wrapper_control_sidebar_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "control-sidebar",
      class: wrapper_control_sidebar_customClass(props)
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/wrapper/wrapper-content.js


var wrapper_content_props = {
  tag: {
    type: String,
    default: "section"
  }
};
var wrapper_content_name = "NlyWrapperContent";
var NlyWrapperContent = utils_vue.extend({
  name: wrapper_content_name,
  props: wrapper_content_props,
  functional: true,
  render: function render(h, _ref) {
    var props = _ref.props,
        data = _ref.data,
        children = _ref.children;
    return h(props.tag, lib_esm_a(data, {
      staticClass: "content-wrapper"
    }), children);
  }
});
// CONCATENATED MODULE: ./src/components/wrapper/index.js









var WrapperPlugin = plugins_nlyPluginFactory({
  components: {
    NlyWrapper: NlyWrapper,
    NlyWrapperFooter: NlyWrapperFooter,
    NlyWrapperHeader: NlyWrapperHeader,
    NlyWrapperSidebar: NlyWrapperSidebar,
    NlyWrapperControlSidebar: NlyWrapperControlSidebar,
    NlyWrapperContent: NlyWrapperContent,
    directives: {
      VNlyControlSidebarCollapse: VNlyControlSidebarCollapse,
      VNlySidebarCollapse: VNlySidebarCollapse
    }
  }
});

// CONCATENATED MODULE: ./src/components/index.js











































var componentsPlugin = plugins_nlyPluginFactory({
  plugins: {
    BadgePlugin: BadgePlugin,
    BootstrapPaginationPlugin: BootstrapPaginationPlugin,
    BreadcrumbPlugin: BreadcrumbPlugin,
    ButtonPlugin: ButtonPlugin,
    ButtonGroupPlugin: ButtonGroupPlugin,
    CardPlugin: CardPlugin,
    CollapsePlugin: CollapsePlugin,
    ContainerPlugin: ContainerPlugin,
    ContentPlugin: ContentPlugin,
    ControlSidebarPlugin: ControlSidebarPlugin,
    DropdownPlugin: DropdownPlugin,
    FormCheckboxPlugin: FormCheckboxPlugin,
    FormDaterangepickerPlugin: FormDaterangepickerPlugin,
    FormPlugin: FormPlugin,
    FormGroupPlugin: FormGroupPlugin,
    FormInputPlugin: FormInputPlugin,
    FormRadioPlugin: FormRadioPlugin,
    FormSelectPlugin: FormSelectPlugin,
    GridPlugin: GridPlugin,
    InputGroupoPlugin: InputGroupoPlugin,
    TablePlugin: TablePlugin,
    WrapperPlugin: WrapperPlugin,
    LinkPlugin: LinkPlugin,
    ListGroupPlugin: ListGroupPlugin,
    NavPlugin: NavPlugin,
    NavbarPlugin: NavbarPlugin,
    OverlayPlugin: OverlayPlugin,
    SidebarPlugin: SidebarPlugin,
    switchPlugin: switchPlugin,
    toastPlugin: toastPlugin,
    SearchSelectPlugin: SearchSelectPlugin,
    SpinnerPlugin: SpinnerPlugin,
    ProgressPlugin: ProgressPlugin,
    PopoverPlugin: PopoverPlugin,
    timelinePlugin: timelinePlugin,
    InfoboxPlugin: InfoboxPlugin,
    TooltipPlugin: TooltipPlugin,
    RenderFunctionPlugin: RenderFunctionPlugin,
    PaginationPlugin: PaginationPlugin,
    LogPlugin: LogPlugin,
    ModalPlugin: ModalPlugin,
    TabsPlugin: TabsPlugin
  }
});
// CONCATENATED MODULE: ./src/utils/card.js


var changeBeforeIcon = function changeBeforeIcon(childrenList, icon, order) {
  if (childrenList) {
    if (icon) {
      if (order) {
        childrenList[order - 1].elm.className = icon;
      } else {
        if (childrenList[0].componentInstance.$options._componentTag == "nly-icon") {
          childrenList[0].elm.className = icon;
        }
      }
    }
  }
};
var changeAfterIcon = function changeAfterIcon(childrenList, icon, order) {
  if (childrenList) {
    if (icon) {
      if (order) {
        childrenList[order - 1].elm.className = icon;
      } else {
        if (childrenList[0].componentInstance.$options._componentTag == "nly-icon") {
          childrenList[0].elm.className = icon;
        }
      }
    }
  }
};
var beforeLeaveCollpase = function beforeLeaveCollpase(el) {
  if (!el.dataset) el.dataset = {};
  el.dataset.oldPaddingTop = el.style.paddingTop;
  el.dataset.oldPaddingBottom = el.style.paddingBottom;
  el.dataset.oldOverflow = el.style.overflow;
  el.style.height = el.scrollHeight + "px";
  el.style.overflow = "hidden";
};
var leaveCollpase = function leaveCollpase(el) {
  if (el.scrollHeight !== 0) {
    el.style.transition = "all 0.5s";
    el.style.height = 0;
    el.style.paddingTop = 0;
    el.style.paddingBottom = 0;
  }
};
var afterLeaveCollpase = function afterLeaveCollpase(el) {
  el.style.transition = "";
  el.style.height = "";
  el.style.overflow = el.dataset.oldOverflow;
  el.style.paddingTop = el.dataset.oldPaddingTop;
  el.style.paddingBottom = el.dataset.oldPaddingBottom;
};
var addClassNameCollpase = function addClassNameCollpase(el) {
  el.classList.add("collapsed-card");
};
function collpaseTransiton(_x) {
  return _collpaseTransiton.apply(this, arguments);
}

function _collpaseTransiton() {
  _collpaseTransiton = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(el) {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return beforeLeaveCollpase(el);

          case 2:
            _context.next = 4;
            return leaveCollpase(el);

          case 4:
            _context.next = 6;
            return afterLeaveCollpase(el);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _collpaseTransiton.apply(this, arguments);
}
// CONCATENATED MODULE: ./src/directives/card/maximized-card.js





var VNlyCardMaximized = {
  bind: function bind(el, binding, vnode) {
    var cardMaximizedId = nlyCardId(Object.keys(binding.modifiers)[0]);

    el.onclick = function () {
      if (binding.value !== undefined) {
        var beforeIcon = binding.value.beforeIcon || null;
        var afterIcon = binding.value.afterIcon || null;
        var order = toInteger(binding.value.order);
        var componentInstanceChildren = vnode.children;
        var cardMaximizedDom = document.querySelector("#".concat(cardMaximizedId));
        var htmlDom = document.querySelector("html");
        var cardMaximizedDomOffsetHeight = cardMaximizedDom.offsetHeight;
        var cardMaximizedDomOffsetWidth = cardMaximizedDom.offsetWidth;

        if (cardMaximizedDom.className.indexOf("maximized-card") == -1) {
          cardMaximizedDom.style.transition = "all 0.15s ease 0s";
          cardMaximizedDom.style.height = "".concat(cardMaximizedDomOffsetHeight, "PX");
          cardMaximizedDom.style.width = "".concat(cardMaximizedDomOffsetWidth, "px");
          changeBeforeIcon(componentInstanceChildren, afterIcon, order);
          setTimeout(function () {
            cardMaximizedDom.classList.add("maximized-card");
            htmlDom.classList.add("maximized-card");
          }, 20);
        } else {
          cardMaximizedDom.style.transition = "all 0.15s ease 0s";
          cardMaximizedDom.style.height = "inherit";
          cardMaximizedDom.style.width = "inherit";
          changeAfterIcon(componentInstanceChildren, beforeIcon, order);
          setTimeout(function () {
            cardMaximizedDom.classList.remove("maximized-card");
            htmlDom.classList.remove("maximized-card");
          }, 20);
        }
      } else {
        var _cardMaximizedDom = document.querySelector("#".concat(cardMaximizedId));

        var _htmlDom = document.querySelector("html");

        var _cardMaximizedDomOffsetHeight = _cardMaximizedDom.offsetHeight;
        var _cardMaximizedDomOffsetWidth = _cardMaximizedDom.offsetWidth;

        if (_cardMaximizedDom.className.indexOf("maximized-card") == -1) {
          _cardMaximizedDom.style.transition = "all 0.15s ease 0s";
          _cardMaximizedDom.style.height = "".concat(_cardMaximizedDomOffsetHeight, "PX");
          _cardMaximizedDom.style.width = "".concat(_cardMaximizedDomOffsetWidth, "px");
          setTimeout(function () {
            _cardMaximizedDom.classList.add("maximized-card");

            _htmlDom.classList.add("maximized-card");
          }, 20);
        } else {
          _cardMaximizedDom.style.transition = "all 0.15s ease 0s";
          _cardMaximizedDom.style.height = "inherit";
          _cardMaximizedDom.style.width = "inherit";
          setTimeout(function () {
            _cardMaximizedDom.classList.remove("maximized-card");

            _htmlDom.classList.remove("maximized-card");
          }, 20);
        }
      }
    };
  }
};
// CONCATENATED MODULE: ./src/directives/card/collapse-card.js




// import { nlyCardId } from "../../utils/mixin-id";
// import { toInteger } from "../../utils/number";
// import {
//   beforeLeaveCollpase,
//   leaveCollpase,
//   afterLeaveCollpase
// } from "../../utils/card";
var VNlyCardCollapse = {
  bind: function bind(el, binding, vnode) {
    var cardCollapseRef = Object.keys(binding.modifiers)[0];

    el.onclick = function () {
      var cardVnode = vnode.context.$refs[cardCollapseRef];
      var cardVnodeChildren = cardVnode.$children;

      if (cardVnode.$el.className.indexOf("collapsed-card") != -1) {
        cardVnodeChildren.forEach(function (item) {
          var itemEl = item.$el;

          if (item.$options._componentTag != "nly-card-header") {
            itemEl.style.transition = "all 0.5s";
            if (!itemEl.dataset) itemEl.dataset = {};
            itemEl.dataset.oldPaddingTop = itemEl.style.paddingTop;
            itemEl.dataset.oldPaddingBottom = itemEl.style.paddingBottom;
            itemEl.style.height = 0;
            itemEl.style.paddingTop = 0;
            itemEl.style.paddingBottom = 0;
            itemEl.dataset.oldOverflow = itemEl.style.overflow;
            itemEl.style.display = "block";

            if (itemEl.scrollHeight !== 0) {
              itemEl.style.height = itemEl.scrollHeight + "px";
              itemEl.style.paddingTop = itemEl.dataset.oldPaddingTop;
              itemEl.style.paddingBottom = itemEl.dataset.oldPaddingBottom;
            } else {
              itemEl.style.height = "";
              itemEl.style.paddingTop = itemEl.dataset.oldPaddingTop;
              itemEl.style.paddingBottom = itemEl.dataset.oldPaddingBottom;
            }

            itemEl.style.overflow = "hidden";
            setTimeout(function () {
              itemEl.style.transition = "";
              itemEl.style.height = "";
              itemEl.style.overflow = itemEl.dataset.oldOverflow;
              itemEl.style.display = "";
            }, 500);
          }

          setTimeout(function () {
            cardVnode.$el.classList.remove("collapsed-card");
          }, 500);
        });
      } else {
        cardVnodeChildren.forEach(function (item) {
          var itemEl = item.$el;

          if (item.$options._componentTag != "nly-card-header") {
            itemEl.dataset.oldPaddingTop = itemEl.style.paddingTop;
            itemEl.dataset.oldPaddingBottom = itemEl.style.paddingBottom;
            itemEl.dataset.oldOverflow = itemEl.style.overflow;
            itemEl.style.height = itemEl.scrollHeight + "px";
            itemEl.style.overflow = "hidden";

            if (itemEl.scrollHeight !== 0) {
              itemEl.style.transition = "all 0.5s";
              itemEl.style.height = 0;
              itemEl.style.paddingTop = 0;
              itemEl.style.paddingBottom = 0;
            }

            setTimeout(function () {
              itemEl.style.transition = "";
              itemEl.style.height = "";
              itemEl.style.overflow = itemEl.dataset.oldOverflow;
              itemEl.style.paddingTop = itemEl.dataset.oldPaddingTop;
              itemEl.style.paddingBottom = itemEl.dataset.oldPaddingBottom;
            }, 500);
          }

          setTimeout(function () {
            cardVnode.$el.classList.add("collapsed-card");
          }, 500);
        });
      }
    };
  }
};
// CONCATENATED MODULE: ./src/directives/card/index.js



var VNlyCardPlugin = plugins_nlyPluginFactory({
  directives: {
    VNlyCardMaximized: VNlyCardMaximized,
    VNlyCardCollapse: VNlyCardCollapse
  }
});

// CONCATENATED MODULE: ./src/directives/modal/modal.js




 // Emitted show event for modal

var EVENT_SHOW = "nlya::show::modal"; // Prop name we use to store info on root element

var PROPERTY = "__nlya_modal_directive__";

var modal_getTarget = function getTarget(_ref) {
  var _ref$modifiers = _ref.modifiers,
      modifiers = _ref$modifiers === void 0 ? {} : _ref$modifiers,
      arg = _ref.arg,
      value = _ref.value;
  // Try value, then arg, otherwise pick last modifier
  return isString(value) ? value : isString(arg) ? arg : keys(modifiers).reverse()[0];
};

var modal_getTriggerElement = function getTriggerElement(el) {
  // If root element is a dropdown-item or nav-item, we
  // need to target the inner link or button instead
  return el && matches(el, ".dropdown-menu > li, li.nav-item") ? dom_select("a, button", el) || el : el;
};

var modal_setRole = function setRole(trigger) {
  // Ensure accessibility on non button elements
  if (trigger && trigger.tagName !== "BUTTON") {
    // Only set a role if the trigger element doesn't have one
    if (!hasAttr(trigger, "role")) {
      setAttr(trigger, "role", "button");
    } // Add a tabindex is not a button or link, and tabindex is not provided


    if (trigger.tagName !== "A" && !hasAttr(trigger, "tabindex")) {
      setAttr(trigger, "tabindex", "0");
    }
  }
};

var modal_bind = function bind(el, binding, vnode) {
  var target = modal_getTarget(binding);
  var trigger = modal_getTriggerElement(el);

  if (target && trigger) {
    var handler = function handler(evt) {
      // `currentTarget` is the element with the listener on it
      var currentTarget = evt.currentTarget;

      if (!dom_isDisabled(currentTarget)) {
        var type = evt.type;
        var key = evt.keyCode; // Open modal only if trigger is not disabled

        if (type === "click" || type === "keydown" && (key === key_codes.ENTER || key === key_codes.SPACE)) {
          vnode.context.$root.$emit(EVENT_SHOW, target, currentTarget);
        }
      }
    };

    el[PROPERTY] = {
      handler: handler,
      target: target,
      trigger: trigger
    }; // If element is not a button, we add `role="button"` for accessibility

    modal_setRole(trigger); // Listen for click events

    eventOn(trigger, "click", handler, EVENT_OPTIONS_PASSIVE);

    if (trigger.tagName !== "BUTTON" && getAttr(trigger, "role") === "button") {
      // If trigger isn't a button but has role button,
      // we also listen for `keydown.space` && `keydown.enter`
      eventOn(trigger, "keydown", handler, EVENT_OPTIONS_PASSIVE);
    }
  }
};

var modal_unbind = function unbind(el) {
  var oldProp = el[PROPERTY] || {};
  var trigger = oldProp.trigger;
  var handler = oldProp.handler;

  if (trigger && handler) {
    eventOff(trigger, "click", handler, EVENT_OPTIONS_PASSIVE);
    eventOff(trigger, "keydown", handler, EVENT_OPTIONS_PASSIVE);
    eventOff(el, "click", handler, EVENT_OPTIONS_PASSIVE);
    eventOff(el, "keydown", handler, EVENT_OPTIONS_PASSIVE);
  }

  delete el[PROPERTY];
};

var componentUpdated = function componentUpdated(el, binding, vnode) {
  var oldProp = el[PROPERTY] || {};
  var target = modal_getTarget(binding);
  var trigger = modal_getTriggerElement(el);

  if (target !== oldProp.target || trigger !== oldProp.trigger) {
    // We bind and rebind if the target or trigger changes
    modal_unbind(el, binding, vnode);
    modal_bind(el, binding, vnode);
  } // If trigger element is not a button, ensure `role="button"`
  // is still set for accessibility


  modal_setRole(trigger);
};

var updated = function updated() {};
/*
 * Export our directive
 */


var VNlyModal = {
  inserted: componentUpdated,
  updated: updated,
  componentUpdated: componentUpdated,
  unbind: modal_unbind
};
// CONCATENATED MODULE: ./src/directives/modal/index.js


var VNlyModalPlugin = plugins_nlyPluginFactory({
  directives: {
    VNlyModal: VNlyModal
  }
});

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.match.js
var es_string_match = __webpack_require__("466d");

// CONCATENATED MODULE: ./src/directives/scrollspy/scrollspy.class.js
























var scrollspy_class_NAME = "v-ny-scrollspy";
var ACTIVATE_EVENT = "nlya::scrollspy::activate";
var Default = {
  element: "body",
  offset: 10,
  method: "auto",
  throttle: 75
};
var DefaultType = {
  element: "(string|element|component)",
  offset: "number",
  method: "string",
  throttle: "number"
};
var ClassName = {
  DROPDOWN_ITEM: "dropdown-item",
  ACTIVE: "active"
};
var scrollspy_class_Selector = {
  ACTIVE: ".active",
  NAV_LIST_GROUP: ".nav, .list-group",
  NAV_LINKS: ".nav-link",
  NAV_ITEMS: ".nav-item",
  LIST_ITEMS: ".list-group-item",
  DROPDOWN: ".dropdown, .dropup",
  DROPDOWN_ITEMS: ".dropdown-item",
  DROPDOWN_TOGGLE: ".dropdown-toggle"
};
var OffsetMethod = {
  OFFSET: "offset",
  POSITION: "position"
};
var HREF_REGEX = /^.*(#[^#]+)$/;
var TransitionEndEvents = ["webkitTransitionEnd", "transitionend", "otransitionend", "oTransitionEnd"];

var scrollspy_class_toType = function toType(obj) {
  return object_toString(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
};

var scrollspy_class_typeCheckConfig = function typeCheckConfig(componentName, config, configTypes) {
  for (var property in configTypes) {
    if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
      var expectedTypes = configTypes[property];
      var value = config[property];
      var valueType = value && isElement(value) ? "element" : scrollspy_class_toType(value);
      valueType = value && value._isVue ? "component" : valueType;

      if (!new RegExp(expectedTypes).test(valueType)) {
        warn_warn("".concat(componentName, ": Option \"").concat(property, "\" provided type \"").concat(valueType, "\" but expected type \"").concat(expectedTypes, "\""));
      }
    }
  }
};

var scrollspy_class_ScrollSpy = /*#__PURE__*/function () {
  function ScrollSpy(element, config, $root) {
    _classCallCheck(this, ScrollSpy);

    this.$el = element;
    this.$scroller = null;
    this.$selector = [scrollspy_class_Selector.NAV_LINKS, scrollspy_class_Selector.LIST_ITEMS, scrollspy_class_Selector.DROPDOWN_ITEMS].join(",");
    this.$offsets = [];
    this.$targets = [];
    this.$activeTarget = null;
    this.$scrollHeight = 0;
    this.$resizeTimeout = null;
    this.$obs_scroller = null;
    this.$obs_targets = null;
    this.$root = $root || null;
    this.$config = null;
    this.updateConfig(config);
  }

  _createClass(ScrollSpy, [{
    key: "updateConfig",
    value: function updateConfig(config, $root) {
      if (this.$scroller) {
        // Just in case out scroll element has changed
        this.unlisten();
        this.$scroller = null;
      }

      var cfg = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.constructor.Default), config);

      if ($root) {
        this.$root = $root;
      }

      scrollspy_class_typeCheckConfig(this.constructor.Name, cfg, this.constructor.DefaultType);
      this.$config = cfg;

      if (this.$root) {
        var self = this;
        this.$root.$nextTick(function () {
          self.listen();
        });
      } else {
        this.listen();
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.unlisten();
      clearTimeout(this.$resizeTimeout);
      this.$resizeTimeout = null;
      this.$el = null;
      this.$config = null;
      this.$scroller = null;
      this.$selector = null;
      this.$offsets = null;
      this.$targets = null;
      this.$activeTarget = null;
      this.$scrollHeight = null;
    }
  }, {
    key: "listen",
    value: function listen() {
      var _this = this;

      var scroller = this.getScroller();

      if (scroller && scroller.tagName !== "BODY") {
        eventOn(scroller, "scroll", this, EVENT_OPTIONS_NO_CAPTURE);
      }

      eventOn(window, "scroll", this, EVENT_OPTIONS_NO_CAPTURE);
      eventOn(window, "resize", this, EVENT_OPTIONS_NO_CAPTURE);
      eventOn(window, "orientationchange", this, EVENT_OPTIONS_NO_CAPTURE);
      TransitionEndEvents.forEach(function (evtName) {
        eventOn(window, evtName, _this, EVENT_OPTIONS_NO_CAPTURE);
      });
      this.setObservers(true); // Schedule a refresh

      this.handleEvent("refresh");
    }
  }, {
    key: "unlisten",
    value: function unlisten() {
      var _this2 = this;

      var scroller = this.getScroller();
      this.setObservers(false);

      if (scroller && scroller.tagName !== "BODY") {
        eventOff(scroller, "scroll", this, EVENT_OPTIONS_NO_CAPTURE);
      }

      eventOff(window, "scroll", this, EVENT_OPTIONS_NO_CAPTURE);
      eventOff(window, "resize", this, EVENT_OPTIONS_NO_CAPTURE);
      eventOff(window, "orientationchange", this, EVENT_OPTIONS_NO_CAPTURE);
      TransitionEndEvents.forEach(function (evtName) {
        eventOff(window, evtName, _this2, EVENT_OPTIONS_NO_CAPTURE);
      });
    }
  }, {
    key: "setObservers",
    value: function setObservers(on) {
      var _this3 = this;

      // We observe both the scroller for content changes, and the target links
      if (this.$obs_scroller) {
        this.$obs_scroller.disconnect();
        this.$obs_scroller = null;
      }

      if (this.$obs_targets) {
        this.$obs_targets.disconnect();
        this.$obs_targets = null;
      }

      if (on) {
        this.$obs_targets = observe_dom(this.$el, function () {
          _this3.handleEvent("mutation");
        }, {
          subtree: true,
          childList: true,
          attributes: true,
          attributeFilter: ["href"]
        });
        this.$obs_scroller = observe_dom(this.getScroller(), function () {
          _this3.handleEvent("mutation");
        }, {
          subtree: true,
          childList: true,
          characterData: true,
          attributes: true,
          attributeFilter: ["id", "style", "class"]
        });
      }
    } // General event handler

  }, {
    key: "handleEvent",
    value: function handleEvent(evt) {
      var type = isString(evt) ? evt : evt.type;
      var self = this;

      var resizeThrottle = function resizeThrottle() {
        if (!self.$resizeTimeout) {
          self.$resizeTimeout = setTimeout(function () {
            self.refresh();
            self.process();
            self.$resizeTimeout = null;
          }, self.$config.throttle);
        }
      };

      if (type === "scroll") {
        if (!this.$obs_scroller) {
          // Just in case we are added to the DOM before the scroll target is
          // We re-instantiate our listeners, just in case
          this.listen();
        }

        this.process();
      } else if (/(resize|orientationchange|mutation|refresh)/.test(type)) {
        // Postpone these events by throttle time
        resizeThrottle();
      }
    } // Refresh the list of target links on the element we are applied to

  }, {
    key: "refresh",
    value: function refresh() {
      var _this4 = this;

      var scroller = this.getScroller();

      if (!scroller) {
        return;
      }

      var autoMethod = scroller !== scroller.window ? OffsetMethod.POSITION : OffsetMethod.OFFSET;
      var method = this.$config.method === "auto" ? autoMethod : this.$config.method;
      var methodFn = method === OffsetMethod.POSITION ? dom_position : offset;
      var offsetBase = method === OffsetMethod.POSITION ? this.getScrollTop() : 0;
      this.$offsets = [];
      this.$targets = [];
      this.$scrollHeight = this.getScrollHeight(); // Find all the unique link HREFs that we will control

      dom_selectAll(this.$selector, this.$el) // Get HREF value
      .map(function (link) {
        return getAttr(link, "href");
      }) // Filter out HREFs that do not match our RegExp
      .filter(function (href) {
        return href && HREF_REGEX.test(href || "");
      }) // Find all elements with ID that match HREF hash
      .map(function (href) {
        // Convert HREF into an ID (including # at beginning)
        var id = href.replace(HREF_REGEX, "$1").trim();

        if (!id) {
          return null;
        } // Find the element with the ID specified by id


        var el = dom_select(id, scroller);

        if (el && isVisible(el)) {
          return {
            offset: toInteger(methodFn(el).top, 0) + offsetBase,
            target: id
          };
        }

        return null;
      }).filter(Boolean) // Sort them by their offsets (smallest first)
      .sort(function (a, b) {
        return a.offset - b.offset;
      }) // record only unique targets/offsets
      .reduce(function (memo, item) {
        if (!memo[item.target]) {
          _this4.$offsets.push(item.offset);

          _this4.$targets.push(item.target);

          memo[item.target] = true;
        }

        return memo;
      }, {}); // Return this for easy chaining

      return this;
    } // Handle activating/clearing

  }, {
    key: "process",
    value: function process() {
      var scrollTop = this.getScrollTop() + this.$config.offset;
      var scrollHeight = this.getScrollHeight();
      var maxScroll = this.$config.offset + scrollHeight - this.getOffsetHeight();

      if (this.$scrollHeight !== scrollHeight) {
        this.refresh();
      }

      if (scrollTop >= maxScroll) {
        var target = this.$targets[this.$targets.length - 1];

        if (this.$activeTarget !== target) {
          this.activate(target);
        }

        return;
      }

      if (this.$activeTarget && scrollTop < this.$offsets[0] && this.$offsets[0] > 0) {
        this.$activeTarget = null;
        this.clear();
        return;
      }

      for (var i = this.$offsets.length; i--;) {
        var isActiveTarget = this.$activeTarget !== this.$targets[i] && scrollTop >= this.$offsets[i] && (isUndefined(this.$offsets[i + 1]) || scrollTop < this.$offsets[i + 1]);

        if (isActiveTarget) {
          this.activate(this.$targets[i]);
        }
      }
    }
  }, {
    key: "getScroller",
    value: function getScroller() {
      if (this.$scroller) {
        return this.$scroller;
      }

      var scroller = this.$config.element;

      if (!scroller) {
        return null;
      } else if (isElement(scroller.$el)) {
        scroller = scroller.$el;
      } else if (isString(scroller)) {
        scroller = dom_select(scroller);
      }

      if (!scroller) {
        return null;
      }

      this.$scroller = scroller.tagName === "BODY" ? window : scroller;
      return this.$scroller;
    }
  }, {
    key: "getScrollTop",
    value: function getScrollTop() {
      var scroller = this.getScroller();
      return scroller === window ? scroller.pageYOffset : scroller.scrollTop;
    }
  }, {
    key: "getScrollHeight",
    value: function getScrollHeight() {
      return this.getScroller().scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
    }
  }, {
    key: "getOffsetHeight",
    value: function getOffsetHeight() {
      var scroller = this.getScroller();
      return scroller === window ? window.innerHeight : getBCR(scroller).height;
    }
  }, {
    key: "activate",
    value: function activate(target) {
      var _this5 = this;

      this.$activeTarget = target;
      this.clear(); // Grab the list of target links (<a href="{$target}">)

      var links = dom_selectAll(this.$selector // Split out the base selectors
      .split(",") // Map to a selector that matches links with HREF ending in the ID (including '#')
      .map(function (selector) {
        return "".concat(selector, "[href$=\"").concat(target, "\"]");
      }) // Join back into a single selector string
      .join(","), this.$el);
      links.forEach(function (link) {
        if (hasClass(link, ClassName.DROPDOWN_ITEM)) {
          // This is a dropdown item, so find the .dropdown-toggle and set its state
          var dropdown = closest(scrollspy_class_Selector.DROPDOWN, link);

          if (dropdown) {
            _this5.setActiveState(dom_select(scrollspy_class_Selector.DROPDOWN_TOGGLE, dropdown), true);
          } // Also set this link's state


          _this5.setActiveState(link, true);
        } else {
          // Set triggered link as active
          _this5.setActiveState(link, true);

          if (matches(link.parentElement, scrollspy_class_Selector.NAV_ITEMS)) {
            // Handle nav-link inside nav-item, and set nav-item active
            _this5.setActiveState(link.parentElement, true);
          } // Set triggered links parents as active
          // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor


          var el = link;

          while (el) {
            el = closest(scrollspy_class_Selector.NAV_LIST_GROUP, el);
            var sibling = el ? el.previousElementSibling : null;

            if (sibling && matches(sibling, "".concat(scrollspy_class_Selector.NAV_LINKS, ", ").concat(scrollspy_class_Selector.LIST_ITEMS))) {
              _this5.setActiveState(sibling, true);
            } // Handle special case where nav-link is inside a nav-item


            if (sibling && matches(sibling, scrollspy_class_Selector.NAV_ITEMS)) {
              _this5.setActiveState(dom_select(scrollspy_class_Selector.NAV_LINKS, sibling), true); // Add active state to nav-item as well


              _this5.setActiveState(sibling, true);
            }
          }
        }
      }); // Signal event to via $root, passing ID of activated target and reference to array of links

      if (links && links.length > 0 && this.$root) {
        this.$root.$emit(ACTIVATE_EVENT, target, links);
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      var _this6 = this;

      dom_selectAll("".concat(this.$selector, ", ").concat(scrollspy_class_Selector.NAV_ITEMS), this.$el).filter(function (el) {
        return hasClass(el, ClassName.ACTIVE);
      }).forEach(function (el) {
        return _this6.setActiveState(el, false);
      });
    }
  }, {
    key: "setActiveState",
    value: function setActiveState(el, active) {
      if (!el) {
        return;
      }

      if (active) {
        addClass(el, ClassName.ACTIVE);
      } else {
        removeClass(el, ClassName.ACTIVE);
      }
    }
  }], [{
    key: "Name",
    get: function get() {
      return scrollspy_class_NAME;
    }
  }, {
    key: "Default",
    get: function get() {
      return Default;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType;
    }
  }]);

  return ScrollSpy;
}();

/* harmony default export */ var scrollspy_class = (scrollspy_class_ScrollSpy);
// CONCATENATED MODULE: ./src/directives/scrollspy/scrollspy.js








var NLYA_SCROLLSPY = "__NLYA_ScrollSpy__";
var onlyDigitsRE = /^\d+$/;
var scrollspy_offsetRE = /^(auto|position|offset)$/;

var scrollspy_parseBindings = function parseBindings(bindings) {
  var config = {};

  if (bindings.arg) {
    config.element = "#".concat(bindings.arg);
  }

  keys(bindings.modifiers).forEach(function (mod) {
    if (onlyDigitsRE.test(mod)) {
      config.offset = toInteger(mod, 0);
    } else if (scrollspy_offsetRE.test(mod)) {
      config.method = mod;
    }
  }); // Process value

  if (isString(bindings.value)) {
    config.element = bindings.value;
  } else if (isNumber(bindings.value)) {
    config.offset = Math.round(bindings.value);
  } else if (object_isObject(bindings.value)) {
    keys(bindings.value).filter(function (k) {
      return !!scrollspy_class.DefaultType[k];
    }).forEach(function (k) {
      config[k] = bindings.value[k];
    });
  }

  return config;
};

var scrollspy_applyScrollspy = function applyScrollspy(el, bindings, vnode) {
  if (!env["g" /* isBrowser */]) {
    return;
  }

  var config = scrollspy_parseBindings(bindings);

  if (el[NLYA_SCROLLSPY]) {
    el[NLYA_SCROLLSPY].updateConfig(config, vnode.context.$root);
  } else {
    el[NLYA_SCROLLSPY] = new scrollspy_class(el, config, vnode.context.$root);
  }
};

var removeScrollspy = function removeScrollspy(el) {
  if (el[NLYA_SCROLLSPY]) {
    el[NLYA_SCROLLSPY].dispose();
    el[NLYA_SCROLLSPY] = null;
    delete el[NLYA_SCROLLSPY];
  }
};

var VNlyScrollspy = {
  bind: function bind(el, bindings, vnode) {
    scrollspy_applyScrollspy(el, bindings, vnode);
  },
  inserted: function inserted(el, bindings, vnode) {
    scrollspy_applyScrollspy(el, bindings, vnode);
  },
  update: function update(el, bindings, vnode) {
    if (bindings.value !== bindings.oldValue) {
      scrollspy_applyScrollspy(el, bindings, vnode);
    }
  },
  componentUpdated: function componentUpdated(el, bindings, vnode) {
    if (bindings.value !== bindings.oldValue) {
      scrollspy_applyScrollspy(el, bindings, vnode);
    }
  },
  unbind: function unbind(el) {
    removeScrollspy(el);
  }
};
// CONCATENATED MODULE: ./src/directives/scrollspy/index.js


var VNlyScrollspyPlugin = plugins_nlyPluginFactory({
  directives: {
    VNlyScrollspy: VNlyScrollspy
  }
});

// CONCATENATED MODULE: ./src/directives/index.js








var directivesPlugin = plugins_nlyPluginFactory({
  plugins: {
    VNlyCardPlugin: VNlyCardPlugin,
    VNlyCollapseSidebarPlugin: VNlyCollapseSidebarPlugin,
    VNlyTogglePlugin: VNlyTogglePlugin,
    VNlyModalPlugin: VNlyModalPlugin,
    VNlyTooltipPlugin: VNlyTooltipPlugin,
    VNlyScrollspyPlugin: VNlyScrollspyPlugin,
    VNlyPopoverPlugin: VNlyPopoverPlugin
  }
});
// CONCATENATED MODULE: ./src/components/icons/index.js


var IconsPlugin = plugins_nlyPluginFactory({
  components: {
    NlyIcon: NlyIcon
  }
});

// CONCATENATED MODULE: ./src/icon.js


var icon_NAME = "NlyAdminlteVueIcons";
var icon_install = plugins_nlyInstallFactory({
  plugins: {
    IconsPlugin: IconsPlugin
  }
});
var NlyAdminlteVueIcons = {
  install: icon_install,
  NAME: icon_NAME
};

/* harmony default export */ var icon = (NlyAdminlteVueIcons);
// CONCATENATED MODULE: ./src/index.js



var src_NAME = "NlyAdminlteVue";
var src_install = plugins_nlyInstallFactory({
  plugins: {
    componentsPlugin: componentsPlugin,
    directivesPlugin: directivesPlugin
  }
});
var NlyAdminlteVue = {
  install: src_install,
  NAME: src_NAME
};





































































































































































































/* harmony default export */ var src_0 = (NlyAdminlteVue);
// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = __webpack_exports__["default"] = (src_0);



/***/ }),

/***/ "fb6a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var isObject = __webpack_require__("861d");
var isArray = __webpack_require__("e8b5");
var toAbsoluteIndex = __webpack_require__("23cb");
var toLength = __webpack_require__("50c4");
var toIndexedObject = __webpack_require__("fc6a");
var createProperty = __webpack_require__("8418");
var wellKnownSymbol = __webpack_require__("b622");
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');
var USES_TO_LENGTH = arrayMethodUsesToLength('slice', { ACCESSORS: true, 0: 0, 1: 2 });

var SPECIES = wellKnownSymbol('species');
var nativeSlice = [].slice;
var max = Math.max;

// `Array.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === Array || Constructor === undefined) {
        return nativeSlice.call(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});


/***/ }),

/***/ "fc6a":
/***/ (function(module, exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__("44ad");
var requireObjectCoercible = __webpack_require__("1d80");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "fdbc":
/***/ (function(module, exports) {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ "fdbf":
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_SYMBOL = __webpack_require__("4930");

module.exports = NATIVE_SYMBOL
  // eslint-disable-next-line no-undef
  && !Symbol.sham
  // eslint-disable-next-line no-undef
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ "fea9":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

module.exports = global.Promise;


/***/ })

/******/ });
//# sourceMappingURL=nly-adminlte-vue.common.js.map